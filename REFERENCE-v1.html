<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Standalone Documentation IDE</title>
    
    <!-- External Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #252526;
            --bg-tertiary: #2d2d30;
            --border-color: #3e3e42;
            --text-primary: #cccccc;
            --text-secondary: #969696;
            --text-active: #ffffff;
            --accent-primary: #007acc;
            --accent-hover: #1177bb;
            --success-color: #10b981;
            --error-color: #ef4444;
            --warning-color: #f0883e;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            overflow: hidden;
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .ide-container {
            display: flex;
            height: 100vh;
            flex-direction: column;
        }

        /* Header */
        .ide-header {
            height: 48px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 16px;
            justify-content: space-between;
            z-index: 100;
        }

        .ide-title {
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .system-info {
            font-size: 12px;
            color: var(--text-secondary);
            margin-left: 8px;
        }
        
        .system-picker {
            background: var(--border-color);
            border: 1px solid #5a5a5a;
            color: var(--text-primary);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            max-width: 300px;
            transition: background 0.2s;
        }
        
        .system-picker:hover {
            background: #505050;
        }

        .header-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .btn {
            background: #0e639c;
            border: none;
            color: white;
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover:not(:disabled) {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: var(--border-color);
        }

        .btn-secondary:hover:not(:disabled) {
            background: #505050;
        }

        .btn-icon {
            padding: 6px 10px;
            font-size: 14px;
        }

        /* Body */
        .ide-body {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            flex: 0 0 auto;
            min-width: 200px;
            max-width: 600px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: none; /* Disable transition during resize */
            position: relative;
        }

        .sidebar.collapsed {
            width: 0;
            min-width: 0;
        }

        /* Resize handles - Make visible and functional */
        .resize-handle {
            position: absolute;
            background: linear-gradient(90deg, transparent 0%, rgba(0, 122, 204, 0.3) 50%, transparent 100%);
            z-index: 1000;
            transition: background 0.15s;
        }

        .resize-handle:hover {
            background: linear-gradient(90deg, transparent 0%, var(--accent-primary) 50%, transparent 100%);
        }

        .resize-handle.active {
            background: var(--accent-primary);
        }

        .resize-handle-vertical {
            width: 8px;
            top: 0;
            bottom: 0;
            cursor: col-resize;
            -webkit-user-select: none;
            user-select: none;
        }

        .sidebar .resize-handle-vertical {
            right: -4px;
        }

        .preview-pane .resize-handle-vertical {
            left: -4px;
        }

        .ai-panel .resize-handle-vertical {
            left: -4px;
        }

        .sidebar-header {
            padding: 12px 16px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-primary);
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-tree {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 8px 0;
            user-select: none;
        }

        .file-tree::-webkit-scrollbar {
            width: 8px;
        }

        .file-tree::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .tree-item {
            display: block;
        }

        .file-item, .folder-item {
            padding: 4px 12px 4px 8px;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background 0.15s;
            white-space: nowrap;
        }

        .file-item:hover, .folder-item:hover {
            background: #2a2d2e;
        }

        .file-item.active {
            background: #37373d;
            color: var(--text-active);
        }

        .folder-item {
            font-weight: 500;
        }

        .folder-chevron {
            font-size: 10px;
            color: var(--text-secondary);
            transition: transform 0.2s;
            width: 12px;
            text-align: center;
        }

        .folder-chevron.expanded {
            transform: rotate(90deg);
        }

        .folder-icon, .file-icon {
            font-size: 14px;
        }

        .file-icon {
            margin-left: 18px;
        }

        .folder-contents {
            padding-left: 16px;
        }

        .folder-contents.collapsed {
            display: none;
        }

        /* Editor Container */
        .editor-container {
            flex: 1;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
            position: relative;
            overflow: hidden;
        }

        /* Tabs Bar */
        .tabs-bar {
            height: 35px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            overflow-x: auto;
        }

        .tabs-bar::-webkit-scrollbar {
            height: 3px;
        }

        .tabs-bar::-webkit-scrollbar-thumb {
            background: var(--border-color);
        }

        /* Breadcrumb Bar */
        .breadcrumb-bar {
            user-select: none;
        }

        .breadcrumb-bar::-webkit-scrollbar {
            height: 3px;
        }

        .breadcrumb-bar::-webkit-scrollbar-thumb {
            background: var(--border-color);
        }

        .breadcrumb-item {
            display: inline-block;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: background 0.15s, color 0.15s;
        }

        .breadcrumb-item:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .breadcrumb-item.active {
            color: var(--text-active);
            font-weight: 500;
        }

        .breadcrumb-separator {
            display: inline-block;
            margin: 0 6px;
            color: var(--text-secondary);
            font-size: 10px;
        }

        .tab {
            padding: 8px 16px;
            background: transparent;
            border: none;
            border-right: 1px solid var(--border-color);
            color: var(--text-secondary);
            cursor: pointer;
            white-space: nowrap;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.15s, color 0.15s;
            max-width: 200px;
        }

        .tab:hover {
            background: #2a2d2e;
            color: var(--text-primary);
        }

        .tab.active {
            background: var(--bg-primary);
            color: var(--text-active);
        }

        .tab.pinned {
            background: var(--bg-secondary);
            border-left: 2px solid #0e639c;
        }

        .tab.pinned.active {
            background: var(--bg-primary);
        }

        .tab.dragging {
            opacity: 0.5;
        }

        .tab.drag-over {
            border-left: 2px solid #0e639c;
        }

        .tab-pin {
            opacity: 0;
            margin-right: 4px;
            font-size: 12px;
            line-height: 1;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .tab:hover .tab-pin {
            opacity: 0.6;
        }

        .tab-pin:hover {
            opacity: 1;
        }

        .tab.pinned .tab-pin {
            opacity: 0.8;
        }

        .tab-close {
            opacity: 0;
            margin-left: 4px;
            font-size: 16px;
            line-height: 1;
            transition: opacity 0.2s;
        }

        .tab:hover .tab-close {
            opacity: 0.6;
        }

        .tab-close:hover {
            opacity: 1;
        }

        /* Split View */
        .editor-split-container {
            flex: 1;
            display: flex;
            overflow: hidden;
            min-width: 0; /* Critical for flex overflow handling */
        }

        .editor-pane {
            flex: 1 1 0;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .preview-pane {
            width: 400px;
            flex: 0 0 auto;
            min-width: 300px;
            max-width: 800px;
            background: var(--bg-primary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .preview-pane.hidden {
            display: none;
        }

        .preview-pane .resize-handle-vertical {
            left: -2px;
            right: auto;
        }

        .preview-header {
            height: 35px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            padding: 0 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            font-weight: 600;
        }

        .preview-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            color: var(--text-primary);
        }

        .preview-content h1, .preview-content h2, .preview-content h3 {
            color: var(--text-active);
            margin-top: 24px;
            margin-bottom: 12px;
        }

        .preview-content h1 { font-size: 28px; }
        .preview-content h2 { font-size: 22px; }
        .preview-content h3 { font-size: 18px; }

        .preview-content p {
            margin-bottom: 12px;
            line-height: 1.6;
        }

        .preview-content code {
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .preview-content pre {
            background: var(--bg-secondary);
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 12px 0;
        }

        .preview-content pre code {
            background: none;
            padding: 0;
        }

        /* AI Chat Panel */
        .ai-panel {
            width: 400px;
            flex: 0 0 auto;
            min-width: 300px;
            max-width: 800px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .ai-panel.hidden {
            display: none;
        }

        .ai-panel .resize-handle-vertical {
            left: -2px;
            right: auto;
        }

        .ai-header {
            height: 35px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            padding: 0 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            font-weight: 600;
        }

        .ai-chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .ai-message {
            margin-bottom: 16px;
            animation: fadeIn 0.3s ease-out;
        }

        .ai-message-header {
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 6px;
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        .ai-message-content {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 6px;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .ai-message.user .ai-message-header {
            color: #0e639c;
        }

        .ai-message.user .ai-message-content {
            background: #1e3a5f;
        }

        .ai-message.assistant .ai-message-header {
            color: #10b981;
        }

        .ai-message.assistant .ai-message-content {
            background: var(--bg-tertiary);
        }

        .ai-message.error .ai-message-content {
            background: #3d2020;
            color: var(--error-color);
        }

        .ai-message-actions {
            margin-top: 8px;
            display: flex;
            gap: 8px;
        }

        .ai-quick-actions {
            padding: 12px 16px;
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
        }

        .ai-quick-actions-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .ai-quick-action-btn {
            display: block;
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            text-align: left;
            margin-bottom: 6px;
            transition: all 0.15s;
        }

        .ai-quick-action-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        .ai-input-container {
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
        }

        .ai-input {
            width: 100%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 13px;
            font-family: inherit;
            resize: vertical;
            min-height: 60px;
            max-height: 200px;
        }

        .ai-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .ai-send-btn {
            margin-top: 8px;
            width: 100%;
            background: var(--accent-primary);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .ai-send-btn:hover:not(:disabled) {
            background: var(--accent-hover);
        }

        .ai-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .ai-thinking {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .ai-thinking-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Editor Wrapper */
        .editor-wrapper {
            flex: 1;
            position: relative;
        }

        #monaco-editor {
            width: 100%;
            height: 100%;
        }
        
        #monaco-diff-editor {
            width: 100%;
            height: 100%;
        }
        
        #monaco-diff-editor.hidden {
            display: none;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-primary);
            font-size: 14px;
            z-index: 50;
        }

        .loading-overlay.hidden {
            display: none;
        }

        /* Command Palette */
        .command-palette {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            max-width: 90vw;
            max-height: 400px;
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-primary);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            z-index: 10000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .command-palette.hidden {
            display: none;
        }

        .command-palette input {
            width: 100%;
            padding: 16px;
            background: var(--border-color);
            border: none;
            color: var(--text-primary);
            font-size: 14px;
            outline: none;
        }

        .command-results {
            flex: 1;
            overflow-y: auto;
        }

        .command-item {
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.15s;
            border-left: 3px solid transparent;
        }

        .command-item:hover, .command-item.selected {
            background: var(--bg-secondary);
            border-left-color: var(--accent-primary);
        }

        .command-label {
            font-size: 13px;
        }

        .command-keys {
            font-size: 11px;
            color: var(--text-secondary);
            background: var(--bg-secondary);
            padding: 2px 8px;
            border-radius: 3px;
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 400px;
            height: 100vh;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.3s;
            box-shadow: -4px 0 12px rgba(0,0,0,0.3);
        }

        .settings-panel.open {
            transform: translateX(0);
        }

        .settings-header {
            height: 48px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            padding: 0 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 600;
        }

        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .setting-group {
            margin-bottom: 24px;
        }

        .setting-group-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        .setting-item {
            margin-bottom: 16px;
        }

        .setting-label {
            font-size: 13px;
            margin-bottom: 6px;
            display: block;
        }

        .setting-input {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
            font-size: 13px;
        }

        .setting-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .setting-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .setting-checkbox input {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* Search Panel */
        .search-panel {
            position: absolute;
            top: 50px;
            right: 20px;
            width: 350px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            z-index: 1000;
            padding: 12px;
        }

        .search-panel.hidden {
            display: none;
        }

        .search-input-group {
            margin-bottom: 8px;
        }

        .search-input {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
            font-size: 13px;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .search-options {
            display: flex;
            gap: 12px;
            margin-top: 8px;
            font-size: 12px;
        }

        .search-option {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
        }

        /* Keyboard Help */
        .keyboard-help {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 700px;
            max-width: 90vw;
            max-height: 80vh;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            z-index: 10000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .keyboard-help.hidden {
            display: none;
        }

        .keyboard-help-header {
            padding: 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            display: flex;
            justify-content: space-between;
        }

        .keyboard-help-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .shortcut-section {
            margin-bottom: 20px;
        }

        .shortcut-section-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 13px;
        }

        .shortcut-keys {
            color: var(--text-secondary);
            font-family: monospace;
        }

        /* Status Bar */
        .status-bar {
            height: 22px;
            background: var(--accent-primary);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 12px;
            font-size: 12px;
            justify-content: space-between;
        }

        .status-left, .status-right {
            display: flex;
            gap: 16px;
        }

        .status-item {
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .status-item:hover {
            opacity: 0.8;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 12px 20px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            font-size: 13px;
            z-index: 10001;
            animation: slideIn 0.3s ease-out;
        }

        .toast.success {
            border-left: 3px solid var(--success-color);
        }

        .toast.error {
            border-left: 3px solid var(--error-color);
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            z-index: 10000;
            min-width: 180px;
            padding: 4px 0;
        }

        .context-menu.hidden {
            display: none;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.15s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .context-menu-item:hover {
            background: var(--bg-secondary);
        }

        .context-menu-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .context-menu-item.disabled:hover {
            background: transparent;
        }
        
        .context-menu-item.danger {
            color: var(--error-color);
        }
        
        .context-menu-item span:first-child {
            margin-right: 8px;
        }

        .context-menu-separator {
            height: 1px;
            background: var(--border-color);
            margin: 4px 0;
        }

        /* Tooltips */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-4px);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            border: 1px solid var(--border-color);
            z-index: 10000;
        }

        [data-tooltip]:hover::after {
            opacity: 1;
        }

        /* Overlay for modals */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9998;
        }

        .overlay.hidden {
            display: none;
        }

        /* Smooth transitions */
        * {
            transition-property: background-color, color, border-color, opacity, transform;
            transition-duration: 0.2s;
            transition-timing-function: ease;
        }

        input, select, button, .tab, .file-item {
            transition-property: background-color, color, border-color, opacity, transform;
        }

        /* ========================================================================== */
        /* EDIT QUEUE PANEL - Cursor-style edit review */
        /* ========================================================================== */
        
        .edit-queue-panel {
            position: fixed;
            right: 0;
            top: 60px;
            bottom: 0;
            width: 340px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transform: translateX(0);
            transition: transform 0.3s ease;
        }

        .edit-queue-panel.hidden {
            transform: translateX(100%);
        }

        .edit-queue-header {
            padding: 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .edit-queue-header h3 {
            font-size: 14px;
            font-weight: 600;
            margin: 0;
        }

        .edit-queue-actions {
            padding: 12px;
            display: flex;
            gap: 6px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .edit-queue-actions .btn {
            flex: 1;
            min-width: 80px;
            padding: 6px 10px;
            font-size: 11px;
        }

        .edit-queue-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .edit-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .edit-item:hover {
            background: var(--bg-hover);
            border-color: var(--accent-color);
        }

        .edit-item.accepted {
            border-left: 3px solid #10b981;
            opacity: 0.6;
        }

        .edit-item.rejected {
            border-left: 3px solid #ef4444;
            opacity: 0.6;
        }

        .edit-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .edit-item-file {
            font-weight: 600;
            font-size: 13px;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }

        .edit-item-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 6px;
        }

        .edit-item-status.pending {
            background: #3b82f6;
            color: white;
        }

        .edit-item-status.accepted {
            background: #10b981;
            color: white;
        }

        .edit-item-status.rejected {
            background: #ef4444;
            color: white;
        }

        .edit-item-summary {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .edit-item-actions {
            display: flex;
            gap: 6px;
        }

        .edit-item-actions button {
            flex: 1;
            padding: 4px 8px;
            font-size: 11px;
        }

        .edit-item.accepted .edit-item-actions,
        .edit-item.rejected .edit-item-actions {
            display: none;
        }
    </style>
</head>
<body>
    <div class="ide-container">
        <!-- Header -->
        <div class="ide-header">
            <div class="ide-title">
                <span style="font-size: 18px;">üåå</span>
                <span>COSMO Documentation IDE</span>
                <select class="system-picker" id="system-picker" onchange="switchSystem()">
                    <option value="">Loading systems...</option>
                </select>
            </div>
            <div class="header-actions">
                <button class="btn btn-icon" onclick="createNewFile()" data-tooltip="New File (Cmd+N)" title="Create new file">
                    üìÑ
                </button>
                <button class="btn btn-icon" onclick="createNewFolder()" data-tooltip="New Folder" title="Create new folder">
                    üìÅ
                </button>
                <button class="btn btn-icon" onclick="showCSVBuilder()" data-tooltip="New CSV Table" title="Create CSV spreadsheet">
                    üìä
                </button>
                <button class="btn btn-icon" onclick="togglePreview()" id="preview-btn" data-tooltip="Toggle Preview" style="display: none;">
                    üëÅÔ∏è
                </button>
                <button class="btn btn-icon" onclick="toggleAI()" id="ai-btn" data-tooltip="AI Assistant (Cmd+K A)" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    ü§ñ
                </button>
                <button class="btn btn-icon" onclick="toggleSearch()" data-tooltip="Search (Cmd+F)">
                    üîç
                </button>
                <button class="btn btn-icon" onclick="toggleSettings()" data-tooltip="Settings">
                    ‚öôÔ∏è
                </button>
                <button class="btn btn-icon" onclick="toggleKeyboardHelp()" data-tooltip="Keyboard Shortcuts (?)">
                    ‚å®Ô∏è
                </button>
                <button class="btn btn-icon" onclick="downloadCurrentFile()" id="download-btn" disabled data-tooltip="Download Current File">
                    ‚¨áÔ∏è
                </button>
                <button class="btn" onclick="saveCurrentFile()" id="save-btn" disabled data-tooltip="Save (Cmd+S)">
                    üíæ Save
                </button>
                <button class="btn btn-secondary" onclick="saveAllFiles()" id="save-all-btn" disabled data-tooltip="Save All (Cmd+Shift+S)">
                    Save All
                </button>
                <button class="btn btn-secondary" onclick="goBackToPicker()">
                    üè† Home
                </button>
            </div>
        </div>

        <!-- Body -->
        <div class="ide-body">
            <!-- Sidebar -->
            <div class="sidebar" id="sidebar">
                <div class="resize-handle resize-handle-vertical" data-target="sidebar"></div>
                <div class="sidebar-header">
                    <span>DOCUMENTATION FILES</span>
                    <button class="btn btn-icon" onclick="toggleSidebar()" data-tooltip="Toggle Sidebar" style="background: none; padding: 0;">
                        ‚óÄ
                    </button>
                </div>
                <div class="file-tree" id="file-tree">
                    <!-- Populated by JavaScript -->
                </div>
            </div>

            <!-- Editor -->
            <div class="editor-container">
                <div class="tabs-bar" id="tabs-bar">
                    <!-- Tabs populated by JavaScript -->
                </div>
                
                <div class="breadcrumb-bar" id="breadcrumb-bar" style="height: 28px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); padding: 0 16px; display: none; align-items: center; font-size: 12px; color: var(--text-secondary); overflow-x: auto; white-space: nowrap;">
                    <!-- Breadcrumb populated by JavaScript -->
                </div>
                
                <div class="editor-split-container">
                    <div class="editor-pane">
                        <!-- Diff Action Bar (shown in diff mode) -->
                        <div id="diff-action-bar" class="hidden" style="background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color); padding: 12px 16px; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-weight: 600; margin-right: 16px;">üìù Reviewing Changes</span>
                                <span id="diff-file-name" style="color: var(--text-secondary); font-size: 12px;"></span>
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-primary" onclick="acceptCurrentDiff()" id="accept-diff-inline-btn">
                                    ‚úì Accept Changes
                                </button>
                                <button class="btn btn-secondary" onclick="rejectCurrentDiff()">
                                    ‚úó Reject
                                </button>
                            </div>
                        </div>
                        
                        <div class="editor-wrapper">
                            <div id="monaco-editor"></div>
                            <div id="monaco-diff-editor" class="hidden"></div>
                            <div class="loading-overlay" id="loading-overlay">
                                <span>üåå Loading Monaco Editor...</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Markdown Preview Pane -->
                    <div class="preview-pane hidden" id="preview-pane">
                        <div class="resize-handle resize-handle-vertical" data-target="preview-pane"></div>
                        <div class="preview-header">
                            <span>üìÑ Preview</span>
                            <button onclick="togglePreview()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">√ó</button>
                        </div>
                        <div class="preview-content" id="preview-content">
                            <p style="color: var(--text-secondary);">Preview will appear here...</p>
                        </div>
                    </div>
                    
                    <!-- AI Chat Panel -->
                    <div class="ai-panel hidden" id="ai-panel">
                        <div class="resize-handle resize-handle-vertical" data-target="ai-panel"></div>
                        <div class="ai-header">
                            <span>ü§ñ AI Assistant</span>
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <button onclick="toggleChatHistory()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 14px; padding: 4px 8px;" title="View chat history for this folder">
                                    üìú
                                </button>
                                <button onclick="startNewChat()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 14px; padding: 4px 8px;" title="Start new conversation">
                                    ‚ûï
                                </button>
                                <button onclick="toggleAI()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">√ó</button>
                            </div>
                        </div>
                        
                        <div class="ai-quick-actions">
                            <div class="ai-quick-actions-title">ü§ñ Model</div>
                            <select id="ai-model-select" class="ai-quick-action-btn" style="cursor: pointer; padding: 6px 12px;">
                                <option value="claude-sonnet-4-5">Claude Sonnet 4.5 (Default - Fast)</option>
                                <option value="claude-opus-4-5">Claude Opus 4.5 (Most Capable)</option>
                                <option value="gpt-5.2">GPT-5.2</option>
                            </select>
                            <div class="ai-quick-actions-title" style="margin-top: 12px;">üí° Quick Actions</div>
                            <button class="ai-quick-action-btn" onclick="aiQuickAction('improve')">‚ú® Improve this section</button>
                            <button class="ai-quick-action-btn" onclick="aiQuickAction('summarize')">üìù Summarize document</button>
                            <button class="ai-quick-action-btn" onclick="aiQuickAction('grammar')">‚úì Check grammar</button>
                            <button class="ai-quick-action-btn" onclick="aiQuickAction('examples')">üí° Add examples</button>
                        </div>
                        
                        <!-- Chat History Panel (toggleable) -->
                        <div id="chat-history-panel" class="hidden" style="border-bottom: 1px solid var(--border-color); background: var(--bg-tertiary);">
                            <div style="padding: 12px 16px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center;">
                                <span style="font-size: 11px; font-weight: 600; color: var(--text-secondary);">CHAT HISTORY</span>
                                <button onclick="chatHistory.clearDirectory()" style="background: none; border: none; color: var(--error-color); cursor: pointer; font-size: 11px;" title="Clear all history for this folder">
                                    Clear All
                                </button>
                            </div>
                            <div id="chat-history-list" style="max-height: 200px; overflow-y: auto; padding: 8px;">
                                <!-- Populated dynamically -->
                            </div>
                        </div>
                        
                        <div class="ai-chat-messages" id="ai-chat-messages">
                            <div style="padding: 20px; text-align: center; color: var(--text-secondary); font-size: 12px;">
                                üëã Hi! I'm your AI assistant.<br>
                                Ask me to help with your documentation!
                            </div>
                        </div>
                        
                        <div class="ai-input-container">
                            <textarea 
                                id="ai-input" 
                                class="ai-input" 
                                placeholder="Ask AI to help with your document..."
                                onkeydown="if(event.key==='Enter' && (event.metaKey||event.ctrlKey)) sendAIMessage()"
                            ></textarea>
                            <button id="ai-send-btn" class="ai-send-btn" onclick="sendAIMessage()">
                                Send (Cmd+Enter)
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-left">
                <span id="status-file">No file open</span>
                <span id="status-line">Ln 1, Col 1</span>
                <span id="status-selection"></span>
                <span id="status-dirty"></span>
            </div>
            <div class="status-right">
                <span id="status-edits" class="status-item" onclick="toggleEditQueue()" style="display:none; cursor:pointer; color: #3b82f6;" title="Click to open AI Edits panel"></span>
                <span id="status-size"></span>
                <span id="status-words"></span>
                <span id="status-lang">Plain Text</span>
                <span id="status-encoding">UTF-8</span>
            </div>
        </div>
    </div>

    <!-- Command Palette -->
    <div class="command-palette hidden" id="command-palette">
        <input type="text" id="command-input" placeholder="Type a command or search files (Cmd+Shift+P)..." />
        <div class="command-results" id="command-results"></div>
    </div>

    <!-- Search Panel -->
    <div class="search-panel hidden" id="search-panel">
        <div class="search-input-group">
            <input type="text" class="search-input" id="search-input" placeholder="Find..." />
        </div>
        <div class="search-input-group">
            <input type="text" class="search-input" id="replace-input" placeholder="Replace..." />
        </div>
        <div class="search-options">
            <label class="search-option">
                <input type="checkbox" id="search-case" />
                <span>Match Case</span>
            </label>
            <label class="search-option">
                <input type="checkbox" id="search-whole" />
                <span>Whole Word</span>
            </label>
            <label class="search-option">
                <input type="checkbox" id="search-regex" />
                <span>Regex</span>
            </label>
        </div>
        <div style="margin-top: 12px; display: flex; gap: 8px;">
            <button class="btn" onclick="findNext()" style="flex: 1;">Find Next</button>
            <button class="btn btn-secondary" onclick="replaceOne()" style="flex: 1;">Replace</button>
        </div>
        <div style="margin-top: 8px;">
            <button class="btn btn-secondary" onclick="replaceAll()" style="width: 100%;">Replace All</button>
        </div>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settings-panel">
        <div class="settings-header">
            <span>‚öôÔ∏è Settings</span>
            <button onclick="toggleSettings()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">√ó</button>
        </div>
        <div class="settings-content">
            <div class="setting-group">
                <div class="setting-group-title">Editor</div>
                <div class="setting-item">
                    <label class="setting-label">Theme</label>
                    <select class="setting-input" id="setting-theme" onchange="applyTheme()">
                        <option value="vs-dark">Dark (default)</option>
                        <option value="vs">Light</option>
                        <option value="hc-black">High Contrast Dark</option>
                        <option value="hc-light">High Contrast Light</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label class="setting-label">Font Size</label>
                    <input type="number" class="setting-input" id="setting-font-size" value="14" min="10" max="24" onchange="applyFontSize()" />
                </div>
                <div class="setting-item">
                    <label class="setting-label">Tab Size</label>
                    <input type="number" class="setting-input" id="setting-tab-size" value="2" min="2" max="8" onchange="applyTabSize()" />
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-group-title">View</div>
                <div class="setting-item">
                    <label class="setting-checkbox">
                        <input type="checkbox" id="setting-minimap" checked onchange="applyMinimap()" />
                        <span>Show Minimap</span>
                    </label>
                </div>
                <div class="setting-item">
                    <label class="setting-checkbox">
                        <input type="checkbox" id="setting-line-numbers" checked onchange="applyLineNumbers()" />
                        <span>Show Line Numbers</span>
                    </label>
                </div>
                <div class="setting-item">
                    <label class="setting-checkbox">
                        <input type="checkbox" id="setting-word-wrap" checked onchange="applyWordWrap()" />
                        <span>Word Wrap</span>
                    </label>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-group-title">Auto-Save</div>
                <div class="setting-item">
                    <label class="setting-label">Auto-Save Mode</label>
                    <select class="setting-input" id="setting-auto-save" onchange="applyAutoSave()">
                        <option value="off">Off</option>
                        <option value="afterDelay">After Delay</option>
                        <option value="onFocusChange">On Focus Change</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label class="setting-label">Auto-Save Delay (ms)</label>
                    <input type="number" class="setting-input" id="setting-auto-save-delay" value="1000" min="500" max="5000" step="500" />
                </div>
            </div>
            <div style="margin-top: 24px;">
                <button class="btn" onclick="resetSettings()" style="width: 100%;">Reset to Defaults</button>
            </div>
        </div>
    </div>

    <!-- Keyboard Help -->
    <div class="keyboard-help hidden" id="keyboard-help">
        <div class="keyboard-help-header">
            <span>‚å®Ô∏è Keyboard Shortcuts</span>
            <button onclick="toggleKeyboardHelp()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">√ó</button>
        </div>
        <div class="keyboard-help-content">
            <div class="shortcut-section">
                <div class="shortcut-section-title">File Operations</div>
                <div class="shortcut-item"><span>Save File</span><span class="shortcut-keys">Cmd+S / Ctrl+S</span></div>
                <div class="shortcut-item"><span>Save All Files</span><span class="shortcut-keys">Cmd+Shift+S</span></div>
                <div class="shortcut-item"><span>Close File</span><span class="shortcut-keys">Cmd+W / Ctrl+W</span></div>
            </div>
            <div class="shortcut-section">
                <div class="shortcut-section-title">Navigation</div>
                <div class="shortcut-item"><span>Command Palette</span><span class="shortcut-keys">Cmd+Shift+P</span></div>
                <div class="shortcut-item"><span>Quick Open File</span><span class="shortcut-keys">Cmd+P</span></div>
                <div class="shortcut-item"><span>Go to Line</span><span class="shortcut-keys">Cmd+G / Ctrl+G</span></div>
            </div>
            <div class="shortcut-section">
                <div class="shortcut-section-title">Editing</div>
                <div class="shortcut-item"><span>Find</span><span class="shortcut-keys">Cmd+F / Ctrl+F</span></div>
                <div class="shortcut-item"><span>Replace</span><span class="shortcut-keys">Cmd+H / Ctrl+H</span></div>
                <div class="shortcut-item"><span>Format Document</span><span class="shortcut-keys">Shift+Alt+F</span></div>
                <div class="shortcut-item"><span>Toggle Comment</span><span class="shortcut-keys">Cmd+/ / Ctrl+/</span></div>
            </div>
            <div class="shortcut-section">
                <div class="shortcut-section-title">View</div>
                <div class="shortcut-item"><span>Toggle Sidebar</span><span class="shortcut-keys">Cmd+B / Ctrl+B</span></div>
                <div class="shortcut-item"><span>Toggle Preview</span><span class="shortcut-keys">Cmd+K V</span></div>
                <div class="shortcut-item"><span>Toggle AI Assistant</span><span class="shortcut-keys">Cmd+K A</span></div>
                <div class="shortcut-item"><span>Settings</span><span class="shortcut-keys">Cmd+,</span></div>
            </div>
            <div class="shortcut-section">
                <div class="shortcut-section-title">AI Assistant</div>
                <div class="shortcut-item"><span>Send Message</span><span class="shortcut-keys">Cmd+Enter</span></div>
                <div class="shortcut-item"><span>Improve Selection</span><span class="shortcut-keys">Right-click ‚Üí AI menu</span></div>
            </div>
            <div class="shortcut-section">
                <div class="shortcut-section-title">Help</div>
                <div class="shortcut-item"><span>Keyboard Shortcuts</span><span class="shortcut-keys">? / Cmd+K Cmd+S</span></div>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu hidden" id="context-menu">
        <!-- Populated dynamically -->
    </div>

    <!-- Overlay -->
    <div class="overlay hidden" id="overlay" onclick="closeAllModals()"></div>

    <!-- Folder Browser Modal -->
    <div class="keyboard-help hidden" id="folder-browser" style="width: 900px; max-width: 90vw;">
        <div class="keyboard-help-header">
            <span>üìÇ Browse for Folder</span>
            <button onclick="closeFolderBrowser()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">√ó</button>
        </div>
        <div class="keyboard-help-content" style="padding: 0; max-height: 70vh;">
            <div style="padding: 12px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color);">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                    <button onclick="navigateUp()" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;">‚¨ÜÔ∏è Up</button>
                    <button onclick="navigateToHome()" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;">üè† Home</button>
                    <div style="flex: 1; padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 12px; font-family: monospace; overflow-x: auto; white-space: nowrap;" id="current-path-display">
                        /Users
                    </div>
                </div>
                <div style="display: flex; gap: 8px;">
                    <input type="text" id="manual-path-input" placeholder="Or type path directly... (e.g., /path/to/folder)" 
                           style="flex: 1; padding: 8px 12px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 12px; font-family: monospace;"
                           onkeypress="if(event.key==='Enter') goToManualPath()">
                    <button onclick="goToManualPath()" class="btn" style="padding: 8px 16px; font-size: 12px;">Go</button>
                </div>
            </div>
            <div id="folder-list" style="padding: 12px; overflow-y: auto; max-height: calc(70vh - 120px);">
                <div style="text-align: center; color: var(--text-secondary); padding: 40px;">Loading...</div>
            </div>
            <div style="padding: 12px; background: var(--bg-secondary); border-top: 1px solid var(--border-color); display: flex; gap: 8px;">
                <button onclick="closeFolderBrowser()" class="btn btn-secondary" style="flex: 1;">Cancel</button>
                <button onclick="selectCurrentFolder()" class="btn" style="flex: 2;">‚úì Open This Folder</button>
            </div>
        </div>
    </div>

    <!-- Edit Queue Panel (Cursor-style edit review) -->
    <div id="edit-queue-panel" class="edit-queue-panel hidden">
        <div class="edit-queue-header">
            <h3>üìù AI Edits (<span id="edit-count">0</span>)</h3>
            <button onclick="toggleEditQueue()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">√ó</button>
        </div>
        
        <div class="edit-queue-actions">
            <button class="btn btn-primary" onclick="editQueue.acceptAll()" title="Accept all pending edits">
                ‚úì Accept All
            </button>
            <button class="btn btn-secondary" onclick="editQueue.rejectAll()" title="Reject all pending edits">
                ‚úó Reject All
            </button>
            <button class="btn btn-secondary" onclick="editQueue.clearProcessed()" title="Clear accepted/rejected edits">
                Clear
            </button>
        </div>
        
        <div id="edit-queue-list" class="edit-queue-list">
            <div style="text-align: center; color: var(--text-secondary); padding: 40px; font-size: 13px;">
                No pending edits
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu hidden" id="context-menu">
        <!-- Populated dynamically -->
    </div>

    <!-- CSV Table Builder Modal -->
    <div class="keyboard-help hidden" id="csv-builder" style="width: 800px; max-width: 90vw;">
        <div class="keyboard-help-header">
            <span>üìä Create CSV Table</span>
            <button onclick="closeCSVBuilder()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">√ó</button>
        </div>
        <div class="keyboard-help-content" style="padding: 20px;">
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600;">File Name:</label>
                <input type="text" id="csv-filename" value="data.csv" 
                       style="width: 100%; padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-family: monospace;">
            </div>
            
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600;">Table Size:</label>
                <div style="display: flex; gap: 12px;">
                    <div>
                        <label style="font-size: 12px; color: var(--text-secondary);">Rows:</label>
                        <input type="number" id="csv-rows" value="5" min="1" max="100" 
                               style="width: 80px; padding: 6px; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px;">
                    </div>
                    <div>
                        <label style="font-size: 12px; color: var(--text-secondary);">Columns:</label>
                        <input type="number" id="csv-cols" value="4" min="1" max="50" 
                               style="width: 80px; padding: 6px; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px;">
                    </div>
                    <button class="btn btn-secondary" onclick="generateCSVGrid()" style="margin-left: auto;">
                        Generate Grid
                    </button>
                </div>
            </div>
            
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600;">Edit Table:</label>
                <div id="csv-grid" style="overflow: auto; max-height: 400px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-tertiary);">
                    <p style="text-align: center; padding: 40px; color: var(--text-secondary);">Click "Generate Grid" to start</p>
                </div>
            </div>
            
            <div style="display: flex; gap: 8px; justify-content: flex-end;">
                <button onclick="closeCSVBuilder()" class="btn btn-secondary">
                    Cancel
                </button>
                <button onclick="createCSVFile()" class="btn btn-primary">
                    üìä Create CSV File
                </button>
            </div>
        </div>
    </div>

    <!-- Monaco Loader -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>

    <script>
        // ============================================================================
        // STATE MANAGEMENT
        // ============================================================================
        
        // Parse URL parameters
        const params = new URLSearchParams(window.location.search);
        let folderPath = params.get('path');
        let initialFileName = params.get('file');
        
        // Standalone mode - filesystem only
        const IDE_MODE = 'filesystem';
        const runName = null;
        const systemId = null;
        
        // Show folder picker on startup if no path
        if (!folderPath) {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(() => {
                    const folderBrowser = document.getElementById('folder-browser');
                    const overlay = document.getElementById('overlay');
                    if (folderBrowser && overlay) {
                        folderBrowser.classList.remove('hidden');
                        overlay.classList.remove('hidden');
                        browseFolders('/Users');
                    }
                }, 150);
            });
        }
        
        // FileAPI - filesystem only
        const FileAPI = {
            async listFiles() {
                const res = await fetch(`/api/folder/browse?path=${encodeURIComponent(folderPath)}&recursive=true`);
                return await res.json();
            },
            async readFile(filePath) {
                const res = await fetch(`/api/folder/read?path=${encodeURIComponent(filePath)}`);
                return await res.json();
            },
            async writeFile(filePath, content) {
                const res = await fetch('/api/folder/write', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: filePath, content })
                });
                return await res.json();
            },
            getDisplayName() {
                return folderPath ? folderPath.split('/').pop() || folderPath : 'Filesystem';
            }
        };
        
        /**
         * Resolve a path relative to the current working folder
         * Handles: relative paths (README.md), dot-relative (./src), and absolute paths
         * @param {string} inputPath - The path from AI tool commands
         * @returns {string} Absolute path ready for API calls
         */
        function resolvePathForAPI(inputPath) {
            if (!inputPath) return inputPath;
            
            // Get the current working folder based on IDE mode
            const currentFolder = IDE_MODE === 'filesystem' 
                ? folderPath 
                : (currentBrowsePath || '.');
            
            // Already absolute? Return as-is
            if (inputPath.startsWith('/')) {
                return inputPath;
            }
            
            // Handle . and ./ (current directory)
            if (inputPath === '.' || inputPath === './') {
                return currentFolder;
            }
            
            // Handle ./ prefix
            if (inputPath.startsWith('./')) {
                inputPath = inputPath.slice(2);
            }
            
            // Join with current folder
            // Simple join - avoid double slashes
            const base = currentFolder.endsWith('/') ? currentFolder.slice(0, -1) : currentFolder;
            return `${base}/${inputPath}`;
        }

        // Core state
        let editor = null;
        let openFiles = new Map();
        let activeFile = null;
        let allFiles = [];
        let availableSystems = [];
        let autoSaveTimer = null;
        let previewUpdateTimer = null;
        let selectedCommandIndex = 0;
        let pinnedTabs = new Set(); // Track pinned file paths
        let recentFiles = []; // Track recently opened files
        const MAX_RECENT_FILES = 20;
        
        // Settings
        const defaultSettings = {
            theme: 'vs-dark',
            fontSize: 14,
            tabSize: 2,
            minimap: true,
            lineNumbers: true,
            wordWrap: true,
            autoSave: 'off',
            autoSaveDelay: 1000,
        };
        
        let settings = loadSettings();

        // ============================================================================
        // EDIT QUEUE MANAGER - Cursor-style edit review system
        // ============================================================================
        
        class EditQueueManager {
            constructor() {
                this.queue = [];
                this.onUpdate = null;
            }
            
            addEdit(filePath, original, modified) {
                const edit = {
                    id: `edit-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    filePath,
                    fileName: filePath.split('/').pop(),
                    originalContent: original,
                    modifiedContent: modified,
                    summary: this.generateSummary(original, modified),
                    status: 'pending',
                    timestamp: Date.now()
                };
                
                this.queue.push(edit);
                
                // Auto-open panel on first pending edit in this session
                if (this.getPending().length === 1) {
                    showEditQueue();
                    showToast('AI proposed edits ‚Äì review in the AI Edits panel', 'success');
                }
                
                this.notify();
                return edit.id;
            }
            
            acceptEdit(id) {
                const edit = this.queue.find(e => e.id === id);
                if (edit && edit.status === 'pending') {
                    edit.status = 'accepted';
                    this.applyEdit(edit);
                    this.notify();
                }
            }
            
            rejectEdit(id) {
                const edit = this.queue.find(e => e.id === id);
                if (edit && edit.status === 'pending') {
                    edit.status = 'rejected';
                    this.notify();
                }
            }
            
            acceptAll() {
                const pending = this.queue.filter(e => e.status === 'pending');
                pending.forEach(e => this.acceptEdit(e.id));
            }
            
            rejectAll() {
                const pending = this.queue.filter(e => e.status === 'pending');
                pending.forEach(e => this.rejectEdit(e.id));
            }
            
            clearProcessed() {
                this.queue = this.queue.filter(e => e.status === 'pending');
                this.notify();
            }
            
            getPending() {
                return this.queue.filter(e => e.status === 'pending');
            }
            
            getAll() {
                return this.queue;
            }
            
            generateSummary(original, modified) {
                const origLines = original.split('\n').length;
                const modLines = modified.split('\n').length;
                const diff = modLines - origLines;
                if (diff > 0) return `+${diff} lines added`;
                if (diff < 0) return `${Math.abs(diff)} lines removed`;
                return 'Modified';
            }
            
            applyEdit(edit) {
                const fileData = openFiles.get(edit.filePath);
                if (fileData) {
                    fileData.model.setValue(edit.modifiedContent);
                    fileData.dirty = true;
                    updateTabDirtyState(edit.filePath, true);
                    updateSaveButtons();
                    showToast(`Applied edit to ${edit.fileName}`, 'success');
                }
            }
            
            notify() {
                if (this.onUpdate) {
                    this.onUpdate(this.queue);
                }
                updateEditQueueUI();
            }
        }
        
        // Global edit queue instance
        const editQueue = new EditQueueManager();
        
        /**
         * Add surgical edit to queue (from function calling)
         * Applies surgical edit markers to get full content, then queues for review
         */
        async function addToEditQueue(filePath, instructions, surgicalEditContent) {
            try {
                // Read current file content
                const result = await FileAPI.readFile(filePath);
                if (!result.success) {
                    console.error(`Cannot queue edit for ${filePath}: file not found`);
                    showToast(`Cannot edit ${filePath}: file not found`, 'error');
                    return;
                }
                
                const originalContent = result.content;
                
                // Apply surgical edit to get full modified content
                const modifiedContent = applySurgicalEdit(originalContent, surgicalEditContent);
                
                // Add to queue
                const editId = editQueue.addEdit(filePath, originalContent, modifiedContent);
                
                console.log(`[EDIT QUEUE] Added edit for ${filePath}: ${instructions}`);
                
            } catch (error) {
                console.error(`Error adding edit to queue:`, error);
                showToast(`Error queuing edit: ${error.message}`, 'error');
            }
        }
        
        // ============================================================================
        // CHAT HISTORY MANAGER - Directory-specific conversation persistence
        // ============================================================================
        
        class ChatHistoryManager {
            constructor() {
                this.currentConversationId = null;
                this.maxConversationsPerDir = 20; // Keep last 20 conversations per directory
            }
            
            getStorageKey(directory) {
                return `cosmo-chat:${directory}`;
            }
            
            getCurrentDirectory() {
                return IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
            }
            
            loadConversations(directory) {
                const key = this.getStorageKey(directory);
                const stored = localStorage.getItem(key);
                if (!stored) return [];
                
                try {
                    return JSON.parse(stored);
                } catch (e) {
                    console.error('Failed to parse chat history:', e);
                    return [];
                }
            }
            
            saveConversations(directory, conversations) {
                const key = this.getStorageKey(directory);
                try {
                    // Keep only last N conversations
                    const limited = conversations.slice(-this.maxConversationsPerDir);
                    localStorage.setItem(key, JSON.stringify(limited));
                } catch (e) {
                    console.error('Failed to save chat history:', e);
                }
            }
            
            startNewConversation() {
                this.currentConversationId = `conv-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                return this.currentConversationId;
            }
            
            saveMessage(role, content, fileContext = null) {
                const directory = this.getCurrentDirectory();
                const conversations = this.loadConversations(directory);
                
                // Find or create current conversation
                let conversation = conversations.find(c => c.id === this.currentConversationId);
                if (!conversation) {
                    conversation = {
                        id: this.currentConversationId || this.startNewConversation(),
                        timestamp: Date.now(),
                        directory: directory,
                        messages: [],
                        fileContext: fileContext
                    };
                    conversations.push(conversation);
                    this.currentConversationId = conversation.id;
                }
                
                // Add message
                conversation.messages.push({ role, content, timestamp: Date.now() });
                conversation.lastUpdated = Date.now();
                
                // Save back
                this.saveConversations(directory, conversations);
            }
            
            loadConversation(conversationId) {
                const directory = this.getCurrentDirectory();
                const conversations = this.loadConversations(directory);
                return conversations.find(c => c.id === conversationId);
            }
            
            getRecentConversations(directory = null) {
                const dir = directory || this.getCurrentDirectory();
                const conversations = this.loadConversations(dir);
                return conversations.sort((a, b) => b.lastUpdated - a.lastUpdated);
            }
            
            clearDirectory(directory = null) {
                const dir = directory || this.getCurrentDirectory();
                const key = this.getStorageKey(dir);
                localStorage.removeItem(key);
            }
        }
        
        // Global chat history manager
        const chatHistory = new ChatHistoryManager();
        
        // ============================================================================
        // DIFF AND PATH UTILITIES
        // ============================================================================
        
        /**
         * Simple line-based diff (no external dependencies)
         * Returns array of {type: 'add'|'remove'|'same', line: string, oldIndex, newIndex}
         */
        function computeLineDiff(oldText, newText) {
            const oldLines = oldText.split('\n');
            const newLines = newText.split('\n');
            const diffs = [];
            let i = 0, j = 0;

            while (i < oldLines.length || j < newLines.length) {
                const oldLine = oldLines[i];
                const newLine = newLines[j];

                if (oldLine === undefined) {
                    diffs.push({ type: 'add', line: newLine, oldIndex: null, newIndex: j });
                    j++;
                } else if (newLine === undefined) {
                    diffs.push({ type: 'remove', line: oldLine, oldIndex: i, newIndex: null });
                    i++;
                } else if (oldLine === newLine) {
                    diffs.push({ type: 'same', line: oldLine, oldIndex: i, newIndex: j });
                    i++; j++;
                } else {
                    // Treat as remove + add (simple approach)
                    diffs.push({ type: 'remove', line: oldLine, oldIndex: i, newIndex: null });
                    diffs.push({ type: 'add', line: newLine, oldIndex: null, newIndex: j });
                    i++; j++;
                }
            }

            return diffs;
        }
        
        /**
         * Normalize relative paths like ./ and ../ against a base path
         * Handles both absolute and relative paths safely
         */
        function normalizePath(base, relative) {
            if (relative.startsWith('/')) return relative;

            const stack = base.split('/').filter(Boolean);
            const parts = relative.split('/');

            // If base ends with a file (has a dot), drop it
            if (stack.length && stack[stack.length - 1].includes('.')) {
                stack.pop();
            }

            for (const part of parts) {
                if (!part || part === '.') continue;
                if (part === '..') {
                    stack.pop();
                } else {
                    stack.push(part);
                }
            }

            return '/' + stack.join('/');
        }
        

        /**
         * Apply surgical edit (Cursor-style) - FAST edits with only changed sections
         * Parses // ... existing code ... markers and applies only the changes
         */


/**
 * Cursor-Style Surgical Edit Parser (Enterprise-Grade)
 * 
 * Based on Cursor's edit_file tool specification:
 * - Parses // ... existing code ... markers
 * - Uses context lines to find exact positions
 * - Handles multiple edits in sequence
 * - Robust matching with context validation
 */
        function applySurgicalEdit(originalContent, editContent) {
            // Check for surgical edit markers
            const markerPattern = /(?:\/\/|#|<!--|--)\s*\.\.\.\s*existing code\s*\.\.\.(?:\s*-->)?/i;
            if (!markerPattern.test(editContent)) {
                // No markers - treat as full file replacement
                return editContent;
            }
    
            console.log('[SURGICAL EDIT] Parsing Cursor-style surgical edit...');
    
            // Extract INSTRUCTIONS if present (first line starting with INSTRUCTIONS:)
            let instructions = '';
            let codeContent = editContent;
            const instructionsMatch = editContent.match(/^INSTRUCTIONS:\s*(.+?)$/m);
            if (instructionsMatch) {
                instructions = instructionsMatch[1];
                codeContent = editContent.replace(/^INSTRUCTIONS:.*?$\n*/m, '');
                console.log(`[SURGICAL EDIT] Instructions: ${instructions}`);
            }
    
            // Split into sections by the markers
            // Use a more flexible regex that captures different comment styles
            const markerRegex = /(?:\/\/|#|<!--|\/\*)\s*\.\.\.\s*existing code\s*\.\.\.\s*(?:-->|\*\/)?/gi;
            const parts = codeContent.split(markerRegex);
    
            // parts[0] might be empty or have leading content
            // parts[1], parts[3], parts[5]... are the changed sections (between markers)
            // The pattern is: [optional prefix] MARKER [change1] MARKER [change2] MARKER [optional suffix]
    
            const changedBlocks = [];
            for (let i = 0; i < parts.length; i++) {
                const part = parts[i].trim();
                if (part) {
                    changedBlocks.push({
                        content: part,
                        index: i
                    });
                }
            }
    
            if (changedBlocks.length === 0) {
                console.warn('[SURGICAL EDIT] No content blocks found');
                return editContent;
            }
    
            console.log(`[SURGICAL EDIT] Processing ${changedBlocks.length} change blocks`);
    
            // Build the result by applying each change in order
            const originalLines = originalContent.split('\n');
            let result = [...originalLines];
            let offsetAdjustment = 0; // Track line number shifts from previous edits
    
            for (const block of changedBlocks) {
                const blockLines = block.content.split('\n');
        
                // Find context lines (lines that should exist in original to anchor this change)
                // Look for lines with actual code (not just comments or whitespace)
                const contextLines = blockLines.filter(line => {
                    const trimmed = line.trim();
                    return trimmed && 
                           !trimmed.startsWith('//') && 
                           !trimmed.startsWith('#') && 
                           !trimmed.startsWith('*') &&
                           !trimmed.startsWith('/*');
                });
        
                if (contextLines.length === 0) {
                    console.warn('[SURGICAL EDIT] Block has no significant lines - skipping');
                    continue;
                }
        
                // Use first significant line as anchor to find position
                const anchorLine = contextLines[0].trim();
                const searchLength = Math.min(anchorLine.length, 50);
                const searchStr = anchorLine.substring(0, searchLength);
        
                // Find this line in the original (accounting for offset from previous edits)
                let foundAt = -1;
                for (let i = offsetAdjustment; i < result.length; i++) {
                    if (result[i].trim().includes(searchStr)) {
                        foundAt = i;
                        console.log(`[SURGICAL EDIT] Found anchor at line ${foundAt + 1}: "${searchStr.substring(0, 30)}..."`);
                        break;
                    }
                }
        
                if (foundAt === -1) {
                    console.warn(`[SURGICAL EDIT] Could not find anchor: "${searchStr.substring(0, 30)}..."`);
                    // Fallback: append at end
                    result.push('', ...blockLines);
                    continue;
                }
        
                // Determine how many lines this edit replaces
                // This is tricky - we need to figure out the span of the original code this edit covers
                // For now, use a heuristic: same number of lines as the block
                const linesToReplace = blockLines.length;
        
                // Apply the edit
                result.splice(foundAt, linesToReplace, ...blockLines);
        
                // Adjust offset for next iteration
                offsetAdjustment = foundAt + blockLines.length;
        
                console.log(`[SURGICAL EDIT] Replaced ${linesToReplace} lines at position ${foundAt + 1}`);
            }
    
            const finalContent = result.join('\n');
            console.log(`[SURGICAL EDIT] Complete - ${originalLines.length} ‚Üí ${result.length} lines`);
    
            return finalContent;
        }

        // ============================================================================
        // EDIT QUEUE UI FUNCTIONS
        // ============================================================================
        
        function toggleEditQueue() {
            const panel = document.getElementById('edit-queue-panel');
            panel.classList.toggle('hidden');
        }
        
        function showEditQueue() {
            const panel = document.getElementById('edit-queue-panel');
            panel.classList.remove('hidden');
        }
        
        function hideEditQueue() {
            const panel = document.getElementById('edit-queue-panel');
            panel.classList.add('hidden');
        }
        
        function updateEditQueueUI() {
            const queue = editQueue.getAll();
            const pending = editQueue.getPending();
            const countEl = document.getElementById('edit-count');
            const listEl = document.getElementById('edit-queue-list');
            
            // Update count
            countEl.textContent = pending.length;
            
            // Update list
            if (queue.length === 0) {
                listEl.innerHTML = `
                    <div style="text-align: center; color: var(--text-secondary); padding: 40px; font-size: 13px;">
                        No pending edits
                    </div>
                `;
                return;
            }
            
            listEl.innerHTML = queue.map(edit => `
                <div class="edit-item ${edit.status}" data-edit-id="${edit.id}">
                    <div class="edit-item-header">
                        <div class="edit-item-file" title="${edit.filePath}">${edit.fileName}</div>
                        <span class="edit-item-status ${edit.status}">${edit.status}</span>
                    </div>
                    <div class="edit-item-summary">${edit.summary}</div>
                    <div class="edit-item-actions">
                        <button class="btn btn-secondary" onclick="viewEditDiff('${edit.id}')" title="View changes">
                            üëÅÔ∏è View
                        </button>
                        <button class="btn btn-primary" onclick="editQueue.acceptEdit('${edit.id}')" title="Accept this edit">
                            ‚úì
                        </button>
                        <button class="btn btn-secondary" onclick="editQueue.rejectEdit('${edit.id}')" title="Reject this edit">
                            ‚úó
                        </button>
                    </div>
                </div>
            `).join('');
            
            // Update status bar indicator
            const statusEdits = document.getElementById('status-edits');
            if (statusEdits) {
                if (pending.length > 0) {
                    statusEdits.style.display = 'inline';
                    statusEdits.textContent = `üìù AI Edits: ${pending.length}`;
                } else {
                    statusEdits.style.display = 'none';
                    statusEdits.textContent = '';
                }
            }
        }
        
        async function viewEditDiff(editId) {
            const edit = editQueue.getAll().find(e => e.id === editId);
            if (!edit) return;
            
            // Open file if not already open
            if (!openFiles.has(edit.filePath)) {
                const fileName = edit.fileName;
                try {
                    // Wait for file to open before showing diff
                    await openFile(edit.filePath, fileName);
                } catch (err) {
                    console.error('Could not open file:', err);
                    showToast('Could not open file for diff view', 'error');
                    return; // Don't show diff if file couldn't be opened
                }
            }
            
            // Show diff using existing modal (now that file is loaded)
            showDiffPreview(edit.originalContent, edit.modifiedContent, () => {
                editQueue.acceptEdit(editId);
            });
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        // Start a new conversation on load
        chatHistory.startNewConversation();
        
        if (IDE_MODE === 'picker') {
            showSystemPickerModal();
        } else {
            initializeMonaco();
        }

        // ============================================================================
        // SYSTEM PICKER
        // ============================================================================
        
        async function showSystemPickerModal() {
            try {
                const response = await fetch('/api/compiled-docs/all');
                const data = await response.json();
                
                if (!data.success || data.systems.length === 0) {
                    document.getElementById('loading-overlay').innerHTML = `
                        <div style="text-align: center;">
                            <div style="font-size: 18px; margin-bottom: 12px;">üì¶ No Compiled Systems Yet</div>
                            <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 20px;">
                                Compile your first system from the Query tab in Intelligence.
                            </div>
                            <a href="/intelligence" 
                               style="background: #0e639c; color: white; padding: 10px 20px; border-radius: 6px; text-decoration: none; font-size: 13px;">
                                Go to Intelligence Dashboard
                            </a>
                        </div>
                    `;
                    return;
                }
                
                let html = `
                    <div style="text-align: center; max-width: 500px;">
                        <div style="font-size: 18px; margin-bottom: 8px; color: var(--text-primary);">Select Documentation System</div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 20px;">
                            ${data.systems.length} compiled ${data.systems.length === 1 ? 'system' : 'systems'} available
                        </div>
                        <select id="initial-system-picker" 
                                style="width: 100%; padding: 10px; background: var(--border-color); border: 1px solid #5a5a5a; color: var(--text-primary); border-radius: 4px; font-size: 13px; margin-bottom: 16px;">
                `;
                
                const byRun = {};
                data.systems.forEach(sys => {
                    if (!byRun[sys.runName]) byRun[sys.runName] = [];
                    byRun[sys.runName].push(sys);
                });
                
                for (const [run, systems] of Object.entries(byRun)) {
                    html += `<optgroup label="${run}">`;
                    systems.forEach(sys => {
                        const label = `${sys.systemId} (${sys.mdFiles} docs, ${sys.queryCount || 0} queries)`;
                        html += `<option value="${sys.runName}:${sys.systemId}">${label}</option>`;
                    });
                    html += `</optgroup>`;
                }
                
                html += `
                        </select>
                        <button onclick="loadSelectedSystem()" 
                                style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 10px 24px; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
                            üìù Open Compiled Docs
                        </button>
                        <div style="margin: 20px 0; text-align: center; color: var(--text-secondary); font-size: 12px;">
                            ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ OR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                        </div>
                        <button onclick="showFolderBrowser()" 
                                style="width: 100%; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 12px 24px; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
                            üìÇ Browse for Folder...
                        </button>
                    </div>
                `;
                
                document.getElementById('loading-overlay').innerHTML = html;
                
            } catch (error) {
                document.getElementById('loading-overlay').innerHTML = `
                    <div style="color: var(--error-color);">Failed to load systems: ${error.message}</div>
                `;
            }
        }
        
        function loadSelectedSystem() {
            const picker = document.getElementById('initial-system-picker');
            const value = picker.value;
            if (!value) return;
            const [run, system] = value.split(':');
            window.location.href = `/docs-ide?run=${run}&system=${system}`;
        }

        function goBackToPicker() {
            // Go back to picker screen
            window.location.href = '/docs-ide';
        }

        // ============================================================================
        // MONACO EDITOR INITIALIZATION
        // ============================================================================
        
        function initializeMonaco() {
            loadAvailableSystems();
            
            require.config({ 
                paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' } 
            });

            require(['vs/editor/editor.main'], async function() {
                console.log('Monaco Editor loaded');

                // Create editor instance
                editor = monaco.editor.create(document.getElementById('monaco-editor'), {
                    theme: settings.theme,
                    fontSize: settings.fontSize,
                    lineNumbers: settings.lineNumbers ? 'on' : 'off',
                    minimap: { enabled: settings.minimap },
                    scrollBeyondLastLine: false,
                    wordWrap: settings.wordWrap ? 'on' : 'off',
                    automaticLayout: true,
                    renderWhitespace: 'selection',
                    tabSize: settings.tabSize,
                    insertSpaces: true,
                    folding: true,
                    lineDecorationsWidth: 10,
                    lineNumbersMinChars: 4,
                    glyphMargin: false,
                    overviewRulerBorder: false,
                    hideCursorInOverviewRuler: true,
                    find: {
                        seedSearchStringFromSelection: 'always',
                        autoFindInSelection: 'never'
                    }
                });

                // Event handlers
                editor.onDidChangeCursorPosition((e) => {
                    document.getElementById('status-line').textContent = 
                        `Ln ${e.position.lineNumber}, Col ${e.position.column}`;
                    updateSelectionInfo();
                });

                editor.onDidChangeCursorSelection(() => {
                    updateSelectionInfo();
                });

                editor.onDidChangeModelContent(() => {
                    if (activeFile) {
                        const fileData = openFiles.get(activeFile);
                        if (fileData && !fileData.dirty) {
                            fileData.dirty = true;
                            updateTabDirtyState(activeFile, true);
                            updateSaveButtons();
                        }
                        updateFileStats();
                        schedulePreviewUpdate();
                    }
                });

                // Add context menu actions for AI
                editor.addAction({
                    id: 'ai-improve-selection',
                    label: 'ü§ñ AI: Improve Selection',
                    contextMenuGroupId: 'ai',
                    contextMenuOrder: 1,
                    run: async function(ed) {
                        const selection = ed.getSelection();
                        if (selection && !selection.isEmpty()) {
                            // Open AI panel if closed
                            const aiPanel = document.getElementById('ai-panel');
                            if (aiPanel.classList.contains('hidden')) {
                                toggleAI();
                            }
                            // Set quick action
                            await aiQuickAction('improve');
                        }
                    }
                });

                editor.addAction({
                    id: 'ai-fix-grammar',
                    label: '‚úì AI: Check Grammar',
                    contextMenuGroupId: 'ai',
                    contextMenuOrder: 2,
                    run: async function(ed) {
                        const aiPanel = document.getElementById('ai-panel');
                        if (aiPanel.classList.contains('hidden')) {
                            toggleAI();
                        }
                        await aiQuickAction('grammar');
                    }
                });

                editor.addAction({
                    id: 'ai-custom',
                    label: 'üí¨ Ask AI About This...',
                    contextMenuGroupId: 'ai',
                    contextMenuOrder: 3,
                    run: function(ed) {
                        const aiPanel = document.getElementById('ai-panel');
                        if (aiPanel.classList.contains('hidden')) {
                            toggleAI();
                        }
                        document.getElementById('ai-input').focus();
                    }
                });

                // Keyboard shortcuts
                setupKeyboardShortcuts();

                // Hide loading overlay
                document.getElementById('loading-overlay').classList.add('hidden');

                // Load file tree (skip in picker mode)
                if (IDE_MODE !== 'picker') {
                await loadFileTree();
                }
                
                // Restore workspace state
                restoreWorkspaceState();
            });
        }

        // ============================================================================
        // KEYBOARD SHORTCUTS
        // ============================================================================
        
        function setupKeyboardShortcuts() {
            // Save
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_S,
                () => saveCurrentFile()
            );

            // Save All
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KEY_S,
                () => saveAllFiles()
            );

            // Close Tab
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_W,
                () => { if (activeFile) closeTab(activeFile); }
            );

            // Command Palette
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KEY_P,
                () => toggleCommandPalette()
            );

            // Quick Open
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_P,
                () => toggleCommandPalette('file')
            );

            // Find
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_F,
                () => toggleSearch()
            );

            // Toggle Sidebar
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_B,
                () => toggleSidebar()
            );

            // Settings
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyCode.US_COMMA,
                () => toggleSettings()
            );

            // Recent Files
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_E,
                () => showRecentFiles()
            );

            // Find in Files
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KEY_F,
                () => showFindInFiles()
            );

            // Toggle AI Panel
            editor.addCommand(
                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_K,
                () => {
                    // Wait for next key
                    const nextKeyHandler = (e) => {
                        if (e.key === 'a' || e.key === 'A') {
                            toggleAI();
                            document.removeEventListener('keydown', nextKeyHandler);
                        }
                    };
                    document.addEventListener('keydown', nextKeyHandler);
                    setTimeout(() => document.removeEventListener('keydown', nextKeyHandler), 2000);
                }
            );

            // Global keyboard listener for non-editor shortcuts
            document.addEventListener('keydown', (e) => {
                // Escape - close modals
                if (e.key === 'Escape') {
                    closeAllModals();
                }
                
                // Cmd/Ctrl+? - help (changed from plain ? to allow typing question marks)
                if (e.key === '?' && (e.metaKey || e.ctrlKey)) {
                    toggleKeyboardHelp();
                    e.preventDefault();
                }
                
                // Arrow navigation in command palette
                const palette = document.getElementById('command-palette');
                if (!palette.classList.contains('hidden')) {
                    if (e.key === 'ArrowDown') {
                        navigateCommands(1);
                        e.preventDefault();
                    } else if (e.key === 'ArrowUp') {
                        navigateCommands(-1);
                        e.preventDefault();
                    } else if (e.key === 'Enter') {
                        executeSelectedCommand();
                        e.preventDefault();
                    }
                }
            });
        }

        // ============================================================================
        // FILE TREE
        // ============================================================================
        
        async function loadFileTree() {
            try {
                if (!folderPath) return;  // No folder selected yet
                const data = await FileAPI.listFiles();

                if (!data.success) {
                    throw new Error(data.error || 'Failed to load files');
                }

                allFiles = data.files;

                const tree = document.getElementById('file-tree');
                tree.innerHTML = '';

                if (allFiles.length === 0) {
                    tree.innerHTML = '<div style="padding: 16px; color: var(--text-secondary); font-size: 12px;">No files found</div>';
                    return;
                }

                // Build hierarchical tree from flat list
                const treeStructure = buildTreeStructure(allFiles, folderPath);
                renderTree(treeStructure, tree);

                // Auto-open file
                let fileToOpen = null;
                
                if (initialFileName) {
                    fileToOpen = findFileInTree(allFiles, initialFileName);
                }
                
                if (!fileToOpen) {
                    fileToOpen = findFileInTree(allFiles, 'INDEX.md');
                }
                
                if (fileToOpen) {
                    setTimeout(() => openFile(fileToOpen.path, fileToOpen.name), 100);
                }

            } catch (error) {
                console.error('Failed to load file tree:', error);
                showToast('Failed to load files: ' + error.message, 'error');
            }
        }

        function buildTreeStructure(flatFiles, rootPath) {
            const tree = {};
            
            flatFiles.forEach(file => {
                // Get relative path from root
                const relativePath = file.path.startsWith(rootPath) 
                    ? file.path.substring(rootPath.length).replace(/^\//, '')
                    : file.path;
                
                if (!relativePath) return; // Skip root itself
                
                const parts = relativePath.split('/');
                let current = tree;
                
                // Build nested structure
                parts.forEach((part, index) => {
                    if (!current[part]) {
                        const isLastPart = index === parts.length - 1;
                        current[part] = {
                            name: part,
                            path: file.path,
                            isDirectory: isLastPart ? file.isDirectory : true,
                            children: {}
                        };
                    }
                    current = current[part].children;
                });
            });
            
            // Convert to array format
            const treeToArray = (obj) => {
                return Object.values(obj).map(item => ({
                    name: item.name,
                    path: item.path,
                    isDirectory: item.isDirectory,
                    children: item.isDirectory && Object.keys(item.children).length > 0 
                        ? treeToArray(item.children)
                        : []
                })).sort((a, b) => {
                    // Directories first, then alphabetical
                    if (a.isDirectory && !b.isDirectory) return -1;
                    if (!a.isDirectory && b.isDirectory) return 1;
                    return a.name.localeCompare(b.name);
                });
            };
            
            return treeToArray(tree);
        }
        
        function renderTree(items, container) {
            items.forEach(item => {
                const treeItem = document.createElement('div');
                treeItem.className = 'tree-item';
                
                if (item.isDirectory) {
                    const folderHeader = document.createElement('div');
                    folderHeader.className = 'folder-item';
                    folderHeader.innerHTML = `
                        <span class="folder-chevron">‚ñ∂</span>
                        <span class="folder-icon">üìÅ</span>
                        <span>${item.name}</span>
                    `;
                    
                    const folderContents = document.createElement('div');
                    folderContents.className = 'folder-contents collapsed';
                    
                    folderHeader.onclick = (e) => {
                        e.stopPropagation();
                        const chevron = folderHeader.querySelector('.folder-chevron');
                        chevron.classList.toggle('expanded');
                        folderContents.classList.toggle('collapsed');
                    };
                    
                    treeItem.appendChild(folderHeader);
                    treeItem.appendChild(folderContents);
                    
                    if (item.children && item.children.length > 0) {
                        renderTree(item.children, folderContents);
                    }
                } else {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.dataset.path = item.path;
                    
                    const icon = item.type === 'markdown' ? 'üìÑ' : 
                                item.type === 'json' ? 'üìä' : 'üìù';
                    
                    fileItem.innerHTML = `
                        <span class="file-icon">${icon}</span>
                        <span>${item.name}</span>
                    `;
                    
                    fileItem.onclick = () => openFile(item.path, item.name);
                    
                    // Context menu (Cursor-style)
                    fileItem.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showContextMenu(e.clientX, e.clientY, item.path);
                    });
                    
                    treeItem.appendChild(fileItem);
                }
                
                container.appendChild(treeItem);
            });
        }

        function findFileInTree(items, fileName) {
            for (const item of items) {
                if (item.type !== 'directory' && item.name === fileName) {
                    return item;
                }
                if (item.children) {
                    const found = findFileInTree(item.children, fileName);
                    if (found) return found;
                }
            }
            return null;
        }

        // ============================================================================
        // FILE OPERATIONS
        // ============================================================================
        
        async function openFile(filePath, fileName) {
            if (openFiles.has(filePath)) {
                setActiveFile(filePath);
                return;
            }

            try {
                const data = await FileAPI.readFile(filePath);

                if (!data.success) {
                    throw new Error(data.error || 'Failed to load file');
                }

                const language = detectLanguage(fileName);

                // Check if model already exists and dispose it
                const uri = monaco.Uri.file(filePath);
                let model = monaco.editor.getModel(uri);
                
                if (model) {
                    // Model exists - dispose it first
                    model.dispose();
                }
                
                // Create new model
                model = monaco.editor.createModel(
                    data.content,
                    language,
                    uri
                );

                openFiles.set(filePath, {
                    model,
                    dirty: false,
                    name: fileName,
                    path: filePath,
                    originalContent: data.content
                });

                addTab(filePath, fileName);
                setActiveFile(filePath);

                console.log('Opened:', fileName, 'Language:', language);

            } catch (error) {
                console.error('Failed to open file:', error);
                showToast('Failed to open file: ' + error.message, 'error');
            }
        }

        function detectLanguage(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const langMap = {
                'md': 'markdown',
                'markdown': 'markdown',
                'json': 'json',
                'js': 'javascript',
                'ts': 'typescript',
                'py': 'python',
                'html': 'html',
                'css': 'css',
                'yaml': 'yaml',
                'yml': 'yaml',
                'csv': 'csv',
                'tsv': 'csv',
                'txt': 'plaintext'
            };
            return langMap[ext] || 'plaintext';
        }

        function setActiveFile(filePath) {
            activeFile = filePath;
            const fileData = openFiles.get(filePath);

            if (!fileData) return;

            editor.setModel(fileData.model);

            document.querySelectorAll('.file-item').forEach(item => {
                item.classList.toggle('active', item.dataset.path === filePath);
            });

            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.path === filePath);
            });

            document.getElementById('status-file').textContent = fileData.name;
            document.getElementById('status-lang').textContent = 
                fileData.model.getLanguageId().toUpperCase();

            updateSaveButtons();
            updateFileStats();
            
            // Show/hide preview button for previewable file types
            const language = fileData.model.getLanguageId();
            const fileName = fileData.name.toLowerCase();
            const isImage = /\.(png|jpg|jpeg|gif|webp|svg|bmp|ico)$/i.test(fileName);
            const isPDF = fileName.endsWith('.pdf');
            const isPreviewable = ['markdown', 'html', 'json', 'css', 'svg'].includes(language) || isImage || isPDF;
            document.getElementById('preview-btn').style.display = isPreviewable ? 'flex' : 'none';
            
            // Update preview if it's open and file is previewable
            const previewPane = document.getElementById('preview-pane');
            if (isPreviewable && !previewPane.classList.contains('hidden')) {
                updatePreview();
                updatePreviewHeader();
            } else if (!isPreviewable && !previewPane.classList.contains('hidden')) {
                // Hide preview if switching to non-previewable file
                previewPane.classList.add('hidden');
            }
            
            updateBreadcrumb();
            addToRecentFiles(filePath, fileData.name);
            saveWorkspaceState();
        }
        
        function updateBreadcrumb() {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            const breadcrumbBar = document.getElementById('breadcrumb-bar');
            
            if (!fileData) {
                breadcrumbBar.style.display = 'none';
                return;
            }
            
            breadcrumbBar.style.display = 'flex';
            const pathParts = fileData.path.split('/');
            
            const rootName = FileAPI.getDisplayName();
            let html = `<span class="breadcrumb-item">${rootName}</span>`;
            
            for (let i = 0; i < pathParts.length; i++) {
                const isLast = i === pathParts.length - 1;
                html += `<span class="breadcrumb-separator">‚ñ∏</span>`;
                html += `<span class="breadcrumb-item ${isLast ? 'active' : ''}">${pathParts[i]}</span>`;
            }
            
            breadcrumbBar.innerHTML = html;
        }
        
        function addToRecentFiles(filePath, fileName) {
            // Remove if already in list
            recentFiles = recentFiles.filter(f => f.path !== filePath);
            
            // Add to front
            recentFiles.unshift({ path: filePath, name: fileName, timestamp: Date.now() });
            
            // Limit size
            if (recentFiles.length > MAX_RECENT_FILES) {
                recentFiles = recentFiles.slice(0, MAX_RECENT_FILES);
            }
            
            // Save to localStorage
            try {
                if (folderPath) localStorage.setItem(`cosmo-recent-files-${folderPath}`, JSON.stringify(recentFiles));
            } catch (e) {
                console.error('Failed to save recent files:', e);
            }
        }
        
        function loadRecentFiles() {
            try {
                if (!folderPath) return;  // No folder selected yet
                const saved = folderPath ? localStorage.getItem(`cosmo-recent-files-${folderPath}`) : null;
                if (saved) {
                    recentFiles = JSON.parse(saved);
                }
            } catch (e) {
                console.error('Failed to load recent files:', e);
                recentFiles = [];
            }
        }
        
        function showRecentFiles() {
            if (recentFiles.length === 0) {
                showToast('No recent files', 'error');
                return;
            }
            
            // Show in command palette
            toggleCommandPalette('recent');
        }

        async function saveCurrentFile() {
            if (!activeFile) return;

            const fileData = openFiles.get(activeFile);
            if (!fileData || !fileData.dirty) return;

            try {
                const content = fileData.model.getValue();

                const data = await FileAPI.writeFile(fileData.path, content);

                if (!data.success) {
                    throw new Error(data.error || 'Save failed');
                }

                fileData.dirty = false;
                fileData.originalContent = content;
                updateTabDirtyState(activeFile, false);
                updateSaveButtons();

                showToast(`Saved: ${fileData.name}`, 'success');
                console.log('Saved:', fileData.path);

            } catch (error) {
                console.error('Save failed:', error);
                showToast('Save failed: ' + error.message, 'error');
            }
        }

        async function saveAllFiles() {
            const dirtyFiles = Array.from(openFiles.entries())
                .filter(([path, data]) => data.dirty);

            if (dirtyFiles.length === 0) return;

            let savedCount = 0;
            let failedCount = 0;

            for (const [filePath, fileData] of dirtyFiles) {
                try {
                    const content = fileData.model.getValue();

                    const response = await fetch(`/api/compiled-docs/${runName}/${systemId}/file/${encodeURIComponent(fileData.path)}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ content })
                    });

                    const data = await response.json();

                    if (data.success) {
                        fileData.dirty = false;
                        fileData.originalContent = content;
                        updateTabDirtyState(filePath, false);
                        savedCount++;
                    } else {
                        failedCount++;
                    }

                } catch (error) {
                    console.error('Failed to save:', fileData.path, error);
                    failedCount++;
                }
            }

            updateSaveButtons();

            if (failedCount === 0) {
                showToast(`Saved ${savedCount} ${savedCount === 1 ? 'file' : 'files'}`, 'success');
            } else {
                showToast(`Saved ${savedCount}, failed ${failedCount}`, 'error');
            }
        }

        // ============================================================================
        // TAB MANAGEMENT
        // ============================================================================
        
        function addTab(filePath, fileName) {
            const tab = document.createElement('button');
            tab.className = 'tab';
            if (pinnedTabs.has(filePath)) {
                tab.classList.add('pinned');
            }
            tab.dataset.path = filePath;
            tab.draggable = true;
            
            // Create tab content
            const pinIcon = document.createElement('span');
            pinIcon.className = 'tab-pin';
            pinIcon.textContent = pinnedTabs.has(filePath) ? 'üìå' : 'üìç';
            pinIcon.title = pinnedTabs.has(filePath) ? 'Unpin tab' : 'Pin tab';
            pinIcon.onclick = (e) => {
                e.stopPropagation();
                togglePinTab(filePath);
            };
            
            const tabName = document.createElement('span');
            tabName.className = 'tab-name';
            tabName.textContent = fileName;
            
            const closeBtn = document.createElement('span');
            closeBtn.className = 'tab-close';
            closeBtn.textContent = '√ó';
            closeBtn.onclick = (e) => {
                e.stopPropagation();
                closeTab(filePath);
            };
            
            tab.appendChild(pinIcon);
            tab.appendChild(tabName);
            tab.appendChild(closeBtn);
            tab.onclick = () => setActiveFile(filePath);
            
            // Drag and drop handlers
            tab.addEventListener('dragstart', handleTabDragStart);
            tab.addEventListener('dragover', handleTabDragOver);
            tab.addEventListener('drop', handleTabDrop);
            tab.addEventListener('dragend', handleTabDragEnd);
            
            // Context menu (right-click)
            tab.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showContextMenu(e.clientX, e.clientY, filePath);
            });
            
            // Insert tab in correct position (pinned tabs first)
            const tabsBar = document.getElementById('tabs-bar');
            if (pinnedTabs.has(filePath)) {
                // Find position among pinned tabs
                const pinnedTabElements = Array.from(tabsBar.querySelectorAll('.tab.pinned'));
                tabsBar.insertBefore(tab, pinnedTabElements[pinnedTabElements.length] || tabsBar.firstChild);
            } else {
                tabsBar.appendChild(tab);
            }
        }
        
        // Tab drag and drop
        let draggedTab = null;
        
        function handleTabDragStart(e) {
            draggedTab = e.currentTarget;
            e.currentTarget.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', e.currentTarget.dataset.path);
        }
        
        function handleTabDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            
            const target = e.currentTarget;
            if (target !== draggedTab && target.classList.contains('tab')) {
                target.classList.add('drag-over');
            }
            return false;
        }
        
        function handleTabDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            const target = e.currentTarget;
            target.classList.remove('drag-over');
            
            if (draggedTab !== target) {
                const tabsBar = document.getElementById('tabs-bar');
                const allTabs = Array.from(tabsBar.children);
                const draggedIndex = allTabs.indexOf(draggedTab);
                const targetIndex = allTabs.indexOf(target);
                
                if (draggedIndex < targetIndex) {
                    tabsBar.insertBefore(draggedTab, target.nextSibling);
                } else {
                    tabsBar.insertBefore(draggedTab, target);
                }
            }
            
            return false;
        }
        
        function handleTabDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('drag-over');
            });
        }
        
        function togglePinTab(filePath) {
            if (pinnedTabs.has(filePath)) {
                pinnedTabs.delete(filePath);
            } else {
                pinnedTabs.add(filePath);
            }
            
            // Update tab appearance
            const tab = document.querySelector(`.tab[data-path="${filePath}"]`);
            if (tab) {
                tab.classList.toggle('pinned');
                const pinIcon = tab.querySelector('.tab-pin');
                if (pinIcon) {
                    pinIcon.textContent = pinnedTabs.has(filePath) ? 'üìå' : 'üìç';
                    pinIcon.title = pinnedTabs.has(filePath) ? 'Unpin tab' : 'Pin tab';
                }
                
                // Move tab to correct position
                const tabsBar = document.getElementById('tabs-bar');
                tab.remove();
                
                if (pinnedTabs.has(filePath)) {
                    const pinnedTabElements = Array.from(tabsBar.querySelectorAll('.tab.pinned'));
                    tabsBar.insertBefore(tab, pinnedTabElements[pinnedTabElements.length] || tabsBar.firstChild);
                } else {
                    const firstUnpinned = tabsBar.querySelector('.tab:not(.pinned)');
                    if (firstUnpinned) {
                        tabsBar.insertBefore(tab, firstUnpinned.nextSibling);
                    } else {
                        tabsBar.appendChild(tab);
                    }
                }
            }
            
            saveWorkspaceState();
        }

        function closeTab(filePath) {
            const fileData = openFiles.get(filePath);

            if (!fileData) return;

            if (fileData.dirty) {
                if (!confirm(`File has unsaved changes. Close anyway?`)) {
                    return;
                }
            }

            fileData.model.dispose();
            openFiles.delete(filePath);

            const tab = document.querySelector(`.tab[data-path="${filePath}"]`);
            if (tab) {
                tab.remove();
            }

            if (activeFile === filePath) {
                const remainingFiles = Array.from(openFiles.keys());
                if (remainingFiles.length > 0) {
                    setActiveFile(remainingFiles[0]);
                } else {
                    activeFile = null;
                    editor.setModel(null);
                    document.getElementById('status-file').textContent = 'No file open';
                    document.getElementById('status-lang').textContent = '';
                    updateSaveButtons();
                }
            }
            
            saveWorkspaceState();
        }

        function updateTabDirtyState(filePath, dirty) {
            const tab = document.querySelector(`.tab[data-path="${filePath}"]`);
            if (!tab) return;

            const fileData = openFiles.get(filePath);
            const nameSpan = tab.querySelector('.tab-name');
            
            if (dirty) {
                nameSpan.textContent = '‚óè ' + fileData.name;
            } else {
                nameSpan.textContent = fileData.name;
            }
        }

        // ============================================================================
        // COMMAND PALETTE
        // ============================================================================
        
        // Commands will be initialized after all functions are defined
        let commands = [];

        function toggleCommandPalette(mode = 'command') {
            const palette = document.getElementById('command-palette');
            const input = document.getElementById('command-input');
            const overlay = document.getElementById('overlay');
            
            if (palette.classList.contains('hidden')) {
                palette.classList.remove('hidden');
                overlay.classList.remove('hidden');
                input.value = '';
                
                if (mode === 'file') {
                    input.placeholder = 'Type to search files...';
                    renderFileCommands();
                } else if (mode === 'recent') {
                    input.placeholder = 'Recent files...';
                    renderRecentFileCommands();
                } else {
                    input.placeholder = 'Type a command or search files...';
                    renderCommands('');
                }
                
                input.focus();
                input.dataset.mode = mode;
            } else {
                palette.classList.add('hidden');
                overlay.classList.add('hidden');
            }
        }

        function renderCommands(query) {
            const results = document.getElementById('command-results');
            selectedCommandIndex = 0;
            
            let filtered = commands;
            
            if (query) {
                query = query.toLowerCase();
                filtered = commands.filter(cmd => 
                    cmd.label.toLowerCase().includes(query) ||
                    cmd.id.toLowerCase().includes(query)
                );
            }
            
            results.innerHTML = filtered.map((cmd, idx) => `
                <div class="command-item ${idx === 0 ? 'selected' : ''}" data-index="${idx}" onclick="executeCommand('${cmd.id}')">
                    <span class="command-label">${cmd.label}</span>
                    ${cmd.keys ? `<span class="command-keys">${cmd.keys}</span>` : ''}
                </div>
            `).join('');
        }

        function renderFileCommands() {
            const results = document.getElementById('command-results');
            selectedCommandIndex = 0;
            
            const flatFiles = [];
            const collectFiles = (items) => {
                items.forEach(item => {
                    if (item.type !== 'directory') {
                        flatFiles.push(item);
                    }
                    if (item.children) {
                        collectFiles(item.children);
                    }
                });
            };
            collectFiles(allFiles);
            
            results.innerHTML = flatFiles.map((file, idx) => `
                <div class="command-item ${idx === 0 ? 'selected' : ''}" data-index="${idx}" onclick="openFileFromPalette('${file.path}', '${file.name}')">
                    <span class="command-label">${file.path}</span>
                </div>
            `).join('');
        }
        
        function renderRecentFileCommands() {
            const results = document.getElementById('command-results');
            selectedCommandIndex = 0;
            
            if (recentFiles.length === 0) {
                results.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: var(--text-secondary);">
                        No recent files
                    </div>
                `;
                return;
            }
            
            results.innerHTML = recentFiles.map((file, idx) => {
                const timeAgo = formatTimeAgo(file.timestamp);
                return `
                    <div class="command-item ${idx === 0 ? 'selected' : ''}" data-index="${idx}" onclick="openFileFromPalette('${file.path}', '${file.name}')">
                        <span class="command-label">${file.name}</span>
                        <span class="command-keys">${timeAgo}</span>
                    </div>
                `;
            }).join('');
        }
        
        function formatTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            return `${days}d ago`;
        }

        function executeCommand(commandId) {
            const cmd = commands.find(c => c.id === commandId);
            if (cmd && cmd.action) {
                cmd.action();
                toggleCommandPalette();
            }
        }

        function executeSelectedCommand() {
            const selected = document.querySelector('.command-item.selected');
            if (selected) {
                selected.click();
            }
        }

        function openFileFromPalette(path, name) {
            openFile(path, name);
            toggleCommandPalette();
        }

        function navigateCommands(direction) {
            const items = document.querySelectorAll('.command-item');
            if (items.length === 0) return;
            
            items[selectedCommandIndex].classList.remove('selected');
            selectedCommandIndex = (selectedCommandIndex + direction + items.length) % items.length;
            items[selectedCommandIndex].classList.add('selected');
            
            items[selectedCommandIndex].scrollIntoView({ block: 'nearest' });
        }

        // Listen to input changes
        document.addEventListener('DOMContentLoaded', () => {
            const input = document.getElementById('command-input');
            if (input) {
                input.addEventListener('input', (e) => {
                    const query = e.target.value;
                    const mode = e.target.dataset.mode || 'command';
                    
                    if (mode === 'command') {
                        renderCommands(query);
                    } else if (mode === 'file') {
                        // Could filter files by query here
                        renderFileCommands();
                    } else if (mode === 'recent') {
                        // Could filter recent files by query here
                        renderRecentFileCommands();
                    }
                });
            }
            
            // Load recent files on startup
            loadRecentFiles();
        });

        // ============================================================================
        // MARKDOWN PREVIEW
        // ============================================================================
        
        function togglePreview() {
            const pane = document.getElementById('preview-pane');
            pane.classList.toggle('hidden');
            
            if (!pane.classList.contains('hidden')) {
                updatePreview();
                updatePreviewHeader();
            }
        }
        
        function updatePreviewHeader() {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) return;
            
            const language = fileData.model.getLanguageId();
            const fileName = fileData.name.toLowerCase();
            const previewHeader = document.querySelector('.preview-header span');
            
            if (language === 'markdown') {
                previewHeader.textContent = 'üìÑ Markdown Preview';
            } else if (language === 'html') {
                previewHeader.textContent = 'üåê HTML Preview';
            } else if (language === 'json') {
                previewHeader.textContent = 'üìä JSON Viewer';
            } else if (language === 'css') {
                previewHeader.textContent = 'üé® CSS Preview';
            } else if (language === 'svg' || fileName.endsWith('.svg')) {
                previewHeader.textContent = 'üñºÔ∏è SVG Preview';
            } else if (fileName.endsWith('.pdf')) {
                previewHeader.textContent = 'üìë PDF Viewer';
            } else if (/\.(png|jpg|jpeg|gif|webp|bmp|ico)$/i.test(fileName)) {
                previewHeader.textContent = 'üñºÔ∏è Image Preview';
            } else {
                previewHeader.textContent = 'üëÅÔ∏è Preview';
            }
        }

        function schedulePreviewUpdate() {
            if (document.getElementById('preview-pane').classList.contains('hidden')) return;
            
            clearTimeout(previewUpdateTimer);
            previewUpdateTimer = setTimeout(updatePreview, 500);
        }

        function updatePreview() {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) return;
            
            const language = fileData.model.getLanguageId();
            const fileName = fileData.name.toLowerCase();
            const content = fileData.model.getValue();
            const previewContent = document.getElementById('preview-content');
            
            try {
                if (language === 'markdown') {
                    // Parse markdown to HTML
            const html = marked.parse(content);
                    previewContent.innerHTML = html;
                    
                } else if (language === 'html') {
                    // Render HTML in sandboxed iframe
                    previewContent.innerHTML = `
                        <iframe 
                            id="html-preview-frame" 
                            style="width: 100%; height: 100%; border: none; background: white;"
                            sandbox="allow-same-origin allow-scripts"
                        ></iframe>
                    `;
                    const iframe = document.getElementById('html-preview-frame');
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    iframeDoc.open();
                    iframeDoc.write(content);
                    iframeDoc.close();
                    
                } else if (language === 'json') {
                    // JSON formatted tree view
                    try {
                        const parsed = JSON.parse(content);
                        const formatted = JSON.stringify(parsed, null, 2);
                        previewContent.innerHTML = `
                            <div style="padding: 20px; font-family: 'Monaco', monospace; font-size: 13px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 16px; border-bottom: 1px solid #3e3e42; padding-bottom: 12px;">
                                    <strong style="color: var(--text-active);">JSON Structure</strong>
                                    <button onclick="copyJsonToClipboard()" class="btn btn-secondary" style="padding: 4px 12px; font-size: 11px;">
                                        Copy Formatted
                                    </button>
                                </div>
                                <div id="json-tree-view"></div>
                            </div>
                        `;
                        renderJsonTree(parsed, document.getElementById('json-tree-view'));
                    } catch (e) {
                        previewContent.innerHTML = `
                            <div style="color: var(--error-color); padding: 20px;">
                                <strong>Invalid JSON</strong><br>
                                ${e.message}
                                <pre style="margin-top: 12px; padding: 12px; background: var(--bg-secondary); border-radius: 4px; overflow-x: auto;">${content}</pre>
                            </div>
                        `;
                    }
                    
                } else if (language === 'css') {
                    // CSS preview with test HTML
                    previewContent.innerHTML = `
                        <iframe 
                            id="css-preview-frame" 
                            style="width: 100%; height: 100%; border: none; background: white;"
                            sandbox="allow-same-origin"
                        ></iframe>
                    `;
                    const iframe = document.getElementById('css-preview-frame');
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    const testHTML = `
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <style>${content}</style>
                        </head>
                        <body>
                            <h1>Heading 1</h1>
                            <h2>Heading 2</h2>
                            <h3>Heading 3</h3>
                            <p>This is a paragraph with <strong>bold</strong> and <em>italic</em> text.</p>
                            <p>Another paragraph with a <a href="#">link</a>.</p>
                            <ul>
                                <li>Unordered list item 1</li>
                                <li>Unordered list item 2</li>
                                <li>Unordered list item 3</li>
                            </ul>
                            <ol>
                                <li>Ordered list item 1</li>
                                <li>Ordered list item 2</li>
                                <li>Ordered list item 3</li>
                            </ol>
                            <button>Button</button>
                            <input type="text" placeholder="Text input" />
                            <table>
                                <tr><th>Header 1</th><th>Header 2</th></tr>
                                <tr><td>Cell 1</td><td>Cell 2</td></tr>
                                <tr><td>Cell 3</td><td>Cell 4</td></tr>
                            </table>
                            <div class="box">Box with class "box"</div>
                            <div id="special">Div with id "special"</div>
                        </body>
                        </html>
                    `;
                    iframeDoc.open();
                    iframeDoc.write(testHTML);
                    iframeDoc.close();
                    
                } else if (language === 'svg' || fileName.endsWith('.svg')) {
                    // SVG preview
                    previewContent.innerHTML = `
                        <div style="padding: 20px; text-align: center; background: white; height: 100%; overflow: auto;">
                            ${content}
                        </div>
                    `;
                    
                } else if (fileName.endsWith('.pdf')) {
                    // PDF viewer (requires base64 encoded content or URL)
                    previewContent.innerHTML = `
                        <div style="padding: 20px; text-align: center;">
                            <p style="color: var(--text-secondary); margin-bottom: 16px;">
                                PDF preview requires a URL or base64 encoded content.
                            </p>
                            <button onclick="downloadCurrentFile()" class="btn">
                                Download PDF to View
                            </button>
                        </div>
                    `;
                    
                } else if (/\.(png|jpg|jpeg|gif|webp|bmp|ico)$/i.test(fileName)) {
                    // Image preview
                    // For images, we need to read as data URL or use the file path
                    previewContent.innerHTML = `
                        <div style="padding: 20px; text-align: center; background: #f0f0f0; height: 100%; overflow: auto; display: flex; align-items: center; justify-content: center;">
                            <div>
                                <div style="color: #666; margin-bottom: 12px; font-size: 12px;">
                                    ${fileData.name}
                                </div>
                                <div style="color: #999; font-size: 11px;">
                                    Image preview requires loading from file system or data URL.
                                    <br>Use Download button to save and view externally.
                                </div>
                                <button onclick="downloadCurrentFile()" class="btn" style="margin-top: 16px;">
                                    Download Image
                                </button>
                            </div>
                        </div>
                    `;
                }
                
            } catch (error) {
                console.error('Preview error:', error);
                previewContent.innerHTML = 
                    `<div style="color: var(--error-color); padding: 20px;">
                        <strong>Preview Error</strong><br>
                        ${error.message}
                    </div>`;
            }
        }
        
        // Helper function to render JSON tree
        function renderJsonTree(obj, container, level = 0) {
            const indent = level * 20;
            
            if (obj === null) {
                container.innerHTML += `<div style="margin-left: ${indent}px; color: #569cd6;">null</div>`;
                return;
            }
            
            if (typeof obj !== 'object') {
                const color = typeof obj === 'string' ? '#ce9178' : 
                             typeof obj === 'number' ? '#b5cea8' : 
                             typeof obj === 'boolean' ? '#569cd6' : '#cccccc';
                const value = typeof obj === 'string' ? `"${obj}"` : String(obj);
                container.innerHTML += `<div style="margin-left: ${indent}px; color: ${color};">${value}</div>`;
                return;
            }
            
            const isArray = Array.isArray(obj);
            const entries = Object.entries(obj);
            
            if (entries.length === 0) {
                container.innerHTML += `<div style="margin-left: ${indent}px; color: #808080;">${isArray ? '[]' : '{}'}</div>`;
                return;
            }
            
            for (let i = 0; i < entries.length; i++) {
                const [key, value] = entries[i];
                const isLast = i === entries.length - 1;
                const isExpandable = value !== null && typeof value === 'object';
                
                const line = document.createElement('div');
                line.style.marginLeft = indent + 'px';
                line.style.marginTop = '2px';
                
                if (isExpandable) {
                    const toggle = document.createElement('span');
                    toggle.textContent = '‚ñº ';
                    toggle.style.cursor = 'pointer';
                    toggle.style.color = '#808080';
                    toggle.style.fontSize = '10px';
                    toggle.style.marginRight = '4px';
                    
                    const keySpan = document.createElement('span');
                    keySpan.style.color = '#9cdcfe';
                    keySpan.textContent = isArray ? `[${key}]` : `"${key}"`;
                    
                    const colonSpan = document.createElement('span');
                    colonSpan.textContent = ': ';
                    colonSpan.style.color = '#cccccc';
                    
                    const typeSpan = document.createElement('span');
                    typeSpan.style.color = '#808080';
                    typeSpan.textContent = Array.isArray(value) ? `Array(${value.length})` : 'Object';
                    
                    const childContainer = document.createElement('div');
                    childContainer.style.marginLeft = '20px';
                    
                    toggle.onclick = () => {
                        const isCollapsed = childContainer.style.display === 'none';
                        childContainer.style.display = isCollapsed ? 'block' : 'none';
                        toggle.textContent = isCollapsed ? '‚ñº ' : '‚ñ∂ ';
                    };
                    
                    line.appendChild(toggle);
                    line.appendChild(keySpan);
                    line.appendChild(colonSpan);
                    line.appendChild(typeSpan);
                    container.appendChild(line);
                    container.appendChild(childContainer);
                    
                    renderJsonTree(value, childContainer, level + 1);
                } else {
                    const keySpan = document.createElement('span');
                    keySpan.style.color = '#9cdcfe';
                    keySpan.style.marginLeft = '16px';
                    keySpan.textContent = isArray ? `[${key}]` : `"${key}"`;
                    
                    const colonSpan = document.createElement('span');
                    colonSpan.textContent = ': ';
                    colonSpan.style.color = '#cccccc';
                    
                    const valueColor = typeof value === 'string' ? '#ce9178' : 
                                      typeof value === 'number' ? '#b5cea8' : 
                                      typeof value === 'boolean' ? '#569cd6' : '#cccccc';
                    const valueSpan = document.createElement('span');
                    valueSpan.style.color = valueColor;
                    valueSpan.textContent = typeof value === 'string' ? `"${value}"` : String(value);
                    
                    line.appendChild(keySpan);
                    line.appendChild(colonSpan);
                    line.appendChild(valueSpan);
                    container.appendChild(line);
                }
            }
        }
        
        function copyJsonToClipboard() {
            if (!activeFile) return;
            const fileData = openFiles.get(activeFile);
            if (!fileData) return;
            
            try {
                const content = fileData.model.getValue();
                const parsed = JSON.parse(content);
                const formatted = JSON.stringify(parsed, null, 2);
                copyToClipboard(formatted);
            } catch (e) {
                showToast('Invalid JSON, cannot copy', 'error');
            }
        }

        // ============================================================================
        // SEARCH & REPLACE
        // ============================================================================
        
        function toggleSearch() {
            const panel = document.getElementById('search-panel');
            panel.classList.toggle('hidden');
            
            if (!panel.classList.contains('hidden')) {
                document.getElementById('search-input').focus();
            }
        }

        function findNext() {
            const query = document.getElementById('search-input').value;
            if (!query || !editor) return;
            
            const caseSensitive = document.getElementById('search-case').checked;
            const wholeWord = document.getElementById('search-whole').checked;
            const regex = document.getElementById('search-regex').checked;
            
            // Use Monaco's find controller with our options
            const findController = editor.getContribution('editor.contrib.findController');
            if (findController) {
                findController.start({
                    forceRevealReplace: false,
                    seedSearchStringFromSelection: 'never',
                    seedSearchStringFromGlobalClipboard: false,
                    shouldFocus: 2, // FindInputFocusType.FindInput
                    shouldAnimate: true,
                    updateSearchScope: false,
                    loop: true
                });
                
                // Set the search string and options
                const state = findController.getState();
                if (state) {
                    state.change({
                        searchString: query,
                        isRegex: regex,
                        matchCase: caseSensitive,
                        wholeWord: wholeWord
                    }, false);
                }
                
                // Find next match
                findController.moveToNextMatch();
            }
        }

        function replaceOne() {
            const find = document.getElementById('search-input').value;
            const replace = document.getElementById('replace-input').value;
            if (!find || !editor) return;
            
            const caseSensitive = document.getElementById('search-case').checked;
            const wholeWord = document.getElementById('search-whole').checked;
            const regex = document.getElementById('search-regex').checked;
            
            // Get current selection
            const selection = editor.getSelection();
            if (!selection) return;
            
            const model = editor.getModel();
            if (!model) return;
            
            const text = model.getValueInRange(selection);
            
            // Check if selection matches search (accounting for options)
            let matches = false;
            if (regex) {
                try {
                    const regexPattern = new RegExp(find, caseSensitive ? '' : 'i');
                    matches = regexPattern.test(text);
                } catch (e) {
                    showToast('Invalid regex pattern', 'error');
                    return;
                }
            } else {
                matches = caseSensitive ? text === find : text.toLowerCase() === find.toLowerCase();
                if (wholeWord && matches) {
                    // Check word boundaries
                    const start = selection.getStartPosition();
                    const end = selection.getEndPosition();
                    const startCol = start.column;
                    const endCol = end.column;
                    const line = model.getLineContent(start.lineNumber);
                    
                    const beforeChar = startCol > 1 ? line[startCol - 2] : ' ';
                    const afterChar = endCol <= line.length ? line[endCol - 1] : ' ';
                    
                    const wordBoundary = /\W/;
                    matches = wordBoundary.test(beforeChar) && wordBoundary.test(afterChar);
                }
            }
            
            if (matches) {
                editor.executeEdits('replace', [{
                    range: selection,
                    text: replace
                }]);
                showToast('Replaced 1 occurrence', 'success');
                
                // Find next match after replace
                setTimeout(() => findNext(), 100);
            } else {
                showToast('Selection does not match search', 'error');
            }
        }
        
        function replaceAll() {
            const find = document.getElementById('search-input').value;
            const replace = document.getElementById('replace-input').value;
            if (!find || !editor) return;
            
            const caseSensitive = document.getElementById('search-case').checked;
            const wholeWord = document.getElementById('search-whole').checked;
            const regex = document.getElementById('search-regex').checked;
            
            const model = editor.getModel();
            if (!model) return;
            
            let searchRegex;
            try {
                if (regex) {
                    searchRegex = new RegExp(find, 'g' + (caseSensitive ? '' : 'i'));
                } else {
                    const escapedFind = find.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const pattern = wholeWord ? `\\b${escapedFind}\\b` : escapedFind;
                    searchRegex = new RegExp(pattern, 'g' + (caseSensitive ? '' : 'i'));
                }
            } catch (e) {
                showToast('Invalid search pattern', 'error');
                return;
            }
            
            const content = model.getValue();
            const newContent = content.replace(searchRegex, replace);
            const matches = (content.match(searchRegex) || []).length;
            
            if (matches > 0) {
                model.setValue(newContent);
                showToast(`Replaced ${matches} occurrence${matches === 1 ? '' : 's'}`, 'success');
            } else {
                showToast('No matches found', 'error');
            }
        }

        // ============================================================================
        // SETTINGS
        // ============================================================================
        
        function loadSettings() {
            try {
            const saved = localStorage.getItem('cosmo-ide-settings');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Validate and merge with defaults
                    return { ...defaultSettings, ...parsed };
                }
            } catch (e) {
                console.error('Failed to load settings:', e);
                // Clear corrupted settings
                localStorage.removeItem('cosmo-ide-settings');
            }
            return { ...defaultSettings };
        }

        function saveSettings() {
            localStorage.setItem('cosmo-ide-settings', JSON.stringify(settings));
        }

        function toggleSettings() {
            const panel = document.getElementById('settings-panel');
            panel.classList.toggle('open');
            
            if (panel.classList.contains('open')) {
                // Load current settings into UI
                document.getElementById('setting-theme').value = settings.theme;
                document.getElementById('setting-font-size').value = settings.fontSize;
                document.getElementById('setting-tab-size').value = settings.tabSize;
                document.getElementById('setting-minimap').checked = settings.minimap;
                document.getElementById('setting-line-numbers').checked = settings.lineNumbers;
                document.getElementById('setting-word-wrap').checked = settings.wordWrap;
                document.getElementById('setting-auto-save').value = settings.autoSave;
                document.getElementById('setting-auto-save-delay').value = settings.autoSaveDelay;
            }
        }

        function applyTheme() {
            settings.theme = document.getElementById('setting-theme').value;
            monaco.editor.setTheme(settings.theme);
            saveSettings();
        }

        function applyFontSize() {
            settings.fontSize = parseInt(document.getElementById('setting-font-size').value);
            editor.updateOptions({ fontSize: settings.fontSize });
            saveSettings();
        }

        function applyTabSize() {
            settings.tabSize = parseInt(document.getElementById('setting-tab-size').value);
            editor.updateOptions({ tabSize: settings.tabSize });
            saveSettings();
        }

        function applyMinimap() {
            settings.minimap = document.getElementById('setting-minimap').checked;
            editor.updateOptions({ minimap: { enabled: settings.minimap } });
            saveSettings();
        }

        function applyLineNumbers() {
            settings.lineNumbers = document.getElementById('setting-line-numbers').checked;
            editor.updateOptions({ lineNumbers: settings.lineNumbers ? 'on' : 'off' });
            saveSettings();
        }

        function applyWordWrap() {
            settings.wordWrap = document.getElementById('setting-word-wrap').checked;
            editor.updateOptions({ wordWrap: settings.wordWrap ? 'on' : 'off' });
            saveSettings();
        }

        function applyAutoSave() {
            settings.autoSave = document.getElementById('setting-auto-save').value;
            settings.autoSaveDelay = parseInt(document.getElementById('setting-auto-save-delay').value);
            saveSettings();
            setupAutoSave();
        }

        function setupAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
            }
            
            if (settings.autoSave === 'afterDelay') {
                autoSaveTimer = setInterval(() => {
                    const hasDirty = Array.from(openFiles.values()).some(f => f.dirty);
                    if (hasDirty) {
                        saveAllFiles();
                    }
                }, settings.autoSaveDelay);
            }
        }

        function resetSettings() {
            if (!confirm('Reset all settings to defaults?')) return;
            
            settings = { ...defaultSettings };
            saveSettings();
            toggleSettings();
            
            // Reload to apply all defaults
            location.reload();
        }

        // ============================================================================
        // WORKSPACE STATE PERSISTENCE
        // ============================================================================
        
        function saveWorkspaceState() {
            const state = {
                openTabs: Array.from(openFiles.keys()),
                activeFile: activeFile,
                sidebarCollapsed: document.getElementById('sidebar').classList.contains('collapsed'),
                pinnedTabs: Array.from(pinnedTabs),
            };
            
            const key = folderPath ? `cosmo-workspace-${folderPath}` : 'cosmo-workspace-default';
            localStorage.setItem(key, JSON.stringify(state));
        }

        function restoreWorkspaceState() {
            if (!folderPath) return;  // No folder selected yet
            const key = folderPath ? `cosmo-workspace-${folderPath}` : 'cosmo-workspace-default';
            const saved = localStorage.getItem(key);
            
            if (!saved) return;
            
            try {
                const state = JSON.parse(saved);
                
                // Restore sidebar state
                if (state.sidebarCollapsed) {
                    toggleSidebar();
                }
                
                // Restore pinned tabs
                if (state.pinnedTabs && Array.isArray(state.pinnedTabs)) {
                    pinnedTabs = new Set(state.pinnedTabs);
                }
                
                // Note: Files are already opened by loadFileTree()
                // Pinned status will be applied when tabs are created
            } catch (e) {
                console.error('Failed to restore workspace:', e);
            }
        }

        // ============================================================================
        // UI HELPERS
        // ============================================================================
        
        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('collapsed');
        }

        function toggleKeyboardHelp() {
            const help = document.getElementById('keyboard-help');
            const overlay = document.getElementById('overlay');
            help.classList.toggle('hidden');
            overlay.classList.toggle('hidden');
        }

        function closeAllModals() {
            document.getElementById('command-palette').classList.add('hidden');
            document.getElementById('keyboard-help').classList.add('hidden');
            document.getElementById('search-panel').classList.add('hidden');
            document.getElementById('context-menu').classList.add('hidden');
            document.getElementById('overlay').classList.add('hidden');
            // Note: Don't close AI panel on Escape - it's a persistent panel like preview
        }

        function showContextMenu(x, y, items) {
            const menu = document.getElementById('context-menu');
            
            // Clear previous content and event listeners
            menu.innerHTML = '';
            
            // Build menu items with proper event handlers
            items.forEach((item, index) => {
                if (item.type === 'separator') {
                    const separator = document.createElement('div');
                    separator.className = 'context-menu-separator';
                    menu.appendChild(separator);
                } else {
                    const menuItem = document.createElement('div');
                    menuItem.className = 'context-menu-item';
                    menuItem.textContent = item.label;
                    menuItem.dataset.index = index;
                    
                    // Add click handler
                    menuItem.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (item.action && typeof item.action === 'function') {
                            item.action();
                        }
                        menu.classList.add('hidden');
                    });
                    
                    menu.appendChild(menuItem);
                }
            });
            
            // Position menu
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.classList.remove('hidden');
            
            // Ensure menu stays within viewport
            setTimeout(() => {
                const rect = menu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
                }
                if (rect.bottom > window.innerHeight) {
                    menu.style.top = (window.innerHeight - rect.height - 10) + 'px';
                }
            }, 0);
            
            // Close on click outside
            setTimeout(() => {
                const closeHandler = (e) => {
                    if (!menu.contains(e.target)) {
                    menu.classList.add('hidden');
                        document.removeEventListener('click', closeHandler);
                    }
                };
                document.addEventListener('click', closeHandler);
            }, 0);
        }

        function copyToClipboard(text) {
            if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text).then(() => {
                showToast('Copied to clipboard', 'success');
                }).catch(err => {
                    console.error('Clipboard copy failed:', err);
                    fallbackCopyToClipboard(text);
                });
            } else {
                fallbackCopyToClipboard(text);
            }
        }
        
        function fallbackCopyToClipboard(text) {
            // Fallback for browsers that don't support clipboard API
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                showToast('Copied to clipboard', 'success');
            } catch (err) {
                console.error('Fallback copy failed:', err);
                showToast('Copy failed', 'error');
            }
            document.body.removeChild(textArea);
        }

        function updateSaveButtons() {
            const currentFileDirty = activeFile ? openFiles.get(activeFile)?.dirty : false;
            const hasDirtyFiles = Array.from(openFiles.values()).some(f => f.dirty);
            const hasActiveFile = activeFile !== null;

            document.getElementById('save-btn').disabled = !currentFileDirty;
            document.getElementById('save-all-btn').disabled = !hasDirtyFiles;
            document.getElementById('download-btn').disabled = !hasActiveFile;

            const dirtyCount = Array.from(openFiles.values()).filter(f => f.dirty).length;
            if (dirtyCount > 0) {
                document.getElementById('status-dirty').textContent = 
                    `${dirtyCount} unsaved ${dirtyCount === 1 ? 'file' : 'files'}`;
                document.getElementById('status-dirty').style.color = 'var(--warning-color)';
            } else {
                document.getElementById('status-dirty').textContent = '';
            }
        }

        function updateFileStats() {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) {
                document.getElementById('status-size').textContent = '';
                document.getElementById('status-words').textContent = '';
                return;
            }
            
            const content = fileData.model.getValue();
            const bytes = new Blob([content]).size;
            const size = bytes < 1024 ? `${bytes} B` : 
                        bytes < 1024 * 1024 ? `${(bytes / 1024).toFixed(1)} KB` : 
                        `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
            
            const words = content.split(/\s+/).filter(w => w.length > 0).length;
            
            document.getElementById('status-size').textContent = size;
            document.getElementById('status-words').textContent = `${words} words`;
        }

        function updateSelectionInfo() {
            const selection = editor.getSelection();
            if (!selection) return;
            
            const model = editor.getModel();
            if (!model) return;
            
            const start = model.getOffsetAt(selection.getStartPosition());
            const end = model.getOffsetAt(selection.getEndPosition());
            const length = end - start;
            
            if (length > 0) {
                const lines = selection.endLineNumber - selection.startLineNumber + 1;
                document.getElementById('status-selection').textContent = 
                    `${length} chars, ${lines} lines selected`;
            } else {
                document.getElementById('status-selection').textContent = '';
            }
        }

        function showToast(message, type = 'success', duration = 3000) {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease-out reverse';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        // ============================================================================
        // SYSTEM SWITCHING
        // ============================================================================
        
        async function loadAvailableSystems() {
            try {
            if (IDE_MODE === 'filesystem') return;  // Standalone mode
                const response = await fetch('/api/compiled-docs/all');
                const data = await response.json();
                
                if (data.success) {
                    availableSystems = data.systems;
                    
                    const picker = document.getElementById('system-picker');
                    picker.innerHTML = '';
                    
                    if (availableSystems.length === 0) {
                        picker.innerHTML = '<option value="">No systems compiled yet</option>';
                        picker.disabled = true;
                        return;
                    }
                    
                    const byRun = {};
                    availableSystems.forEach(sys => {
                        if (!byRun[sys.runName]) byRun[sys.runName] = [];
                        byRun[sys.runName].push(sys);
                    });
                    
                    for (const [run, systems] of Object.entries(byRun)) {
                        const group = document.createElement('optgroup');
                        group.label = run;
                        
                        systems.forEach(sys => {
                            const option = document.createElement('option');
                            option.value = `${sys.runName}:${sys.systemId}`;
                            option.textContent = sys.systemId;
                            
                            if (sys.runName === runName && sys.systemId === systemId) {
                                option.selected = true;
                            }
                            
                            group.appendChild(option);
                        });
                        
                        picker.appendChild(group);
                    }
                }
            } catch (error) {
                console.error('Failed to load available systems:', error);
            }
        }
        
        function switchSystem() {
            if (IDE_MODE === 'filesystem') return;  // Standalone mode
            const picker = document.getElementById('system-picker');
            const value = picker.value;
            
            if (!value) return;
            
            const hasDirty = Array.from(openFiles.values()).some(f => f.dirty);
            if (hasDirty) {
                if (!confirm('You have unsaved changes. Switch anyway?')) {
                    picker.value = `${runName}:${systemId}`;
                    return;
                }
            }
            
            const [newRun, newSystem] = value.split(':');
            window.location.href = `/docs-ide?run=${newRun}&system=${newSystem}`;
        }

        // ============================================================================
        // FILE MANAGEMENT
        // ============================================================================
        
        function closeOtherTabs() {
            if (!activeFile) return;
            
            const tabsToClose = Array.from(openFiles.keys()).filter(path => path !== activeFile);
            
            if (tabsToClose.length === 0) {
                showToast('No other tabs to close', 'error');
                return;
            }
            
            const dirtyTabs = tabsToClose.filter(path => openFiles.get(path)?.dirty);
            if (dirtyTabs.length > 0) {
                if (!confirm(`${dirtyTabs.length} tab(s) have unsaved changes. Close anyway?`)) {
                    return;
                }
            }
            
            tabsToClose.forEach(path => closeTab(path));
            showToast(`Closed ${tabsToClose.length} tab(s)`, 'success');
        }
        
        function closeUnpinnedTabs() {
            const tabsToClose = Array.from(openFiles.keys()).filter(path => !pinnedTabs.has(path));
            
            if (tabsToClose.length === 0) {
                showToast('No unpinned tabs to close', 'error');
                return;
            }
            
            const dirtyTabs = tabsToClose.filter(path => openFiles.get(path)?.dirty);
            if (dirtyTabs.length > 0) {
                if (!confirm(`${dirtyTabs.length} unpinned tab(s) have unsaved changes. Close anyway?`)) {
                    return;
                }
            }
            
            tabsToClose.forEach(path => closeTab(path));
            showToast(`Closed ${tabsToClose.length} unpinned tab(s)`, 'success');
        }
        
        function showNewFileDialog() {
            showToast('File creation requires backend API support', 'error');
            // TODO: Implement file creation via API
            // const fileName = prompt('Enter new file name:');
            // if (fileName) {
            //     createNewFile(fileName);
            // }
        }
        
        function renameFileDialog(filePath) {
            const fileData = openFiles.get(filePath);
            if (!fileData) return;
            
            showToast('File rename requires backend API support', 'error');
            // TODO: Implement file rename via API
            // const newName = prompt('Enter new file name:', fileData.name);
            // if (newName && newName !== fileData.name) {
            //     renameFile(filePath, newName);
            // }
        }
        
        function deleteFileDialog(filePath) {
            const fileData = openFiles.get(filePath);
            if (!fileData) return;
            
            if (!confirm(`Delete ${fileData.name}? This action cannot be undone.`)) {
                return;
            }
            
            showToast('File deletion requires backend API support', 'error');
            // TODO: Implement file deletion via API
            // deleteFile(filePath);
        }
        
        function showFindInFiles() {
            const query = prompt('Find in all files:');
            if (!query) return;
            
            showToast('Searching...', 'success');
            
            // Search through all open files and potentially all files in the system
            const results = [];
            
            // Search in open files
            for (const [path, fileData] of openFiles.entries()) {
                const content = fileData.model.getValue();
                const lines = content.split('\n');
                
                lines.forEach((line, lineNumber) => {
                    if (line.toLowerCase().includes(query.toLowerCase())) {
                        results.push({
                            path,
                            name: fileData.name,
                            line: lineNumber + 1,
                            content: line.trim()
                        });
                    }
                });
            }
            
            if (results.length === 0) {
                showToast('No results found in open files', 'error');
                return;
            }
            
            // Show results in command palette
            const palette = document.getElementById('command-palette');
            const input = document.getElementById('command-input');
            const resultsDiv = document.getElementById('command-results');
            const overlay = document.getElementById('overlay');
            
            palette.classList.remove('hidden');
            overlay.classList.remove('hidden');
            input.value = query;
            input.placeholder = `Found ${results.length} result(s)`;
            
            resultsDiv.innerHTML = results.map((result, idx) => `
                <div class="command-item ${idx === 0 ? 'selected' : ''}" data-index="${idx}" onclick="openFileFromPalette('${result.path}', '${result.name}')">
                    <div>
                        <div class="command-label">${result.name}:${result.line}</div>
                        <div style="font-size: 11px; color: var(--text-secondary); margin-top: 2px;">${result.content.substring(0, 80)}...</div>
                    </div>
                </div>
            `).join('');
        }

        // ============================================================================
        // AI ASSISTANT
        // ============================================================================
        
        let aiConversationHistory = [];
        let aiProcessing = false;
        
        function buildFileTreeContext() {
            // Build a compact representation of file tree for AI
            let totalCount = 0; // Shared counter across all recursion levels
            const maxItems = 100;
            
            const flattenTree = (items, depth = 0) => {
                let result = '';
                
                for (const item of items) {
                    if (totalCount >= maxItems) {
                        result += `${'  '.repeat(depth)}... (truncated at ${maxItems} items)\n`;
                        break;
                    }
                    
                    const indent = '  '.repeat(depth);
                    if (item.isDirectory) {
                        result += `${indent}üìÅ ${item.name}/\n`;
                        totalCount++;
                        if (item.children && depth < 2 && totalCount < maxItems) {
                            result += flattenTree(item.children, depth + 1);
                        }
                    } else {
                        result += `${indent}üìÑ ${item.name}\n`;
                        totalCount++;
                    }
                }
                return result;
            };
            
            return allFiles && allFiles.length > 0 ? flattenTree(allFiles) : '';
        }
        
        function toggleAI() {
            const panel = document.getElementById('ai-panel');
            panel.classList.toggle('hidden');
            
            if (!panel.classList.contains('hidden')) {
                document.getElementById('ai-input').focus();
            }
        }
        
        /**
         * Update a streaming message in real-time (Cursor-style)
         */
        function updateStreamingMessage(messageId, content) {
            const messageDiv = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageDiv) {
                const contentDiv = messageDiv.querySelector('.ai-message-content');
                if (contentDiv) {
                    contentDiv.textContent = content;
                    
                    // Auto-scroll to bottom
                    const messagesContainer = document.getElementById('ai-chat-messages');
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }
            }
        }
        
        async function sendAIMessage() {
            const input = document.getElementById('ai-input');
            const message = input.value.trim();
            
            if (!message || aiProcessing) return;
            
            // Get current file context
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            const documentContent = fileData ? fileData.model.getValue() : '';
            const fileName = fileData ? fileData.name : 'untitled';
            const language = fileData ? fileData.model.getLanguageId() : 'text';
            
            // Get selected text if any
            const selection = editor.getSelection();
            const selectedText = selection && !selection.isEmpty() ? 
                editor.getModel().getValueInRange(selection) : null;
            
            // Add user message to chat
            addChatMessage('user', message);
            
            // Clear input
            input.value = '';
            
            // Show thinking indicator  
            aiProcessing = true;
            document.getElementById('ai-send-btn').disabled = true;
            
            // Create streaming message placeholder
            const streamingMessageId = `streaming-${Date.now()}`;
            addChatMessage('assistant', '', { streaming: true, messageId: streamingMessageId });
            
            try {
                // Build file tree context (just structure, not content)
                const fileTreeContext = buildFileTreeContext();
                
                // Get selected model
                const selectedModel = document.getElementById('ai-model-select')?.value || 'claude-sonnet-4-5';
                
                // Use streaming for real-time response (Cursor-style)
                const requestBody = {
                    message,
                    documentContent,
                    selectedText,
                    fileName,
                    language,
                    fileTreeContext,
                    currentFolder: IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.'),
                    model: selectedModel,
                    conversationHistory: aiConversationHistory.slice(-12),
                    stream: true  // Enable streaming
                };
                
                // Handle streaming response with incremental file creation (look-ahead pattern)
                let fullResponse = '';
                let data = null;
                let pendingFile = null; // {path, content} - file being streamed
                const currentFolderForRealtime = IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
                let realtimeCreatedPaths = new Set(); // Track files created during streaming
                
                const response = await fetch('/api/ide/chat-v2', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                // Handle SSE streaming with tool feedback
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let toolFeedbackMessage = null;
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const event = JSON.parse(line.slice(6));
                                
                                // Handle different event types
                                if (event.type === 'error') {
                                    throw new Error(event.error);
                                }
                                
                                else if (event.type === 'iteration') {
                                    console.log(`[AI] Iteration ${event.iteration}/${event.max}`);
                                }
                                
                                else if (event.type === 'tools_start') {
                                    // Show tool feedback
                                    const toolNames = event.tools.map(t => t.name).join(', ');
                                    const feedbackText = `üîß Using ${event.tools.length} tool(s): ${toolNames}...`;
                                    toolFeedbackMessage = addChatMessage('system', feedbackText, { temp: true });
                                }
                                
                                else if (event.type === 'tool_start') {
                                    // Update feedback with current tool
                                    const icon = event.tool === 'read_file' ? 'üìñ' :
                                                event.tool === 'list_directory' ? 'üìÅ' :
                                                event.tool === 'grep_search' ? 'üîç' :
                                                event.tool === 'codebase_search' ? 'üß†' :
                                                event.tool === 'edit_file' ? '‚úèÔ∏è' :
                                                event.tool === 'create_file' ? 'üìù' :
                                                event.tool === 'run_terminal' ? '‚ö°' :
                                                event.tool === 'delete_file' ? 'üóëÔ∏è' : 'üîß';
                                    
                                    const argStr = event.args.file_path || event.args.directory_path || event.args.query || event.args.pattern || event.args.command || '';
                                    updateChatMessage(toolFeedbackMessage, `${icon} ${event.tool}: ${argStr}...`);
                                }
                                
                                else if (event.type === 'tool_complete') {
                                    console.log(`[AI] ${event.tool} complete`);
                                }
                                
                                else if (event.type === 'response_chunk') {
                                    // Remove tool feedback, start streaming response
                                    if (toolFeedbackMessage) {
                                        removeChatMessage(toolFeedbackMessage);
                                        toolFeedbackMessage = null;
                                    }
                                    fullResponse += event.chunk;
                                    updateStreamingMessage(streamingMessageId, fullResponse);
                                }
                                
                                else if (event.type === 'complete') {
                                        // Remove tool feedback if still showing
                                        if (toolFeedbackMessage) {
                                            removeChatMessage(toolFeedbackMessage);
                                            toolFeedbackMessage = null;
                                        }
                                        
                                        // Handle pending edits (show in queue, not auto-apply)
                                        if (event.pendingEdits && event.pendingEdits.length > 0) {
                                            console.log(`[AI] ${event.pendingEdits.length} edit(s) pending review`);
                                            for (const edit of event.pendingEdits) {
                                                // Add to edit queue for user review
                                                addToEditQueue(edit.file, edit.instructions, edit.edit);
                                            }
                                            
                                            // Show notification
                                            const editsMsg = event.pendingEdits.length === 1 ? '1 edit' : `${event.pendingEdits.length} edits`;
                                            addChatMessage('system', `‚úÖ ${editsMsg} added to queue for review`, {});
                                        }
                                        
                                        data = {
                                            success: true,
                                            response: event.fullResponse || fullResponse,
                                            tokensUsed: event.tokensUsed || 0,
                                            iterations: event.iterations || 0,
                                            model: selectedModel
                                        };
                                    }
                                } catch (e) {
                                    console.error('Failed to parse SSE event:', e);
                                }
                            }
                        }
                    }
                
                removeThinkingIndicator();
                
                // Function calling v2: tools executed server-side, response is clean
                // No need to parse for READ_FILE, GREP, etc. - already handled
                
                if (!data || !data.success) {
                    throw new Error(data?.error || 'AI request failed');
                }
                
                // Add final response to conversation history
                aiConversationHistory.push(
                    { role: 'user', content: message },
                    { role: 'assistant', content: data.response }
                );
                
                // Limit history size (keep last 24 messages = 12 exchanges)
                if (aiConversationHistory.length > 24) {
                    aiConversationHistory = aiConversationHistory.slice(-24);
                }
                
            } catch (error) {
                removeThinkingIndicator();
                addChatMessage('error', `Error: ${error.message}`);
                console.error('AI chat error:', error);
            } finally {
                aiProcessing = false;
                document.getElementById('ai-send-btn').disabled = false;
                input.focus();
            }
        }
        
        // REMOVED OLD TEXT-BASED TOOL HANDLING CODE (~650 lines)
        // Function calling v2 handles all tools server-side (READ_FILE, GREP, etc.)
        
        // addChatMessage defined below (keeping original)

        function addChatMessage(type, content, options = {}) {
            const messagesDiv = document.getElementById('ai-chat-messages');
            
            // Remove welcome message if present
            const welcome = messagesDiv.querySelector('[style*="text-align: center"]');
            if (welcome) {
                welcome.remove();
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `ai-message ${type}`;
            
            // Add message ID for streaming updates
            if (options.messageId) {
                messageDiv.dataset.messageId = options.messageId;
            }
            
            const headerText = type === 'user' ? 'You' : 
                              type === 'assistant' ? (options.streaming ? 'AI Assistant (streaming...)' : 'AI Assistant') : 
                              'Error';
            
            let html = `
                <div class="ai-message-header">${headerText}</div>
                <div class="ai-message-content">${options.streaming ? '‚ñã' : escapeHtml(content)}</div>
            `;
            
            // Add action buttons for assistant messages
            if (type === 'assistant' && options.canApply) {
                html += `
                    <div class="ai-message-actions">
                        <button class="btn btn-secondary" onclick="applyAISuggestion(this)" style="padding: 4px 12px; font-size: 11px;">
                            ‚úì Apply
                        </button>
                        <button class="btn btn-secondary" onclick="copyAISuggestion(this)" style="padding: 4px 12px; font-size: 11px;">
                            üìã Copy
                        </button>
                    </div>
                `;
            }
            
            messageDiv.innerHTML = html;
            
            // Store response content for apply button
            if (options.canApply) {
                messageDiv.dataset.response = content;
                
                // Store original text for diff view
                const selection = editor.getSelection();
                const model = editor.getModel();
                if (selection && !selection.isEmpty()) {
                    messageDiv.dataset.originalText = model.getValueInRange(selection);
                } else if (model) {
                    messageDiv.dataset.originalText = model.getValue();
                }
            }
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            return messageDiv; // Return for later updates/removal
        }
        
        function updateChatMessage(messageElement, newContent) {
            if (!messageElement) return;
            const contentDiv = messageElement.querySelector('.ai-message-content');
            if (contentDiv) {
                contentDiv.textContent = newContent;
            }
        }
        
        function removeChatMessage(messageElement) {
            if (messageElement && messageElement.parentNode) {
                messageElement.remove();
            }
        }
        
        function addThinkingIndicator() {
            const messagesDiv = document.getElementById('ai-chat-messages');
            const thinking = document.createElement('div');
            thinking.id = 'ai-thinking';
            thinking.className = 'ai-thinking';
            thinking.innerHTML = `
                <div class="ai-thinking-spinner"></div>
                <span>AI is thinking...</span>
            `;
            messagesDiv.appendChild(thinking);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        function removeThinkingIndicator() {
            const thinking = document.getElementById('ai-thinking');
            if (thinking) {
                thinking.remove();
            }
        }
        
        async function aiQuickAction(action) {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) {
                showToast('No file open', 'error');
                return;
            }
            
            // Get selected text if any
            const selection = editor.getSelection();
            const selectedText = selection && !selection.isEmpty() ? 
                editor.getModel().getValueInRange(selection) : null;
            
            const actionMap = {
                'improve': selectedText ? 
                    'Improve this selected text - make it clearer and more professional' : 
                    'Review this document and suggest improvements',
                'summarize': 'Provide a concise summary of this document',
                'grammar': selectedText ? 
                    'Check grammar and fix any issues in the selected text' : 
                    'Check grammar and fix any issues in this document',
                'examples': 'Add relevant examples to illustrate the concepts'
            };
            
            const message = actionMap[action] || action;
            
            // Set the message and send
            document.getElementById('ai-input').value = message;
            await sendAIMessage();
        }
        
        function applyAISuggestion(button) {
            const messageDiv = button.closest('.ai-message');
            const suggestion = messageDiv.dataset.response;
            const originalText = messageDiv.dataset.originalText;
            
            if (!suggestion || !editor) return;
            
            // Get current selection or full document
            const selection = editor.getSelection();
            const model = editor.getModel();
            const currentText = selection && !selection.isEmpty() ? 
                model.getValueInRange(selection) : model.getValue();
            
            // Show diff preview before applying
            if (suggestion.length > 100 || currentText.length > 100) {
                showDiffPreview(currentText, suggestion, () => {
                    applyEdit(selection, suggestion);
                });
            } else {
                // For small changes, apply directly with confirmation
                if (confirm('Apply AI suggestion?')) {
                    applyEdit(selection, suggestion);
                }
            }
        }
        
        function applyEdit(selection, newText) {
            if (selection && !selection.isEmpty()) {
                // Replace selection
                editor.executeEdits('ai-edit', [{
                    range: selection,
                    text: newText
                }]);
                showToast('Applied AI suggestion to selection', 'success');
            } else {
                // Replace entire document
                editor.setValue(newText);
                showToast('Document updated with AI suggestion', 'success');
            }
            
            // Mark as dirty
            if (activeFile) {
                const fileData = openFiles.get(activeFile);
                if (fileData) {
                    fileData.dirty = true;
                    updateTabDirtyState(activeFile, true);
                    updateSaveButtons();
                }
            }
        }
        
        function showDiffPreview(original, modified, onAccept) {
            // Use inline diff viewer instead of modal (Cursor-style UX)
            const fileName = activeFile ? openFiles.get(activeFile)?.name : 'Changes';
            showInlineDiff(original, modified, fileName, onAccept);
        }
        
        function copyAISuggestion(button) {
            const messageDiv = button.closest('.ai-message');
            const suggestion = messageDiv.dataset.response;
            
            if (suggestion) {
                copyToClipboard(suggestion);
                showToast('Copied AI suggestion', 'success');
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function clearAIChat() {
            const messagesDiv = document.getElementById('ai-chat-messages');
            messagesDiv.innerHTML = `
                <div style="padding: 20px; text-align: center; color: var(--text-secondary); font-size: 12px;">
                    üëã Chat cleared. Ask me anything!
                </div>
            `;
            aiConversationHistory = [];
        }

        // ============================================================================
        // EXPORT & DOWNLOAD
        // ============================================================================
        
        function downloadCurrentFile() {
            if (!activeFile) {
                showToast('No file open', 'error');
                return;
            }
            
            const fileData = openFiles.get(activeFile);
            if (!fileData) {
                showToast('File data not found', 'error');
                return;
            }
            
            try {
            const content = fileData.model.getValue();
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = fileData.name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast(`Downloaded: ${fileData.name}`, 'success');
            } catch (error) {
                console.error('Download error:', error);
                showToast('Failed to download file: ' + error.message, 'error');
            }
        }
        
        async function downloadAllFiles() {
            showToast('Preparing download...', 'success');
            
            // For a simple implementation without JSZip, we'll download files one by one
            // Or offer to download a bundle via API
            
            try {
                const response = await fetch(`/api/compiled-docs/${runName}/${systemId}/download`);
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${systemId}-docs.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showToast('Downloaded all files', 'success');
                } else {
                    throw new Error('Download failed');
                }
            } catch (error) {
                console.error('Download failed:', error);
                showToast('Download failed. Downloading current file only.', 'error');
                downloadCurrentFile();
            }
        }
        
        function exportMarkdownToPDF() {
            if (!activeFile) {
                showToast('No file open', 'error');
                return;
            }
            
            const fileData = openFiles.get(activeFile);
            if (!fileData || fileData.model.getLanguageId() !== 'markdown') {
                showToast('Only markdown files can be exported to PDF', 'error');
                return;
            }
            
            try {
            // Use browser print for PDF export
            const content = fileData.model.getValue();
            const html = marked.parse(content);
            
            const printWindow = window.open('', '_blank');
                if (!printWindow) {
                    showToast('Pop-up blocked. Please allow pop-ups to export to PDF.', 'error');
                    return;
                }
                
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${fileData.name}</title>
                    <style>
                        body {
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                            max-width: 800px;
                            margin: 40px auto;
                            padding: 0 20px;
                            line-height: 1.6;
                            color: #333;
                        }
                        h1, h2, h3 { margin-top: 24px; margin-bottom: 12px; }
                        code {
                            background: #f5f5f5;
                            padding: 2px 6px;
                            border-radius: 3px;
                            font-family: 'Monaco', 'Courier New', monospace;
                        }
                        pre {
                            background: #f5f5f5;
                            padding: 16px;
                            border-radius: 6px;
                            overflow-x: auto;
                        }
                        pre code {
                            background: none;
                            padding: 0;
                        }
                    </style>
                </head>
                <body>
                    ${html}
                </body>
                </html>
            `);
            printWindow.document.close();
            
            setTimeout(() => {
                printWindow.print();
            }, 250);
                
                showToast('Opening print dialog...', 'success');
            } catch (error) {
                console.error('PDF export error:', error);
                showToast('Failed to export to PDF: ' + error.message, 'error');
            }
        }
        
        function exportMarkdownToHTML() {
            if (!activeFile) {
                showToast('No file open', 'error');
                return;
            }
            
            const fileData = openFiles.get(activeFile);
            if (!fileData || fileData.model.getLanguageId() !== 'markdown') {
                showToast('Only markdown files can be exported to HTML', 'error');
                return;
            }
            
            try {
            const content = fileData.model.getValue();
            const html = marked.parse(content);
            
            const fullHTML = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${fileData.name}</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            max-width: 800px;
            margin: 40px auto;
            padding: 0 20px;
            line-height: 1.6;
            color: #333;
        }
        h1, h2, h3 { margin-top: 24px; margin-bottom: 12px; color: #1a1a1a; }
        h1 { font-size: 32px; }
        h2 { font-size: 24px; }
        h3 { font-size: 20px; }
        p { margin-bottom: 12px; }
        code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }
        pre {
            background: #f5f5f5;
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 12px 0;
        }
        pre code {
            background: none;
            padding: 0;
        }
        a { color: #0066cc; text-decoration: none; }
        a:hover { text-decoration: underline; }
        blockquote {
            border-left: 4px solid #ddd;
            margin: 12px 0;
            padding-left: 16px;
            color: #666;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 12px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
        }
        th {
            background: #f5f5f5;
            font-weight: 600;
        }
    </style>
</head>
<body>
${html}
</body>
</html>`;
            
            const blob = new Blob([fullHTML], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = fileData.name.replace(/\.md$/, '.html');
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('Exported to HTML', 'success');
            } catch (error) {
                console.error('HTML export error:', error);
                showToast('Failed to export to HTML: ' + error.message, 'error');
            }
        }

        // ============================================================================
        // BEFORE UNLOAD WARNING
        // ============================================================================
        
        window.addEventListener('beforeunload', (e) => {
            const hasDirty = Array.from(openFiles.values()).some(f => f.dirty);
            if (hasDirty) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
                return e.returnValue;
            }
        });

        // ============================================================================
        // PANEL RESIZING
        // ============================================================================
        
        function initPanelResizing() {
            const handles = document.querySelectorAll('.resize-handle-vertical');
            
            console.log('Initializing panel resizing, found', handles.length, 'handles');
            
            handles.forEach((handle, index) => {
                console.log('Setting up resize handle', index, 'for', handle.dataset.target);
                
                let isResizing = false;
                let startX = 0;
                let startWidth = 0;
                let targetPanel = null;
                let targetId = null;
                
                const handleMouseDown = (e) => {
                    console.log('Resize mousedown on', handle.dataset.target);
                    isResizing = true;
                    startX = e.clientX;
                    targetId = handle.dataset.target;
                    targetPanel = document.getElementById(targetId);
                    
                    if (targetPanel) {
                        startWidth = targetPanel.offsetWidth;
                        handle.classList.add('active');
                        document.body.style.cursor = 'col-resize';
                        document.body.style.userSelect = 'none';
                        console.log('Started resizing', targetId, 'from width', startWidth);
                        
                        // Add move and up listeners
                        document.addEventListener('mousemove', handleMouseMove);
                        document.addEventListener('mouseup', handleMouseUp);
                    } else {
                        console.error('Target panel not found:', targetId);
                    }
                    
                    e.preventDefault();
                    e.stopPropagation();
                };
                
                const handleMouseMove = (e) => {
                    if (!isResizing || !targetPanel) return;
                    
                    e.preventDefault();
                    e.stopPropagation();
                    
                    let newWidth;
                    
                    if (targetId === 'sidebar') {
                        // Sidebar: resize from left to right
                        const delta = e.clientX - startX;
                        newWidth = startWidth + delta;
                    } else {
                        // Preview/AI panels: resize from right to left
                        const delta = startX - e.clientX;
                        newWidth = startWidth + delta;
                    }
                    
                    // Apply constraints
                    const minWidth = parseInt(getComputedStyle(targetPanel).minWidth) || 200;
                    const maxWidth = parseInt(getComputedStyle(targetPanel).maxWidth) || 800;
                    
                    // Also ensure we don't exceed 40% of viewport width
                    const maxViewportWidth = window.innerWidth * 0.4;
                    newWidth = Math.max(minWidth, Math.min(maxWidth, maxViewportWidth, newWidth));
                    
                    targetPanel.style.width = newWidth + 'px';
                    targetPanel.style.flexGrow = '0';
                    targetPanel.style.flexShrink = '0';
                    targetPanel.style.flexBasis = 'auto';
                };
                
                const handleMouseUp = (e) => {
                    if (isResizing && targetPanel) {
                        const finalWidth = targetPanel.offsetWidth;
                        
                        savePanelSize(targetId, finalWidth);
                        console.log('Resize complete:', targetId, 'final width:', finalWidth);
                        
                        isResizing = false;
                        handle.classList.remove('active');
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                        
                        // Remove event listeners
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                        
                        targetPanel = null;
                        targetId = null;
                        
                        e.preventDefault();
                        e.stopPropagation();
                    }
                };
                
                // Attach initial mousedown listener
                handle.addEventListener('mousedown', handleMouseDown);
            });
        }
        
        function savePanelSize(panelId, width) {
            try {
                const key = `cosmo-panel-size-${panelId}`;
                localStorage.setItem(key, width.toString());
            } catch (e) {
                console.error('Failed to save panel size:', e);
            }
        }
        
        function restorePanelSizes() {
            const panels = ['sidebar', 'preview-pane', 'ai-panel'];
            
            panels.forEach(panelId => {
                try {
                    const key = `cosmo-panel-size-${panelId}`;
                    const saved = localStorage.getItem(key);
                    if (saved) {
                        const panel = document.getElementById(panelId);
                        if (panel) {
                            panel.style.width = saved + 'px';
                        }
                    }
                } catch (e) {
                    console.error(`Failed to restore ${panelId} size:`, e);
                }
            });
        }

        // ============================================================================
        // FILE CREATION (AI-Triggered or Manual)
        // ============================================================================
        
        // ============================================================================
        // INLINE DIFF VIEWER - Monaco DiffEditor integration
        // ============================================================================
        
        let diffEditor = null;
        let currentDiffCallback = null;
        let currentDiffOriginal = null;
        let currentDiffModified = null;
        
        function showInlineDiff(original, modified, fileName, onAccept) {
            // Store callback and content
            currentDiffCallback = onAccept;
            currentDiffOriginal = original;
            currentDiffModified = modified;
            
            // Hide normal editor, show diff editor
            document.getElementById('monaco-editor').classList.add('hidden');
            document.getElementById('monaco-diff-editor').classList.remove('hidden');
            document.getElementById('diff-action-bar').classList.remove('hidden');
            document.getElementById('diff-file-name').textContent = fileName || 'Changes';
            
            // Create diff editor if it doesn't exist
            const diffContainer = document.getElementById('monaco-diff-editor');
            
            if (!diffEditor) {
                diffEditor = monaco.editor.createDiffEditor(diffContainer, {
                    enableSplitViewResizing: true,
                    renderSideBySide: true,
                    readOnly: false,
                    originalEditable: false,
                    automaticLayout: true,
                    theme: settings.theme || 'vs-dark',
                    fontSize: settings.fontSize || 14,
                    minimap: { enabled: settings.minimap !== false }
                });
            }
            
            // Detect language from filename or use plaintext
            const language = fileName ? detectLanguage(fileName) : 'plaintext';
            
            // Create models
            const originalModel = monaco.editor.createModel(original, language);
            const modifiedModel = monaco.editor.createModel(modified, language);
            
            // Set models in diff editor
            diffEditor.setModel({
                original: originalModel,
                modified: modifiedModel
            });
            
            // Focus the diff editor
            diffEditor.focus();
        }
        
        function acceptCurrentDiff() {
            if (currentDiffCallback) {
                currentDiffCallback();
                currentDiffCallback = null;
            }
            exitDiffMode();
        }
        
        function rejectCurrentDiff() {
            currentDiffCallback = null;
            exitDiffMode();
            showToast('Changes rejected', 'success');
        }
        
        function exitDiffMode() {
            // Dispose diff editor models
            if (diffEditor) {
                const model = diffEditor.getModel();
                if (model) {
                    model.original?.dispose();
                    model.modified?.dispose();
                }
            }
            
            // Hide diff editor, show normal editor
            document.getElementById('monaco-diff-editor').classList.add('hidden');
            document.getElementById('monaco-editor').classList.remove('hidden');
            document.getElementById('diff-action-bar').classList.add('hidden');
            
            // Clear state
            currentDiffCallback = null;
            currentDiffOriginal = null;
            currentDiffModified = null;
            
            // Refocus normal editor
            if (editor) {
                editor.focus();
            }
        }
        
        // ============================================================================
        // CSV TABLE BUILDER
        // ============================================================================
        
        function showCSVBuilder() {
            document.getElementById('csv-builder').classList.remove('hidden');
            document.getElementById('overlay').classList.remove('hidden');
            
            // Generate default grid
            generateCSVGrid();
        }
        
        function closeCSVBuilder() {
            document.getElementById('csv-builder').classList.add('hidden');
            document.getElementById('overlay').classList.add('hidden');
        }
        
        function generateCSVGrid() {
            const rows = parseInt(document.getElementById('csv-rows').value) || 5;
            const cols = parseInt(document.getElementById('csv-cols').value) || 4;
            const gridDiv = document.getElementById('csv-grid');
            
            let html = '<table style="width: 100%; border-collapse: collapse;">';
            
            // Header row
            html += '<tr style="background: var(--bg-secondary);">';
            for (let c = 0; c < cols; c++) {
                html += `<th style="border: 1px solid var(--border-color); padding: 8px;">
                    <input type="text" class="csv-cell" data-row="0" data-col="${c}" 
                           placeholder="Column ${c + 1}" 
                           style="width: 100%; background: transparent; border: none; color: var(--text-primary); font-weight: 600;">
                </th>`;
            }
            html += '</tr>';
            
            // Data rows
            for (let r = 1; r <= rows; r++) {
                html += '<tr>';
                for (let c = 0; c < cols; c++) {
                    html += `<td style="border: 1px solid var(--border-color); padding: 4px;">
                        <input type="text" class="csv-cell" data-row="${r}" data-col="${c}" 
                               placeholder="" 
                               style="width: 100%; background: transparent; border: none; color: var(--text-primary);">
                    </td>`;
                }
                html += '</tr>';
            }
            html += '</table>';
            
            gridDiv.innerHTML = html;
        }
        
        async function createCSVFile() {
            const fileName = document.getElementById('csv-filename').value || 'data.csv';
            const cells = document.querySelectorAll('#csv-grid .csv-cell');
            
            if (cells.length === 0) {
                showToast('Generate a grid first', 'error');
                return;
            }
            
            // Build CSV data structure
            const data = {};
            cells.forEach(cell => {
                const row = cell.dataset.row;
                const col = cell.dataset.col;
                if (!data[row]) data[row] = {};
                data[row][col] = cell.value || '';
            });
            
            // Convert to CSV text
            const rows = Object.keys(data).sort((a, b) => parseInt(a) - parseInt(b));
            const csvLines = rows.map(r => {
                const cols = Object.keys(data[r]).sort((a, b) => parseInt(a) - parseInt(b));
                return cols.map(c => {
                    const value = data[r][c];
                    // Escape quotes and wrap in quotes if contains comma, quote, or newline
                    if (value.includes(',') || value.includes('"') || value.includes('\n')) {
                        return `"${value.replace(/"/g, '""')}"`;
                    }
                    return value;
                }).join(',');
            });
            
            const csvContent = csvLines.join('\n');
            
            // Create file
            const currentFolder = IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
            const fullPath = fileName.startsWith('/') ? fileName : `${currentFolder}/${fileName}`;
            
            try {
                await createFileOrFolder(fullPath, csvContent);
                showToast(`Created ${fileName}`, 'success');
                closeCSVBuilder();
            } catch (error) {
                showToast(`Failed to create CSV: ${error.message}`, 'error');
            }
        }
        
        // ============================================================================
        // CHAT HISTORY UI FUNCTIONS
        // ============================================================================
        
        function toggleChatHistory() {
            const panel = document.getElementById('chat-history-panel');
            panel.classList.toggle('hidden');
            
            if (!panel.classList.contains('hidden')) {
                updateChatHistoryUI();
            }
        }
        
        function startNewChat() {
            // Clear current conversation
            aiConversationHistory = [];
            chatHistory.startNewConversation();
            
            // Clear chat UI
            const messagesDiv = document.getElementById('ai-chat-messages');
            messagesDiv.innerHTML = `
                <div style="padding: 20px; text-align: center; color: var(--text-secondary); font-size: 12px;">
                    üëã New conversation started!<br>
                    Ask me to help with your documentation!
                </div>
            `;
            
            showToast('Started new conversation', 'success');
        }
        
        function updateChatHistoryUI() {
            const conversations = chatHistory.getRecentConversations();
            const listEl = document.getElementById('chat-history-list');
            
            if (conversations.length === 0) {
                listEl.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: var(--text-secondary); font-size: 12px;">
                        No chat history for this folder
                    </div>
                `;
                return;
            }
            
            listEl.innerHTML = conversations.map(conv => {
                const date = new Date(conv.timestamp);
                const timeStr = date.toLocaleString();
                const messageCount = conv.messages.length;
                const preview = conv.messages[0]?.content.substring(0, 50) || 'Empty conversation';
                
                return `
                    <div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 4px; padding: 10px; margin-bottom: 6px; cursor: pointer; transition: all 0.2s;"
                         onclick="loadChatConversation('${conv.id}')"
                         onmouseover="this.style.background='var(--bg-hover)'; this.style.borderColor='var(--accent-primary)'"
                         onmouseout="this.style.background='var(--bg-secondary)'; this.style.borderColor='var(--border-color)'">
                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 4px;">${timeStr}</div>
                        <div style="font-size: 12px; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(preview)}...</div>
                        <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">${messageCount} messages</div>
                    </div>
                `;
            }).join('');
        }
        
        function loadChatConversation(conversationId) {
            const conversation = chatHistory.loadConversation(conversationId);
            if (!conversation) {
                showToast('Conversation not found', 'error');
                return;
            }
            
            // Set as current conversation
            chatHistory.currentConversationId = conversationId;
            
            // Load messages into conversation history
            aiConversationHistory = conversation.messages.map(m => ({
                role: m.role,
                content: m.content
            }));
            
            // Clear and rebuild chat UI
            const messagesDiv = document.getElementById('ai-chat-messages');
            messagesDiv.innerHTML = '';
            
            conversation.messages.forEach(msg => {
                addChatMessage(msg.role, msg.content, {});
            });
            
            // Close history panel
            document.getElementById('chat-history-panel').classList.add('hidden');
            
            showToast(`Loaded conversation from ${new Date(conversation.timestamp).toLocaleString()}`, 'success');
        }
        
        // ============================================================================
        // CONTEXT MENU - Cursor-style right-click options
        // ============================================================================
        
        function showContextMenu(x, y, filePath) {
            const menu = document.getElementById('context-menu');
            const fileData = openFiles.get(filePath);
            const fileName = filePath.split('/').pop();
            
            const menuItems = [
                { icon: 'üëÅÔ∏è', label: 'Open in Browser', action: () => openInBrowser(filePath) },
                { icon: 'üìÅ', label: 'Reveal in Finder', action: () => revealInFinder(filePath) },
                { separator: true },
                { icon: 'üìã', label: 'Copy Path', action: () => copyFilePath(filePath) },
                { icon: 'üìã', label: 'Copy Relative Path', action: () => copyRelativePath(filePath) },
                { separator: true },
                { icon: '‚úèÔ∏è', label: 'Rename...', action: () => renameFileDialog(filePath) },
                { icon: 'üóëÔ∏è', label: 'Delete...', action: () => deleteFileDialog(filePath), danger: true },
                { separator: true },
                { icon: 'üìå', label: fileData && pinnedTabs.has(filePath) ? 'Unpin Tab' : 'Pin Tab', action: () => togglePinTab(filePath) },
                { icon: 'üíæ', label: 'Save', action: () => saveFile(filePath), disabled: !fileData || !fileData.dirty },
                { icon: 'üîÑ', label: 'Close Tab', action: () => closeFile(filePath), disabled: !fileData }
            ];
            
            menu.innerHTML = menuItems.map(item => {
                if (item.separator) {
                    return '<div class="context-menu-separator"></div>';
                }
                const disabledClass = item.disabled ? ' disabled' : '';
                const dangerClass = item.danger ? ' danger' : '';
                return `
                    <div class="context-menu-item${disabledClass}${dangerClass}" onclick="if(!this.classList.contains('disabled')){${item.action.toString().match(/=>\s*(.+)/)?.[1] || `(${item.action.toString()})()`}; hideContextMenu();}">
                        <span>${item.icon}</span>
                        <span>${item.label}</span>
                    </div>
                `;
            }).join('');
            
            // Position menu
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
            menu.classList.remove('hidden');
            
            // Store current file for action callbacks
            window.contextMenuTarget = filePath;
        }
        
        function hideContextMenu() {
            document.getElementById('context-menu').classList.add('hidden');
            window.contextMenuTarget = null;
        }
        
        async function openInBrowser(filePath) {
            const url = `/api/serve-file?path=${encodeURIComponent(filePath)}`;
            window.open(url, '_blank');
            showToast('Opened in browser', 'success');
        }
        
        async function revealInFinder(filePath) {
            try {
                const response = await fetch('/api/reveal-in-finder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: filePath })
                });
                
                const data = await response.json();
                if (data.success) {
                    showToast('Opened in Finder', 'success');
                } else {
                    showToast(data.error || 'Failed to reveal file', 'error');
                }
            } catch (error) {
                showToast('Failed to reveal file', 'error');
            }
        }
        
        function copyFilePath(filePath) {
            copyToClipboard(filePath);
            showToast('Copied full path', 'success');
        }
        
        function copyRelativePath(filePath) {
            const currentFolder = IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
            let relative = filePath.replace(currentFolder + '/', '');
            if (relative === filePath) relative = './' + filePath.split('/').pop();
            copyToClipboard(relative);
            showToast('Copied relative path', 'success');
        }
        
        function togglePinTab(filePath) {
            if (pinnedTabs.has(filePath)) {
                pinnedTabs.remove(filePath);
                showToast('Tab unpinned', 'success');
            } else {
                pinnedTabs.add(filePath);
                showToast('Tab pinned', 'success');
            }
            renderTabs();
        }
        
        // Close all modals and context menu on click outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.context-menu')) {
                hideContextMenu();
            }
        });
        
        /**
         * User-triggered: Create new file
         * Prompts for filename and creates in current folder
         */
        async function createNewFile() {
            const currentFolder = IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
            const fileName = prompt('Enter new file name:', 'untitled.md');
            
            if (!fileName) return;
            
            // Build full path
            const fullPath = fileName.startsWith('/') ? fileName : `${currentFolder}/${fileName}`;
            
            try {
                await createFileOrFolder(fullPath, '');
                showToast(`Created ${fileName}`, 'success');
            } catch (error) {
                showToast(`Failed to create file: ${error.message}`, 'error');
            }
        }
        
        /**
         * User-triggered: Create new folder
         * Prompts for folder name and creates in current folder
         */
        async function createNewFolder() {
            const currentFolder = IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
            const folderName = prompt('Enter new folder name:', 'new-folder');
            
            if (!folderName) return;
            
            // Build full path (ensure it ends with /)
            const fullPath = folderName.startsWith('/') ? folderName : `${currentFolder}/${folderName}`;
            const normalizedPath = fullPath.endsWith('/') ? fullPath : `${fullPath}/`;
            
            try {
                await createFileOrFolder(normalizedPath, '');
                showToast(`Created folder ${folderName}`, 'success');
            } catch (error) {
                showToast(`Failed to create folder: ${error.message}`, 'error');
            }
        }
        
        async function createFileOrFolder(filePath, content = '') {
            try {
                // Detect if it's a folder (ends with / or has no extension and no content)
                const isFolder = filePath.endsWith('/') || (!filePath.includes('.') && !content);
                
                if (isFolder) {
                    // Create folder (just write a .gitkeep file in it)
                    const folderPath = filePath.replace(/\/$/, '');
                    const keepFile = `${folderPath}/.gitkeep`;
                    const data = await FileAPI.writeFile(keepFile, '');
                    
                    if (!data.success) {
                        throw new Error(data.error || 'Failed to create folder');
                    }
                    
                    console.log('[FOLDER CREATE] Success:', folderPath);
                    showToast(`Created folder: ${folderPath.split('/').pop()}`, 'success');
                } else {
                    // Create file
                    const data = await FileAPI.writeFile(filePath, content);
                    
                    if (!data.success) {
                        throw new Error(data.error || 'Failed to create file');
                    }
                    
                    console.log('[FILE CREATE] Success:', filePath);
                    showToast(`Created: ${filePath.split('/').pop()}`, 'success');
                }
                
                // Reload file tree
                await loadFileTree();
                
                // Open the file if it's not a folder
                if (!isFolder) {
                    setTimeout(() => {
                        const fileName = filePath.split('/').pop();
                        openFile(filePath, fileName);
                    }, 500);
                }
                
                return true;
            } catch (error) {
                console.error('[CREATE] Error:', error);
                showToast('Failed to create: ' + error.message, 'error');
                return false;
            }
        }

        // ============================================================================
        // FOLDER BROWSER
        // ============================================================================
        
        // Default browse path - user can navigate anywhere from here
        // Detect OS from user agent (rough heuristic for default path)
        const isWindows = navigator.userAgent.toLowerCase().includes('windows');
        let currentBrowsePath = isWindows ? 'C:\\Users' : '/';
        
        async function showFolderBrowser() {
            document.getElementById('folder-browser').classList.remove('hidden');
            document.getElementById('overlay').classList.remove('hidden');
            await browseFolders(currentBrowsePath);
        }
        
        function closeFolderBrowser() {
            document.getElementById('folder-browser').classList.add('hidden');
            document.getElementById('overlay').classList.add('hidden');
        }
        
        async function browseFolders(folderPath) {
            currentBrowsePath = folderPath;
            document.getElementById('current-path-display').textContent = folderPath;
            
            const folderList = document.getElementById('folder-list');
            folderList.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">Loading...</div>';
            
            try {
                const response = await fetch(`/api/folder/browse?path=${encodeURIComponent(folderPath)}`);
                const data = await response.json();
                
                if (!data.success) {
                    folderList.innerHTML = `<div style="text-align: center; color: var(--error-color); padding: 20px;">${data.error}</div>`;
                    return;
                }
                
                const folders = data.files.filter(item => item.isDirectory);
                
                if (folders.length === 0) {
                    folderList.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No subfolders</div>';
                    return;
                }
                
                folderList.innerHTML = folders.map(folder => `
                    <div onclick="browseFolders('${folder.path.replace(/'/g, "\\'")}');" 
                         style="padding: 10px 12px; cursor: pointer; border-radius: 4px; transition: background 0.15s; display: flex; align-items: center; gap: 8px; margin-bottom: 4px;"
                         onmouseover="this.style.background='var(--bg-tertiary)'" 
                         onmouseout="this.style.background='transparent'">
                        <span style="font-size: 18px;">üìÅ</span>
                        <span style="font-size: 13px;">${folder.name}</span>
                    </div>
                `).join('');
                
            } catch (error) {
                folderList.innerHTML = `<div style="text-align: center; color: var(--error-color); padding: 20px;">Error: ${error.message}</div>`;
            }
        }
        
        async function navigateUp() {
            const parentPath = currentBrowsePath.substring(0, currentBrowsePath.lastIndexOf('/')) || '/';
            await browseFolders(parentPath);
        }
        
        async function navigateToHome() {
            // Navigate to common user directories based on OS
            const homePath = isWindows ? 'C:\\Users' : '/Users';
            await browseFolders(homePath);
        }
        
        function selectCurrentFolder() {
            if (!currentBrowsePath) {
                showToast('Please select a folder', 'error');
                return;
            }
            closeFolderBrowser();
            window.location.href = `/?path=${encodeURIComponent(currentBrowsePath)}`;
        }
        
        function goToManualPath() {
            const input = document.getElementById('manual-path-input');
            const path = input.value.trim();
            if (!path) {
                showToast('Please enter a path', 'error');
                return;
            }
            // Navigate to that path in the browser
            browseFolders(path);
        }

        // ============================================================================
        // COMMAND REGISTRY INITIALIZATION
        // ============================================================================
        
        function initializeCommands() {
            commands = [
                { id: 'file.save', label: 'Save File', action: saveCurrentFile, keys: 'Cmd+S' },
                { id: 'file.saveAll', label: 'Save All Files', action: saveAllFiles, keys: 'Cmd+Shift+S' },
                { id: 'file.close', label: 'Close File', action: () => { if (activeFile) closeTab(activeFile); }, keys: 'Cmd+W' },
                { id: 'file.closeOthers', label: 'Close Other Tabs', action: closeOtherTabs },
                { id: 'file.closeUnpinned', label: 'Close Unpinned Tabs', action: closeUnpinnedTabs },
                { id: 'file.download', label: 'Download Current File', action: downloadCurrentFile },
                { id: 'file.downloadAll', label: 'Download All Files', action: downloadAllFiles },
                { id: 'file.recent', label: 'Recent Files', action: showRecentFiles, keys: 'Cmd+E' },
                { id: 'file.new', label: 'New File', action: showNewFileDialog },
                { id: 'file.rename', label: 'Rename File', action: () => { if (activeFile) renameFileDialog(activeFile); } },
                { id: 'file.delete', label: 'Delete File', action: () => { if (activeFile) deleteFileDialog(activeFile); } },
                { id: 'export.html', label: 'Export Markdown to HTML', action: exportMarkdownToHTML },
                { id: 'export.pdf', label: 'Export Markdown to PDF', action: exportMarkdownToPDF },
                { id: 'view.toggleSidebar', label: 'Toggle Sidebar', action: toggleSidebar, keys: 'Cmd+B' },
                { id: 'view.togglePreview', label: 'Toggle Preview (MD/HTML/JSON/CSS/SVG/Images)', action: togglePreview, keys: 'Cmd+K V' },
                { id: 'view.settings', label: 'Open Settings', action: toggleSettings, keys: 'Cmd+,' },
                { id: 'editor.action.formatDocument', label: 'Format Document', action: () => editor && editor.getAction('editor.action.formatDocument').run() },
                { id: 'editor.find', label: 'Find', action: toggleSearch, keys: 'Cmd+F' },
                { id: 'editor.findInFiles', label: 'Find in All Files', action: showFindInFiles, keys: 'Cmd+Shift+F' },
                { id: 'tab.pin', label: 'Pin/Unpin Current Tab', action: () => { if (activeFile) togglePinTab(activeFile); } },
                { id: 'ai.toggle', label: 'Toggle AI Assistant', action: toggleAI, keys: 'Cmd+K A' },
                { id: 'ai.improve', label: 'AI: Improve Selection', action: () => aiQuickAction('improve') },
                { id: 'ai.grammar', label: 'AI: Check Grammar', action: () => aiQuickAction('grammar') },
                { id: 'ai.summarize', label: 'AI: Summarize', action: () => aiQuickAction('summarize') },
                { id: 'help.keyboard', label: 'Keyboard Shortcuts', action: toggleKeyboardHelp, keys: '?' },
            ];
        }

        // ============================================================================
        // INITIALIZATION - Setup auto-save on load
        // ============================================================================
        
        initializeCommands();
        setupAutoSave();
        
        // Initialize panel resizing after DOM loaded
        document.addEventListener('DOMContentLoaded', () => {
            initPanelResizing();
            restorePanelSizes();
        });
    </script>
</body>
</html>

