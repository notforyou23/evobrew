<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Standalone Documentation IDE</title>
    
    <!-- External Dependencies -->
    <!-- NOTE: This page has a large inline stylesheet below. We intentionally do NOT load `css/styles.css`
         because it contains an older layout (grid-based) that can conflict with this IDE layout and break scrolling. -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.7/dist/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/github-dark.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #252526;
            --bg-tertiary: #2d2d30;
            --border-color: #3e3e42;
            --text-primary: #cccccc;
            --text-secondary: #969696;
            --text-active: #ffffff;
            --accent-primary: #007acc;
            --accent-hover: #1177bb;
            --success-color: #10b981;
            --error-color: #ef4444;
            --warning-color: #f0883e;
        }

        /* Embedded mode - hide redundant tabs when in Unified iframe */
        body.embedded .tab-btn[data-tab="readme"],
        body.embedded .tab-btn[data-tab="query"],
        body.embedded .tab-btn[data-tab="explore"] {
            display: none !important;
        }

        /* In embedded mode, make Agent IDE tab not look like a tab (it's the only one) */
        body.embedded .tab-btn[data-tab="files"] {
            background: transparent;
            border: none;
            cursor: default;
            font-weight: 600;
        }

        body.embedded .tab-btn[data-tab="files"]:hover {
            background: transparent;
        }

        /* Light theme - activated via ?theme=light URL param */
        body.light-theme {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #f1f3f5;
            --border-color: #dee2e6;
            --text-primary: #212529;
            --text-secondary: #495057;
            --text-active: #000000;
            --accent-primary: #228be6;
            --accent-hover: #1971c2;
            --success-color: #40c057;
            --error-color: #fa5252;
            --warning-color: #fab005;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            height: 100dvh;
            width: 100vw;
            overflow: hidden;
            background: var(--bg-primary);
            color: var(--text-primary);
            -webkit-font-smoothing: antialiased;
            padding-top: env(safe-area-inset-top, 0px);
        }

        .ide-container {
            display: flex;
            flex-direction: column;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            position: relative;
        }

        /* Header */
        .ide-header {
            height: 48px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 16px;
            justify-content: space-between;
            z-index: 100;
        }

        .ide-title {
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .system-info {
            font-size: 12px;
            color: var(--text-secondary);
            margin-left: 8px;
        }
        
        .system-picker {
            background: var(--border-color);
            border: 1px solid #5a5a5a;
            color: var(--text-primary);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            max-width: 300px;
            transition: background 0.2s;
        }
        
        .system-picker:hover {
            background: #505050;
        }

        .header-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .header-group {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 0 10px;
            border-right: 1px solid var(--border-color);
            height: 32px;
        }

        .header-group:last-child {
            border-right: none;
        }

        .header-group-label {
            font-size: 9px;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-right: 4px;
            opacity: 0.7;
            font-weight: 700;
            user-select: none;
        }

        .tab-btn {
            padding: 8px 16px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            outline: none;
            -webkit-tap-highlight-color: transparent;
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            height: 100%;
        }

        .tab-btn:hover {
            color: var(--text-primary);
            background: rgba(255,255,255,0.05);
        }

        .tab-btn.active {
            border-bottom: 2px solid var(--accent-primary);
            color: var(--accent-primary);
        }

        .tab-btn.agent-ide-tab {
            font-weight: 700;
            background: rgba(0, 122, 204, 0.1);
            border-radius: 4px 4px 0 0;
            border-bottom: 2px solid transparent;
            color: #ccc;
        }

        .tab-btn.agent-ide-tab.active {
            background: rgba(0, 122, 204, 0.2);
            color: #00aaff;
            border-bottom-color: #00aaff;
        }

        .btn {
            background: #0e639c;
            border: none;
            color: white;
            padding: 6px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover:not(:disabled) {
            background: var(--accent-hover);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .btn-icon {
            padding: 6px 8px;
            font-size: 14px;
            background: transparent;
            border: 1px solid transparent;
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            justify-content: center;
        }

        .btn-icon:hover:not(:disabled) {
            background: var(--bg-hover);
            border-color: var(--border-color);
            color: var(--text-primary);
        }

        .btn-icon.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        /* Body */
        .ide-body {
            flex: 1;
            display: flex;
            overflow: hidden;
            min-height: 0;
            /* Using flex: 1 and min-height: 0 instead of height: 0 for broader compatibility */
        }

        /* Sidebar - Professional resizable panel */
        .sidebar {
            width: 280px;
            flex: 0 0 auto;
            min-width: 150px; /* Allow smaller sidebar */
            max-width: 800px; /* Allow larger sidebar */
            min-height: 0; /* Critical for flex scrolling */
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: none; /* Disable transition during resize */
            position: relative;
        }

        .sidebar.collapsed {
            width: 0 !important;
            min-width: 0 !important;
            padding: 0;
            overflow: hidden;
            border-right: none;
        }
        
        .sidebar.collapsed * {
            opacity: 0;
            pointer-events: none;
        }
        
        .sidebar.collapsed .resize-handle {
            display: none;
        }
        
        /* Sidebar expand button - shown when sidebar is collapsed */
        .sidebar-expand-btn {
            position: absolute;
            left: 0;
            top: 60px;
            width: 24px;
            height: 48px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-left: none;
            border-radius: 0 6px 6px 0;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, width 0.2s;
        }
        
        .sidebar-expand-btn:hover {
            background: var(--accent-primary);
            width: 32px;
        }

        /* Resize handles - Make visible and functional */
        .resize-handle {
            position: absolute;
            background: transparent;
            z-index: 1000;
            transition: background 0.2s, box-shadow 0.2s;
        }

        .resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 48px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .resize-handle:hover {
            background: rgba(0, 122, 204, 0.15);
        }

        .resize-handle:hover::after {
            opacity: 1;
            background: rgba(0, 122, 204, 0.6);
        }

        .resize-handle.active {
            background: rgba(0, 122, 204, 0.25);
        }

        .resize-handle.active::after {
            opacity: 1;
            background: var(--accent-primary);
            height: 100%;
            width: 2px;
        }

        .resize-handle-vertical {
            width: 10px; /* Wider hit area */
            top: 0;
            bottom: 0;
            cursor: col-resize;
            -webkit-user-select: none;
            user-select: none;
        }

        .sidebar .resize-handle-vertical {
            right: -5px;
        }

        .preview-pane .resize-handle-vertical {
            left: -5px;
        }

        .ai-panel .resize-handle-vertical {
            left: -5px;
        }

        .sidebar-header {
            padding: 12px 16px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-primary);
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-tree {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 8px 0;
            user-select: none;
            min-height: 0; /* Critical for flex scrolling */
        }

        .file-tree::-webkit-scrollbar {
            width: 8px;
        }

        .file-tree::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .tree-item {
            display: block;
        }

        .file-item, .folder-item {
            padding: 4px 12px 4px 8px;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background 0.15s;
            white-space: nowrap;
        }

        .file-item:hover, .folder-item:hover {
            background: #2a2d2e;
        }

        .file-item.active {
            background: #37373d;
            color: var(--text-active);
        }

        .folder-item {
            font-weight: 500;
        }

        .folder-chevron {
            font-size: 10px;
            color: var(--text-secondary);
            transition: transform 0.2s;
            width: 12px;
            text-align: center;
        }

        .folder-chevron.expanded {
            transform: rotate(90deg);
        }

        .folder-icon, .file-icon {
            font-size: 14px;
        }

        .file-icon {
            margin-left: 18px;
        }

        .folder-contents {
            padding-left: 16px;
        }

        .folder-contents.collapsed {
            display: none;
        }

        /* Editor Container - Flexible sizing */
        .editor-container {
            flex: 1;
            min-width: 150px; /* Allow editor to be much smaller */
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
            position: relative;
            overflow: hidden;
            min-height: 0; /* Critical for nested flex scrolling */
        }

        /* Tabs Bar */
        .tabs-bar {
            height: 35px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            overflow-x: auto;
        }

        .tabs-bar::-webkit-scrollbar {
            height: 3px;
        }

        .tabs-bar::-webkit-scrollbar-thumb {
            background: var(--border-color);
        }

        /* Breadcrumb Bar */
        .breadcrumb-bar {
            user-select: none;
        }

        .breadcrumb-bar::-webkit-scrollbar {
            height: 3px;
        }

        .breadcrumb-bar::-webkit-scrollbar-thumb {
            background: var(--border-color);
        }

        .breadcrumb-item {
            display: inline-block;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: background 0.15s, color 0.15s;
        }

        .breadcrumb-item:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .breadcrumb-item.active {
            color: var(--text-active);
            font-weight: 500;
        }

        .breadcrumb-separator {
            display: inline-block;
            margin: 0 6px;
            color: var(--text-secondary);
            font-size: 10px;
        }

        .tab {
            padding: 8px 16px;
            background: transparent;
            border: none;
            border-right: 1px solid var(--border-color);
            color: var(--text-secondary);
            cursor: pointer;
            white-space: nowrap;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.15s, color 0.15s;
            max-width: 200px;
            min-width: 80px;
            flex-shrink: 0;
        }
        
        .tab .tab-name {
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 140px;
        }

        .tab:hover {
            background: #2a2d2e;
            color: var(--text-primary);
        }

        .tab.active {
            background: var(--bg-primary);
            color: var(--text-active);
        }

        .tab.pinned {
            background: var(--bg-secondary);
            border-left: 2px solid #0e639c;
        }

        .tab.pinned.active {
            background: var(--bg-primary);
        }

        .tab.dragging {
            opacity: 0.5;
        }

        .tab.drag-over {
            border-left: 2px solid #0e639c;
        }

        .tab-pin {
            opacity: 0;
            margin-right: 4px;
            font-size: 12px;
            line-height: 1;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .tab:hover .tab-pin {
            opacity: 0.6;
        }

        .tab-pin:hover {
            opacity: 1;
        }

        .tab.pinned .tab-pin {
            opacity: 0.8;
        }

        .tab-close {
            opacity: 0.4;
            margin-left: 4px;
            font-size: 16px;
            line-height: 1;
            transition: opacity 0.2s;
            cursor: pointer;
            padding: 2px;
            border-radius: 3px;
        }

        .tab:hover .tab-close {
            opacity: 0.7;
        }

        .tab-close:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.1);
        }

        /* Split View */
        .editor-split-container {
            flex: 1;
            display: flex;
            overflow: hidden;
            min-width: 0;
            min-height: 0;
        }

        .editor-pane {
            flex: 1 1 0;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            min-height: 0;
        }

        /* Preview Pane - Professional resizable panel */
        .preview-pane {
            width: 400px;
            flex: 0 0 auto;
            min-width: 200px; /* Allow smaller preview */
            max-width: 1200px; /* Allow larger preview */
            background: var(--bg-primary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            min-height: 0; /* Critical for nested flex scrolling */
        }

        .preview-pane.hidden {
            display: none;
        }

        /* Resize handle position already defined above */

        .preview-header {
            height: 35px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            padding: 0 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            font-weight: 600;
        }

        .preview-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            color: var(--text-primary);
            min-height: 0; /* Critical for flex scrolling */
        }

        .preview-content h1, .preview-content h2, .preview-content h3 {
            color: var(--text-active);
            margin-top: 24px;
            margin-bottom: 12px;
        }

        .preview-content h1 { font-size: 28px; }
        .preview-content h2 { font-size: 22px; }
        .preview-content h3 { font-size: 18px; }

        .preview-content p {
            margin-bottom: 12px;
            line-height: 1.6;
        }

        .preview-content code {
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .preview-content pre {
            background: var(--bg-secondary);
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 12px 0;
        }

        .preview-content pre code {
            background: none;
            padding: 0;
        }

        /* AI Chat Panel - Professional resizable panel */
        /* Modern AI Panel Overhaul */
        .ai-panel {
            width: 400px;
            flex: 0 0 auto;
            min-width: 250px;
            max-width: 1600px;
            min-height: 0;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .ai-panel.hidden {
            display: none;
        }

        /* Terminal Dock */
        .terminal-dock {
            height: 280px;
            min-height: 140px;
            max-height: 70vh;
            background: #0b0f17;
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            flex: 0 0 auto;
        }

        .terminal-dock.hidden {
            display: none;
        }

        .terminal-resize-handle {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: row-resize;
            z-index: 10;
            background: transparent;
        }

        .terminal-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 2px;
            transform: translateX(-50%);
            width: 40px;
            height: 2px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.2);
        }

        .terminal-header {
            height: 34px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            background: #101827;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            gap: 8px;
            color: #d3dbe8;
            user-select: none;
        }

        .terminal-tabs {
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 0;
            overflow-x: auto;
            scrollbar-width: thin;
        }

        .terminal-tab {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border: 1px solid transparent;
            border-radius: 6px;
            color: #b8c4d9;
            font-size: 11px;
            cursor: pointer;
            white-space: nowrap;
            background: rgba(255, 255, 255, 0.03);
        }

        .terminal-tab.active {
            color: #ffffff;
            border-color: rgba(45, 212, 191, 0.6);
            background: rgba(45, 212, 191, 0.12);
        }

        .terminal-tab .state-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #34d399;
            display: inline-block;
        }

        .terminal-tab.exited .state-dot {
            background: #f59e0b;
        }

        .terminal-tab.disconnected .state-dot {
            background: #ef4444;
        }

        .terminal-actions {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            flex: 0 0 auto;
        }

        .terminal-actions button {
            height: 24px;
            min-width: 24px;
            padding: 0 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(255, 255, 255, 0.06);
            color: #dbe7ff;
            font-size: 11px;
            cursor: pointer;
        }

        .terminal-actions button:hover {
            background: rgba(255, 255, 255, 0.14);
        }

        .terminal-body {
            flex: 1;
            min-height: 0;
            position: relative;
            background: #0b0f17;
        }

        .terminal-empty {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #7f8ba1;
            font-size: 12px;
        }

        .terminal-view {
            width: 100%;
            height: 100%;
            padding: 8px;
            overflow: hidden;
            display: none;
        }

        .terminal-view.active {
            display: block;
        }

        @media (max-width: 900px) {
            .terminal-dock {
                display: none !important;
            }
        }

        .ai-header {
            height: 40px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            padding: 0 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
            user-select: none;
        }

        .brain-toggle {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            padding: 4px 8px;
            border-radius: 4px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            transition: all 0.15s ease;
        }

        .brain-toggle:hover {
            background: var(--bg-tertiary);
        }

        .brain-toggle input[type="checkbox"] {
            display: none;
        }

        .brain-toggle-label {
            color: var(--text-secondary);
            opacity: 0.6;
            transition: all 0.15s ease;
        }

        .brain-toggle-label::before {
            content: "";
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-secondary);
            margin-right: 4px;
            opacity: 0.4;
            transition: all 0.15s ease;
        }

        .brain-toggle input:checked + .brain-toggle-label {
            color: #4ade80;
            opacity: 1;
        }

        .brain-toggle input:checked + .brain-toggle-label::before {
            background: #4ade80;
            opacity: 1;
            box-shadow: 0 0 6px rgba(74, 222, 128, 0.5);
        }

        .ai-chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            background: var(--bg-primary);
        }

        .ai-message {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 100%;
            animation: fadeIn 0.3s ease-out;
        }

        .ai-message.assistant {
            background: transparent;
            padding: 0;
            border: none;
            box-shadow: none;
        }

        .ai-message.user {
            background: rgba(99, 102, 241, 0.08);
            border-radius: 8px;
            padding: 12px 16px;
            border: 1px solid rgba(99, 102, 241, 0.15);
            margin-left: 20px;
        }

        .ai-message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .ai-message.assistant .ai-message-header {
            color: var(--accent-primary);
        }

        .ai-message.user .ai-message-header {
            color: #818cf8;
        }

        .ai-message-content {
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-primary);
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .ai-message.assistant .ai-message-content {
            font-size: 14px;
            line-height: 1.6;
        }

        /* Modern Code Blocks in Chat */
        .ai-message.assistant pre {
            background: #121212;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            margin: 12px 0;
            overflow-x: auto;
            position: relative;
        }

        .ai-message.assistant code {
            font-family: var(--font-mono, monospace);
            font-size: 13px;
            color: #e0e0e0;
        }

        /* System/Tool Messages - Minimalist */
        .ai-message.system, .ai-message.tool-feedback {
            background: rgba(255, 255, 255, 0.02);
            border-left: 2px solid var(--accent-primary);
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 4px;
            opacity: 0.8;
        }

        .ai-message.system .ai-message-content, 
        .ai-message.tool-feedback .ai-message-content {
            font-size: 12px;
            font-family: var(--font-mono, monospace);
            color: var(--text-secondary);
        }

        .ai-message.system.thinking {
            border-left-color: #6a6a6a;
            font-style: italic;
        }

        .ai-message.system.tool-success {
            border-left-color: var(--success-color);
        }

        .ai-message.system.tool-error {
            border-left-color: var(--error-color);
        }

        /* Input Area - Modern Float */
        .ai-input-container {
            padding: 16px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
        }

        .ai-input-wrapper {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            transition: border-color 0.2s;
        }

        .ai-input-wrapper:focus-within {
            border-color: var(--accent-primary);
        }

        #ai-input {
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 14px;
            font-family: inherit;
            resize: none;
            padding: 4px;
            min-height: 40px;
            max-height: 200px;
            outline: none;
        }
        
        /* AI Details Container - Smaller, subtle, collapsible */
        .ai-details-container {
            background: rgba(100, 100, 100, 0.03);
            border: 1px solid rgba(100, 100, 100, 0.15);
            border-radius: 6px;
            padding: 8px 12px;
            margin: 8px 0;
            font-size: 11px;
            opacity: 0.85;
        }
        
        .ai-details-container details {
            cursor: pointer;
        }
        
        .ai-details-container summary {
            font-weight: 600;
            color: #6b7280;
            font-size: 11px;
            padding: 4px 0;
            user-select: none;
            list-style: none;
            opacity: 0.7;
        }
        
        .ai-details-container summary:hover {
            opacity: 1;
        }
        
        .ai-details-container summary::-webkit-details-marker {
            display: none;
        }
        
        .ai-details-container summary::before {
            content: '▼ ';
            display: inline-block;
            transition: transform 0.2s;
            font-size: 9px;
        }
        
        .ai-details-container details:not([open]) summary::before {
            transform: rotate(-90deg);
        }
        
        .ai-details-content {
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid rgba(100, 100, 100, 0.1);
            max-width: 100%;
            overflow: visible;
        }
        
        .thinking-item, .tool-item {
            padding: 4px 6px;
            margin: 3px 0;
            border-radius: 3px;
            font-size: 11px;
            display: flex;
            align-items: flex-start;
            gap: 6px;
            max-width: 100%;
            overflow: visible;
        }
        
        .thinking-item {
            background: rgba(156, 163, 175, 0.05);
            border-left: 2px solid rgba(156, 163, 175, 0.2);
        }
        
        .thinking-icon {
            flex-shrink: 0;
            font-size: 10px;
        }
        
        .thinking-text {
            color: #6b7280;
            font-style: italic;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            flex: 1;
            min-width: 0;
        }
        
        .tool-item {
            background: rgba(138, 180, 248, 0.03);
        }

        /* Token Counter - Context Window Management */
        .ai-token-counter {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            font-size: 10px;
            color: var(--text-secondary);
            border-top: 1px solid rgba(100, 100, 100, 0.15);
            background: rgba(0, 0, 0, 0.05);
        }

        .token-display {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .token-count {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .token-status-bar {
            flex: 1;
            height: 4px;
            background: rgba(100, 100, 100, 0.2);
            border-radius: 2px;
            overflow: hidden;
            min-width: 60px;
        }

        .token-status-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease, background-color 0.3s ease;
        }

        .token-status-fill[data-status="green"] {
            background: #22c55e;
        }

        .token-status-fill[data-status="yellow"] {
            background: #eab308;
        }

        .token-status-fill[data-status="red"] {
            background: #ef4444;
        }

        .summarize-btn {
            padding: 2px 8px;
            font-size: 9px;
            font-weight: 600;
            border: 1px solid rgba(100, 100, 100, 0.3);
            border-radius: 4px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .summarize-btn:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: var(--accent-color);
            color: var(--accent-color);
        }

        .summarize-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .summarize-btn.summarizing {
            animation: pulse 1.5s infinite;
            border-left: 2px solid rgba(138, 180, 248, 0.2);
        }
        
        .tool-item.tool-running {
            border-left-color: rgba(138, 180, 248, 0.4);
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        .tool-item.tool-running .tool-status {
            color: #8ab4f8;
        }
        
        .tool-item.tool-success {
            border-left-color: rgba(129, 201, 149, 0.3);
        }
        
        .tool-item.tool-success .tool-status {
            color: #81c995;
        }
        
        .tool-item.tool-error {
            border-left-color: rgba(244, 135, 113, 0.3);
        }
        
        .tool-item.tool-error .tool-status {
            color: #f48771;
        }
        
        .tool-icon, .tool-status {
            flex-shrink: 0;
            font-size: 11px;
        }
        
        .tool-text {
            color: #6b7280;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            flex: 1;
            min-width: 0;
        }

        /* AI Tools Section - Unified collapsible container */
        .ai-tools-section {
            background: rgba(40, 40, 45, 0.8);
            border-radius: 8px;
            padding: 10px 14px;
            margin: 8px 0;
            font-size: 12px;
            border: 1px solid rgba(120, 120, 130, 0.3);
        }

        .ai-tools-section summary {
            cursor: pointer;
            color: #b0b0b8;
            font-weight: 600;
            font-size: 12px;
            padding: 4px 0;
            user-select: none;
            list-style: none;
        }

        .ai-tools-section summary::-webkit-details-marker {
            display: none;
        }

        .ai-tools-section summary::before {
            content: '▶ ';
            display: inline-block;
            transition: transform 0.2s;
            font-size: 9px;
        }

        .ai-tools-section details[open] summary::before {
            transform: rotate(90deg);
        }

        .ai-tools-list {
            padding: 8px 0 4px 8px;
        }

        .ai-tools-section .tool-item {
            color: #c8c8d0;
        }

        .ai-tools-section .tool-text {
            color: #a8a8b4;
        }

        .ai-tools-section .tool-item.tool-success .tool-text {
            color: #8cd9a0;
        }

        .ai-tools-section .tool-item.tool-error .tool-text {
            color: #f0a090;
        }

        .ai-tools-section .thinking-text {
            color: #a0a8b8;
        }

        /* Brain Context Section */
        .ai-brain-context {
            background: linear-gradient(135deg, rgba(100, 60, 140, 0.15), rgba(60, 100, 140, 0.15));
            border-radius: 8px;
            padding: 10px 14px;
            margin: 8px 0;
            font-size: 12px;
            border: 1px solid rgba(140, 100, 180, 0.3);
        }

        .ai-brain-context summary {
            cursor: pointer;
            color: #c8a8e8;
            font-weight: 600;
            font-size: 13px;
            padding: 4px 0;
            user-select: none;
            list-style: none;
        }

        .ai-brain-context summary::-webkit-details-marker {
            display: none;
        }

        .ai-brain-context summary::before {
            content: '▶ ';
            display: inline-block;
            transition: transform 0.2s;
            font-size: 9px;
        }

        .ai-brain-context details[open] summary::before {
            transform: rotate(90deg);
        }

        .brain-stats {
            display: flex;
            gap: 16px;
            padding: 8px 0;
            font-size: 11px;
            color: #a0a0b0;
            border-bottom: 1px solid rgba(140, 100, 180, 0.2);
            margin-bottom: 8px;
        }

        .brain-stats span {
            background: rgba(80, 80, 100, 0.3);
            padding: 2px 8px;
            border-radius: 4px;
        }

        .brain-nodes-list {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 8px;
        }

        .brain-node {
            background: rgba(40, 40, 50, 0.5);
            border-radius: 6px;
            padding: 8px 10px;
            margin-bottom: 6px;
            border-left: 3px solid rgba(140, 100, 180, 0.5);
        }

        .brain-node.connected {
            border-left-color: rgba(100, 180, 140, 0.6);
            background: rgba(40, 50, 45, 0.5);
        }

        .brain-node-header {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 4px;
            flex-wrap: wrap;
        }

        .node-rank {
            color: #888;
            font-size: 10px;
            min-width: 24px;
        }

        .node-score {
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            color: #fff;
        }

        .node-tag {
            color: #c8a8e8;
            font-size: 11px;
            background: rgba(140, 100, 180, 0.2);
            padding: 1px 6px;
            border-radius: 3px;
        }

        .node-id {
            color: #707080;
            font-size: 10px;
            font-family: monospace;
        }

        .node-connected {
            color: #8cd9a0;
            font-size: 10px;
        }

        .brain-node-preview {
            color: #b0b0c0;
            font-size: 11px;
            line-height: 1.4;
            word-break: break-word;
        }

        /* AI Chat History Modern Overhaul */
        #chat-history-panel {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            max-height: 0;
            opacity: 0;
        }

        #chat-history-panel:not(.hidden) {
            max-height: 400px;
            opacity: 1;
            box-shadow: inset 0 -10px 20px rgba(0,0,0,0.1);
        }

        .chat-history-header {
            padding: 10px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .chat-history-item {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .chat-history-item:last-child {
            border-bottom: none;
        }

        .chat-history-item:hover {
            background: var(--bg-hover);
        }

        .chat-history-item .conv-title {
            font-size: 13px;
            color: var(--text-primary);
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-history-item .conv-meta {
            font-size: 10px;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
        }

        #chat-history-list::-webkit-scrollbar {
            width: 4px;
        }

        #chat-history-list::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 2px;
        }

        .ai-message.assistant p {
            margin: 8px 0;
            line-height: 1.6;
        }
        
        .ai-message.assistant p:first-child {
            margin-top: 0;
        }
        
        .ai-message.assistant p:last-child {
            margin-bottom: 0;
        }

        .ai-message.assistant ul, .ai-message.assistant ol {
            margin: 10px 0;
            padding-left: 24px;
        }

        .ai-message.assistant li {
            margin: 4px 0;
            line-height: 1.5;
        }

        .ai-message.assistant h1,
        .ai-message.assistant h2,
        .ai-message.assistant h3,
        .ai-message.assistant h4 {
            margin: 20px 0 12px 0;
            color: var(--text-primary);
            font-weight: 600;
        }

        .ai-message.assistant h1 { font-size: 1.6em; }
        .ai-message.assistant h2 { font-size: 1.4em; }
        .ai-message.assistant h3 { font-size: 1.2em; }
        .ai-message.assistant h4 { font-size: 1.1em; }

        .ai-message.assistant code {
            background: rgba(255, 255, 255, 0.08);
            padding: 2px 5px;
            border-radius: 4px;
            font-family: var(--font-mono, monospace);
            font-size: 0.9em;
            color: var(--accent-primary);
        }

        .ai-message.assistant blockquote {
            border-left: 3px solid var(--accent-primary);
            padding-left: 14px;
            margin: 16px 0;
            color: var(--text-secondary);
            font-style: italic;
        }

        .ai-message.assistant a {
            color: var(--accent-primary);
            text-decoration: none;
        }

        .ai-message.assistant a:hover {
            text-decoration: underline;
        }

        .ai-message.assistant hr {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 20px 0;
        }

        .ai-message.assistant table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
        }

        .ai-message.assistant th,
        .ai-message.assistant td {
            border: 1px solid #e1e4e8;
            padding: 8px 12px;
            text-align: left;
        }

        .ai-message.assistant th {
            background: #f6f8fa;
            font-weight: 600;
        }

        .ai-message.assistant img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 12px 0;
        }

        /* Tool feedback / thinking cards */
        .ai-message.system, .ai-message.tool-feedback {
            background: linear-gradient(135deg, #fff9f0 0%, #ffffff 100%);
            border: 1.5px solid rgba(255,149,0,0.4);
            border-radius: 20px;
            padding: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 16px 50px rgba(255,149,0,0.15);
        }

        .ai-message.system::before, .ai-message.tool-feedback::before {
            content: "";
            position: absolute;
            top: 0; 
            left: -100%;
            width: 50%; 
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,149,0,0.12), transparent);
            animation: shimmer 2.5s infinite;
        }

        .ai-message.system .ai-message-header, .ai-message.tool-feedback .ai-message-header {
            color: #ff9500;
        }

        .ai-message.system .ai-message-content, .ai-message.tool-feedback .ai-message-content {
            color: #1a1a1a;
            font-family: "JetBrains Mono", ui-monospace, monospace;
            font-size: 13px;
        }

        .ai-message.error {
            background: #3d2020;
            border-radius: 12px;
            padding: 16px;
        }

        .ai-message.error .ai-message-content {
            color: var(--error-color);
        }

        @keyframes fadeUp { 
            from { 
                opacity: 0; 
                transform: translateY(30px); 
            } 
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes shimmer { 
            0% { left: -100%; } 
            100% { left: 100%; } 
        }

        .ai-message-actions {
            margin-top: 8px;
            display: flex;
            gap: 8px;
        }

        .ai-quick-actions {
            padding: 12px 16px;
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
        }

        .ai-quick-actions-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .ai-quick-action-btn {
            display: block;
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            text-align: left;
            margin-bottom: 6px;
            transition: all 0.15s;
        }

        .ai-quick-action-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        .ai-input-container {
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
        }

        .ai-input {
            width: 100%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 13px;
            font-family: inherit;
            resize: vertical;
            min-height: 60px;
            max-height: 200px;
            box-sizing: border-box;
            overflow-wrap: break-word;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .ai-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .ai-send-btn {
            margin-top: 8px;
            width: 100%;
            background: var(--accent-primary);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .ai-send-btn:hover:not(:disabled) {
            background: var(--accent-hover);
        }

        .ai-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .ai-thinking {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 12px;
            color: var(--text-secondary);
        }
        .ai-thinking-timer {
            margin-left: auto;
            font-variant-numeric: tabular-nums;
            opacity: 0.6;
            font-size: 11px;
        }

        .ai-thinking-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Editor Wrapper */
        .editor-wrapper {
            flex: 1;
            position: relative;
            min-height: 0; /* Critical for nested flex scrolling */
        }

        #monaco-editor {
            width: 100%;
            height: 100%;
        }
        
        #monaco-diff-editor {
            width: 100%;
            height: 100%;
        }
        
        #monaco-diff-editor.hidden {
            display: none;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-primary);
            font-size: 14px;
            z-index: 50;
        }

        .loading-overlay.hidden {
            display: none;
        }

        /* Command Palette */
        .command-palette {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            max-width: 90vw;
            max-height: 400px;
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-primary);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            z-index: 10000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .command-palette.hidden {
            display: none;
        }

        .command-palette input {
            width: 100%;
            padding: 16px;
            background: var(--border-color);
            border: none;
            color: var(--text-primary);
            font-size: 14px;
            outline: none;
        }

        .command-results {
            flex: 1;
            overflow-y: auto;
        }

        .command-item {
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.15s;
            border-left: 3px solid transparent;
        }

        .command-item:hover, .command-item.selected {
            background: var(--bg-secondary);
            border-left-color: var(--accent-primary);
        }

        .command-label {
            font-size: 13px;
        }

        .command-keys {
            font-size: 11px;
            color: var(--text-secondary);
            background: var(--bg-secondary);
            padding: 2px 8px;
            border-radius: 3px;
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 400px;
            height: 100vh;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.3s;
            box-shadow: -4px 0 12px rgba(0,0,0,0.3);
        }

        .settings-panel.open {
            transform: translateX(0);
        }

        .settings-header {
            height: 48px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            padding: 0 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 600;
        }

        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .setting-group {
            margin-bottom: 24px;
        }

        .setting-group-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        .setting-item {
            margin-bottom: 16px;
        }

        .setting-label {
            font-size: 13px;
            margin-bottom: 6px;
            display: block;
        }

        .setting-input {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
            font-size: 13px;
        }

        .setting-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .setting-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .setting-checkbox input {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* Search Panel */
        .search-panel {
            position: absolute;
            top: 50px;
            right: 20px;
            width: 350px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            z-index: 1000;
            padding: 12px;
        }

        .search-panel.hidden {
            display: none;
        }

        .search-input-group {
            margin-bottom: 8px;
        }

        .search-input {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
            font-size: 13px;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .search-options {
            display: flex;
            gap: 12px;
            margin-top: 8px;
            font-size: 12px;
        }

        .search-option {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
        }

        /* Keyboard Help */
        .keyboard-help {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 700px;
            max-width: 90vw;
            max-height: 80vh;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            z-index: 10000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .keyboard-help.hidden {
            display: none;
        }

        .keyboard-help-header {
            padding: 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            display: flex;
            justify-content: space-between;
        }

        .keyboard-help-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .shortcut-section {
            margin-bottom: 20px;
        }

        .shortcut-section-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 13px;
        }

        .shortcut-keys {
            color: var(--text-secondary);
            font-family: monospace;
        }

        /* Status Bar */
        .status-bar {
            height: 22px;
            background: var(--accent-primary);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 12px;
            font-size: 12px;
            justify-content: space-between;
        }

        .status-left, .status-right {
            display: flex;
            gap: 16px;
        }

        .status-item {
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .status-item:hover {
            opacity: 0.8;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 12px 20px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            font-size: 13px;
            z-index: 10001;
            animation: slideIn 0.3s ease-out;
        }

        .toast.success {
            border-left: 3px solid var(--success-color);
        }

        .toast.error {
            border-left: 3px solid var(--error-color);
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            z-index: 10000;
            min-width: 180px;
            padding: 4px 0;
        }

        .context-menu.hidden {
            display: none;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.15s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .context-menu-item:hover {
            background: var(--bg-secondary);
        }

        .context-menu-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .context-menu-item.disabled:hover {
            background: transparent;
        }
        
        .context-menu-item.danger {
            color: var(--error-color);
        }
        
        .context-menu-item span:first-child {
            margin-right: 8px;
        }

        .context-menu-separator {
            height: 1px;
            background: var(--border-color);
            margin: 4px 0;
        }

        /* Tooltips */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-4px);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            border: 1px solid var(--border-color);
            z-index: 10000;
        }

        [data-tooltip]:hover::after {
            opacity: 1;
        }

        /* Overlay for modals */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9998;
            pointer-events: auto;
            display: block;
        }

        .overlay.hidden {
            display: none !important;
            pointer-events: none !important;
        }

        /* Optimized transitions - removed universal selector which breaks performance/scrolling */
        input, select, button, .tab, .file-item, .btn, .tree-item, .node-item {
            transition: background-color 0.15s ease, color 0.15s ease, border-color 0.15s ease, opacity 0.15s ease, transform 0.15s ease;
        }

        /* Global scrollbar styles */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: #3e3e42;
            border-radius: 5px;
            border: 2px solid var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #505050;
        }

        /* ========================================================================== */
        /* EDIT QUEUE PANEL - Cursor-style edit review */
        /* ========================================================================== */
        
        .edit-queue-panel {
            position: fixed;
            right: 0;
            top: 60px;
            bottom: 0;
            width: 340px;
            background: #ffffff;
            border-left: 1px solid rgba(255,149,0,0.3);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            transform: translateX(0);
            transition: transform 0.3s ease;
            box-shadow: -5px 0 30px rgba(0,0,0,0.1);
        }

        .edit-queue-panel.hidden {
            transform: translateX(100%);
        }

        .edit-queue-header {
            padding: 20px;
            background: linear-gradient(135deg, #fff9f0 0%, #ffffff 100%);
            border-bottom: 1px solid rgba(255,149,0,0.25);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .edit-queue-header h3 {
            font-size: 15px;
            font-weight: 700;
            margin: 0;
            color: #ff9500;
        }

        .edit-queue-actions {
            padding: 12px;
            display: flex;
            gap: 6px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .edit-queue-actions .btn {
            flex: 1;
            min-width: 80px;
            padding: 6px 10px;
            font-size: 11px;
        }

        .edit-queue-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .edit-item {
            background: linear-gradient(135deg, #fff9f0 0%, #ffffff 100%);
            border: 1.5px solid rgba(255,149,0,0.4);
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 0 8px 20px rgba(255,149,0,0.1);
        }

        .edit-item::before {
            content: "";
            position: absolute;
            top: 0; 
            left: -100%;
            width: 50%; 
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,149,0,0.08), transparent);
            animation: shimmer 3s infinite;
        }

        .edit-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 30px rgba(255,149,0,0.2);
            border-color: rgba(255,149,0,0.6);
        }

        .edit-item.accepted {
            border-left: 4px solid #10b981;
            opacity: 0.7;
            background: linear-gradient(135deg, #f0fdf4 0%, #ffffff 100%);
        }

        .edit-item.rejected {
            border-left: 4px solid #ef4444;
            opacity: 0.7;
            background: linear-gradient(135deg, #fef2f2 0%, #ffffff 100%);
        }

        .edit-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .edit-item-file {
            font-weight: 700;
            font-size: 13px;
            color: #ff9500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }

        .edit-item-status {
            font-size: 10px;
            padding: 4px 8px;
            border-radius: 8px;
            margin-left: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .edit-item-status.pending {
            background: linear-gradient(135deg, #ff9500, #ffb84d);
            color: white;
            box-shadow: 0 2px 8px rgba(255,149,0,0.3);
        }

        .edit-item-status.accepted {
            background: linear-gradient(135deg, #10b981, #34d399);
            color: white;
            box-shadow: 0 2px 8px rgba(16,185,129,0.3);
        }

        .edit-item-status.rejected {
            background: linear-gradient(135deg, #ef4444, #f87171);
            color: white;
            box-shadow: 0 2px 8px rgba(239,68,68,0.3);
        }

        .edit-item-summary {
            font-size: 12px;
            color: #666;
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .edit-item-actions {
            display: flex;
            gap: 8px;
        }

        .edit-item-actions button {
            flex: 1;
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 10px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .edit-item-actions button:hover {
            transform: scale(1.05);
        }

        .edit-item.accepted .edit-item-actions,
        .edit-item.rejected .edit-item-actions {
            display: none;
        }
        /* Brain Studio Tab Panels */
        .brain-studio-tabs {
          flex: 1;
          overflow: hidden;
          position: relative;
          min-height: 0; /* Critical for nested flex scrolling */
        }
        .brain-tab-panel {
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          overflow: hidden; /* Lock the panel itself */
          display: flex;
          flex-direction: column;
          min-height: 0;
          background: var(--bg-primary);
        }
        #files-tab-panel {
          display: flex;
          flex-direction: column;
          min-height: 0; /* Critical for nested flex scrolling */
        }

        /* Query Tab Styles */
        .query-container {
          display: flex;
          flex-direction: column;
          height: 100%;
          padding: 24px;
          overflow-y: auto;
          background: var(--bg-primary);
        }
        
        .query-input-section {
          background: var(--bg-secondary);
          border: 1px solid var(--border-color);
          border-radius: 8px;
          padding: 20px;
          margin-bottom: 24px;
        }
        
        .query-textarea {
          width: 100%;
          min-height: 120px;
          padding: 12px;
          background: var(--bg-primary);
          border: 1px solid var(--border-color);
          border-radius: 6px;
          color: var(--text-primary);
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
          font-size: 14px;
          resize: vertical;
          margin-bottom: 16px;
        }
        
        .query-options {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 16px;
          margin-bottom: 16px;
        }
        
        .option-group {
          display: flex;
          flex-direction: column;
          gap: 6px;
        }
        
        .option-group label {
          font-size: 12px;
          color: var(--text-secondary);
          font-weight: 500;
        }
        
        .query-select {
          padding: 8px 12px;
          background: var(--bg-primary);
          border: 1px solid var(--border-color);
          border-radius: 4px;
          color: var(--text-primary);
          font-size: 13px;
        }
        
        .query-select-sm {
          padding: 6px 10px;
          background: var(--bg-primary);
          border: 1px solid var(--border-color);
          border-radius: 4px;
          color: var(--text-primary);
          font-size: 12px;
        }
        
        .option-hint {
          font-size: 11px;
          color: var(--text-muted);
          font-style: italic;
          margin-top: 4px;
        }
        
        .query-enhancements, .query-context-options {
          display: flex;
          gap: 16px;
          margin-bottom: 12px;
          flex-wrap: wrap;
        }
        
        .query-enhancements label, .query-context-options label {
          display: flex;
          align-items: center;
          gap: 6px;
          font-size: 13px;
          color: var(--text-primary);
          cursor: pointer;
        }
        
        .query-actions {
          display: flex;
          gap: 12px;
          align-items: center;
          flex-wrap: wrap;
        }
        
        .btn-primary {
          padding: 10px 20px;
          background: var(--accent-primary);
          color: white;
          border: none;
          border-radius: 6px;
          font-size: 14px;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.2s;
        }
        
        .btn-primary:hover {
          background: var(--accent-hover);
          transform: translateY(-1px);
        }
        
        .btn-secondary {
          padding: 10px 20px;
          background: var(--bg-tertiary);
          color: var(--text-primary);
          border: 1px solid var(--border-color);
          border-radius: 6px;
          font-size: 14px;
          cursor: pointer;
          transition: all 0.2s;
        }
        
        .btn-secondary:hover {
          background: var(--bg-secondary);
        }
        
        .export-controls {
          display: flex;
          align-items: center;
          gap: 8px;
          margin-left: auto;
          font-size: 13px;
          color: var(--text-secondary);
        }
        
        .query-loading {
          background: var(--bg-secondary);
          border: 1px solid var(--border-color);
          border-radius: 8px;
          padding: 40px;
          text-align: center;
          color: var(--text-secondary);
        }
        
        .loading-spinner {
          width: 40px;
          height: 40px;
          border: 3px solid var(--border-color);
          border-top-color: var(--accent-primary);
          border-radius: 50%;
          animation: spin 1s linear infinite;
          margin: 0 auto 16px;
        }
        
        .loading-hint {
          font-size: 12px;
          color: var(--text-muted);
          margin-top: 8px;
        }
        
        @keyframes spin {
          to { transform: rotate(360deg); }
        }
        
        #queryResults {
          background: var(--bg-secondary);
          border: 1px solid var(--border-color);
          border-radius: 8px;
          padding: 20px;
          margin-bottom: 24px;
        }
        
        #queryHistory {
          background: var(--bg-secondary);
          border: 1px solid var(--border-color);
          border-radius: 8px;
          padding: 20px;
        }

        /* Explore Tab Styles */
        .explore-layout {
          display: grid;
          grid-template-columns: 280px 1fr 320px;
          height: 100%;
          gap: 0;
          background: var(--bg-primary);
        }
        
        .explore-sidebar {
          background: var(--bg-secondary);
          border-right: 1px solid var(--border-color);
          display: flex;
          flex-direction: column;
          overflow: hidden;
        }
        
        .sidebar-header {
          padding: 16px;
          font-weight: 600;
          color: var(--text-primary);
          border-bottom: 1px solid var(--border-color);
          font-size: 14px;
        }
        
        .search-input {
          margin: 12px;
          padding: 8px 12px;
          background: var(--bg-primary);
          border: 1px solid var(--border-color);
          border-radius: 6px;
          color: var(--text-primary);
          font-size: 13px;
        }
        
        .tag-filter {
          margin: 0 12px 12px;
          padding: 8px 12px;
          background: var(--bg-primary);
          border: 1px solid var(--border-color);
          border-radius: 6px;
          color: var(--text-primary);
          font-size: 13px;
        }
        
        .node-list {
          flex: 1;
          overflow-y: auto;
          padding: 8px;
        }
        
        .node-item {
          padding: 10px 12px;
          margin-bottom: 4px;
          background: var(--bg-primary);
          border: 1px solid var(--border-color);
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s;
          font-size: 13px;
          color: var(--text-primary);
        }
        
        .node-item:hover {
          background: var(--bg-tertiary);
          border-color: var(--accent-primary);
        }
        
        .graph-view {
          position: relative;
          background: var(--bg-primary);
          overflow: hidden;
        }
        
        #graph {
          width: 100%;
          height: 100%;
        }
        
        .graph-controls {
          position: absolute;
          top: 16px;
          right: 16px;
          display: flex;
          gap: 8px;
        }
        
        .graph-controls button {
          padding: 8px 12px;
          background: var(--bg-secondary);
          border: 1px solid var(--border-color);
          border-radius: 6px;
          color: var(--text-primary);
          font-size: 13px;
          cursor: pointer;
          transition: all 0.2s;
        }
        
        .graph-controls button:hover {
          background: var(--bg-tertiary);
          border-color: var(--accent-primary);
        }
        
        .explore-detail {
          background: var(--bg-secondary);
          border-left: 1px solid var(--border-color);
          padding: 20px;
          overflow-y: auto;
        }
        
        .empty-state {
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100%;
          color: var(--text-muted);
          gap: 12px;
        }
        
        .empty-icon {
          font-size: 48px;
          opacity: 0.5;
        }

        /* Enhanced Explore Tab Styles */
        .mini-btn {
          padding: 6px 12px;
          background: var(--bg-tertiary);
          border: 1px solid var(--border-color);
          border-radius: 4px;
          color: var(--text-primary);
          font-size: 11px;
          cursor: pointer;
          transition: all 0.2s;
          white-space: nowrap;
        }
        
        .mini-btn:hover {
          background: var(--bg-hover);
          border-color: var(--accent-primary);
          transform: translateY(-1px);
        }
        
        .node-item {
          padding: 12px;
          margin-bottom: 6px;
          background: var(--bg-primary);
          border: 1px solid var(--border-color);
          border-radius: 6px;
          cursor: pointer;
          transition: all 0.2s;
        }
        
        .node-item:hover {
          background: var(--bg-tertiary);
          border-color: var(--accent-primary);
          transform: translateX(4px);
          box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .node-item.selected {
          background: var(--bg-tertiary);
          border-color: var(--accent-primary);
          border-width: 2px;
          box-shadow: 0 0 12px rgba(0, 122, 204, 0.3);
        }
        
        .connection-item:hover {
          transform: translateX(4px);
          box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.5; }
        }
        
        .loading-spinner {
          width: 40px;
          height: 40px;
          border: 3px solid var(--border-color);
          border-top-color: var(--accent-primary);
          border-radius: 50%;
          animation: spin 1s linear infinite;
        }
        
        /* Graph node tooltips */
        .node-tooltip {
          position: absolute;
          background: var(--bg-secondary);
          border: 1px solid var(--border-color);
          border-radius: 6px;
          padding: 8px 12px;
          font-size: 12px;
          pointer-events: none;
          z-index: 1000;
          box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        
        /* Smooth scrollbars for node list */
        #nodeListContainer::-webkit-scrollbar {
          width: 8px;
        }
        
        #nodeListContainer::-webkit-scrollbar-track {
          background: var(--bg-primary);
        }
        
        #nodeListContainer::-webkit-scrollbar-thumb {
          background: var(--border-color);
          border-radius: 4px;
        }
        
        #nodeListContainer::-webkit-scrollbar-thumb:hover {
          background: var(--accent-primary);
        }
        
        /* Filter Buttons */
        .filter-btn {
          padding: 6px 12px;
          background: var(--bg-tertiary);
          border: 1px solid var(--border-color);
          border-radius: 4px;
          color: var(--text-primary);
          font-size: 11px;
          cursor: pointer;
          transition: all 0.2s;
          display: inline-flex;
          align-items: center;
          gap: 6px;
        }
        
        .filter-btn:hover {
          background: var(--bg-hover);
          border-color: var(--accent-primary);
        }
        
        .filter-btn.active {
          background: var(--accent-primary);
          border-color: var(--accent-primary);
          color: white;
        }
        
        .filter-count {
          background: rgba(255,255,255,0.2);
          padding: 2px 6px;
          border-radius: 3px;
          font-size: 10px;
          font-weight: 600;
        }
        
        .filter-btn.active .filter-count {
          background: rgba(255,255,255,0.3);
        }

        /* Documentation Tab Styling */
        .markdown-body {
          color: var(--text-primary);
          line-height: 1.6;
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
          padding-bottom: 50px;
        }
        .markdown-body h1, .markdown-body h2, .markdown-body h3 {
          margin-top: 24px;
          margin-bottom: 16px;
          font-weight: 600;
          line-height: 1.25;
          color: var(--text-active);
          border-bottom: 1px solid var(--border-color);
          padding-bottom: 0.3em;
        }
        .markdown-body p, .markdown-body ul, .markdown-body ol {
          margin-bottom: 16px;
        }
        .markdown-body code {
          padding: 0.2em 0.4em;
          margin: 0;
          font-size: 85%;
          background-color: rgba(255,255,255,0.05);
          border-radius: 6px;
          font-family: var(--font-mono, monospace);
        }
        .markdown-body pre {
          padding: 16px;
          overflow: auto;
          font-size: 85%;
          line-height: 1.45;
          background-color: #121212;
          border-radius: 6px;
          margin-bottom: 16px;
          border: 1px solid var(--border-color);
        }
        .markdown-body pre code {
          background: transparent;
          padding: 0;
        }
        .markdown-body blockquote {
          padding: 0 1em;
          color: var(--text-secondary);
          border-left: 0.25em solid var(--accent-primary);
          margin-bottom: 16px;
        }

        /* ============================================
           HUB TAB STYLES
           ============================================ */
        .hub-container {
          display: flex;
          flex-direction: column;
          height: 100%;
          background: var(--bg-primary);
        }

        .hub-header {
          padding: 16px 24px;
          border-bottom: 1px solid var(--border-color);
          display: flex;
          justify-content: space-between;
          align-items: center;
          background: var(--bg-tertiary);
        }

        .hub-header h2 {
          font-size: 15px;
          font-weight: 600;
          color: var(--text-primary);
          margin: 0;
        }

        .hub-header-left {
          display: flex;
          gap: 12px;
          align-items: center;
        }

        .hub-badge {
          font-size: 10px;
          color: var(--text-secondary);
          background: var(--bg-primary);
          padding: 3px 8px;
          border-radius: 10px;
          border: 1px solid var(--border-color);
        }

        .hub-badge-accent {
          color: var(--accent-primary);
          opacity: 0.8;
        }

        .hub-actions {
          display: flex;
          gap: 8px;
        }

        .hub-btn {
          border: none;
          border-radius: 6px;
          cursor: pointer;
          font-size: 13px;
          font-weight: 500;
          padding: 8px 16px;
          transition: all 0.2s;
        }

        .hub-btn-primary {
          background: var(--accent-primary);
          color: white;
        }

        .hub-btn-primary:hover:not(:disabled) {
          background: var(--accent-hover);
        }

        .hub-btn-primary:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }

        .hub-btn-secondary {
          background: var(--bg-secondary);
          color: var(--text-primary);
          border: 1px solid var(--border-color);
        }

        .hub-btn-secondary:hover {
          background: var(--bg-tertiary);
          border-color: var(--text-secondary);
        }

        .hub-content {
          flex: 1;
          display: flex;
          overflow: hidden;
        }

        .hub-sidebar {
          width: 320px;
          border-right: 1px solid var(--border-color);
          display: flex;
          flex-direction: column;
          background: var(--bg-secondary);
        }

        .hub-search {
          padding: 12px 16px;
          border-bottom: 1px solid var(--border-color);
        }

        .hub-search input {
          width: 100%;
          padding: 8px 12px;
          background: var(--bg-primary);
          border: 1px solid var(--border-color);
          border-radius: 6px;
          color: var(--text-primary);
          font-size: 13px;
        }

        .hub-search input:focus {
          outline: none;
          border-color: var(--accent-primary);
        }

        .hub-list-header {
          padding: 10px 16px;
          display: flex;
          justify-content: space-between;
          align-items: center;
          border-bottom: 1px solid var(--border-color);
        }

        .hub-list-header span {
          font-size: 11px;
          color: var(--text-secondary);
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }

        .hub-list-header button {
          background: none;
          border: none;
          color: var(--text-secondary);
          cursor: pointer;
          padding: 4px;
          font-size: 14px;
        }

        .hub-list-header button:hover {
          color: var(--text-primary);
        }

        .hub-brain-list {
          flex: 1;
          overflow-y: auto;
          padding: 8px;
        }

        .hub-brain-item {
          padding: 12px 14px;
          margin: 4px 0;
          background: var(--bg-primary);
          border-radius: 8px;
          cursor: pointer;
          border: 2px solid transparent;
          transition: all 0.15s ease;
          min-height: 48px;
          display: flex;
          align-items: center;
        }

        .hub-brain-item:hover {
          border-color: var(--border-color);
          background: var(--bg-tertiary);
        }

        .hub-brain-item.selected {
          border-color: var(--accent-primary);
          background: rgba(0, 122, 204, 0.1);
        }

        .hub-brain-item.previewing {
          background: var(--bg-tertiary);
        }

        .hub-brain-item-header {
          display: flex;
          justify-content: space-between;
          align-items: start;
        }

        .hub-brain-item-info {
          flex: 1;
          min-width: 0;
        }

        .hub-brain-item-name {
          font-weight: 600;
          color: var(--text-primary);
          display: flex;
          align-items: center;
          gap: 8px;
          font-size: 13px;
        }

        .hub-brain-item-name span {
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
        }

        .hub-brain-item-meta {
          font-size: 11px;
          color: var(--text-secondary);
          margin-top: 4px;
        }

        .hub-brain-item input[type="checkbox"] {
          cursor: pointer;
          margin-left: 8px;
          width: 16px;
          height: 16px;
        }

        .hub-preview {
          flex: 1;
          display: flex;
          flex-direction: column;
          overflow: hidden;
          background: var(--bg-primary);
        }

        .hub-preview-content {
          flex: 1;
          overflow-y: auto;
          padding: 24px;
        }

        .hub-empty-state {
          text-align: center;
          padding: 80px 48px;
          color: var(--text-secondary);
        }

        .hub-empty-state-icon {
          font-size: 64px;
          margin-bottom: 16px;
          opacity: 0.5;
        }

        .hub-empty-state-title {
          font-size: 16px;
          font-weight: 500;
          margin-bottom: 8px;
        }

        .hub-empty-state-subtitle {
          font-size: 13px;
          opacity: 0.7;
        }

        .hub-status {
          padding: 8px 16px;
          border-top: 1px solid var(--border-color);
          font-size: 11px;
          color: var(--text-secondary);
          display: flex;
          justify-content: space-between;
          background: var(--bg-secondary);
        }

        /* Hub Preview Details */
        .hub-details-header {
          display: flex;
          justify-content: space-between;
          align-items: start;
          margin-bottom: 24px;
        }

        .hub-details-title {
          font-size: 20px;
          font-weight: 600;
          color: var(--text-primary);
          margin: 0;
          display: flex;
          align-items: center;
          gap: 10px;
        }

        .hub-details-subtitle {
          font-size: 13px;
          color: var(--text-secondary);
          margin-top: 6px;
        }

        .hub-details-type {
          font-size: 11px;
          color: var(--text-secondary);
          margin-top: 4px;
          opacity: 0.7;
        }

        .hub-stats-grid {
          display: grid;
          grid-template-columns: repeat(4, 1fr);
          gap: 12px;
          margin-bottom: 24px;
        }

        .hub-stat-card {
          background: var(--bg-secondary);
          padding: 16px;
          border-radius: 8px;
          text-align: center;
          border: 1px solid var(--border-color);
        }

        .hub-stat-value {
          font-size: 28px;
          font-weight: 700;
        }

        .hub-stat-value.nodes { color: var(--accent-primary); }
        .hub-stat-value.edges { color: var(--success-color); }
        .hub-stat-value.cycles { color: var(--warning-color); }
        .hub-stat-value.outputs { color: var(--text-primary); }

        .hub-stat-label {
          font-size: 11px;
          color: var(--text-secondary);
          text-transform: uppercase;
          letter-spacing: 0.5px;
          margin-top: 4px;
        }

        .hub-metadata-card {
          background: var(--bg-secondary);
          padding: 16px;
          border-radius: 8px;
          margin-bottom: 24px;
          border: 1px solid var(--border-color);
        }

        .hub-metadata-title {
          font-size: 11px;
          text-transform: uppercase;
          letter-spacing: 0.5px;
          color: var(--text-secondary);
          margin: 0 0 12px 0;
        }

        .hub-metadata-grid {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 10px;
          font-size: 13px;
        }

        .hub-metadata-grid span:first-child {
          color: var(--text-secondary);
        }

        .hub-topics {
          display: flex;
          flex-wrap: wrap;
          gap: 6px;
        }

        .hub-topic-tag {
          background: var(--bg-tertiary);
          padding: 4px 10px;
          border-radius: 12px;
          font-size: 12px;
          color: var(--text-primary);
        }

        /* Hub Modal */
        .hub-modal-overlay {
          position: fixed;
          inset: 0;
          background: rgba(0, 0, 0, 0.75);
          z-index: 1000;
          display: flex;
          align-items: center;
          justify-content: center;
          animation: hubFadeIn 0.2s ease;
        }

        @keyframes hubFadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }

        .hub-modal {
          background: var(--bg-secondary);
          border-radius: 12px;
          padding: 24px;
          max-width: 90vw;
          max-height: 90vh;
          overflow-y: auto;
          border: 1px solid var(--border-color);
        }

        .hub-modal h3 {
          margin: 0 0 20px 0;
          color: var(--text-primary);
          font-size: 18px;
        }

        .hub-form-group {
          margin-bottom: 16px;
        }

        .hub-form-label {
          font-size: 12px;
          color: var(--text-secondary);
          display: block;
          margin-bottom: 8px;
        }

        .hub-form-input,
        .hub-form-select {
          width: 100%;
          padding: 10px 12px;
          background: var(--bg-primary);
          border: 1px solid var(--border-color);
          border-radius: 6px;
          color: var(--text-primary);
          font-size: 13px;
        }

        .hub-form-input:focus,
        .hub-form-select:focus {
          outline: none;
          border-color: var(--accent-primary);
        }

        .hub-form-hint {
          font-size: 11px;
          color: var(--text-secondary);
          margin-top: 6px;
        }

        .hub-status-message {
          margin-bottom: 16px;
          padding: 12px;
          border-radius: 6px;
          font-size: 13px;
        }

        .hub-status-message.info {
          background: rgba(0, 122, 204, 0.1);
          color: var(--accent-primary);
        }

        .hub-status-message.success {
          background: rgba(16, 185, 129, 0.1);
          color: var(--success-color);
        }

        .hub-status-message.error {
          background: rgba(239, 68, 68, 0.1);
          color: var(--error-color);
        }

        .hub-modal-actions {
          display: flex;
          justify-content: flex-end;
          gap: 8px;
          margin-top: 24px;
        }

        /* Merge Preview */
        .hub-merge-sources {
          display: flex;
          flex-wrap: wrap;
          gap: 8px;
          margin-bottom: 20px;
        }

        .hub-merge-source-tag {
          background: var(--bg-primary);
          padding: 8px 12px;
          border-radius: 6px;
          font-size: 13px;
          display: flex;
          align-items: center;
          gap: 8px;
          border: 1px solid var(--border-color);
        }

        .hub-merge-source-tag .nodes {
          opacity: 0.5;
          font-size: 11px;
        }

        .hub-merge-options {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 16px;
          margin-bottom: 20px;
        }

        .hub-merge-preview-box {
          background: var(--bg-primary);
          border-radius: 8px;
          padding: 16px;
          margin-bottom: 20px;
          border: 1px solid var(--border-color);
        }

        .hub-merge-preview-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 12px;
        }

        .hub-merge-preview-title {
          font-size: 12px;
          text-transform: uppercase;
          letter-spacing: 0.5px;
          color: var(--text-secondary);
          margin: 0;
        }

        .hub-merge-preview-stats {
          display: grid;
          grid-template-columns: repeat(3, 1fr);
          gap: 16px;
          margin-top: 12px;
        }

        .hub-merge-stat {
          text-align: center;
          padding: 12px;
          background: var(--bg-secondary);
          border-radius: 6px;
        }

        .hub-merge-stat-value {
          font-size: 24px;
          font-weight: 700;
        }

        .hub-merge-stat-label {
          font-size: 11px;
          color: var(--text-secondary);
          margin-top: 4px;
        }

        /* Responsive: Tablet and smaller (≤1200px) — two-row header */
        /* ============================================================
           HEADER RESPONSIVE — Tablet (≤1200px)
           ============================================================ */
        @media (max-width: 1200px) {
          .ide-header {
            flex-wrap: wrap;
            height: auto;
            padding: 6px 10px 0 10px;
            gap: 0;
          }

          /* Row 1: title + brain picker + actions */
          .ide-title {
            flex: 0 0 auto;
          }
          /* Hide subtitle on tablet */
          #modeDescription {
            display: none;
          }

          #brainPickerBtn {
            min-height: 44px;
            min-width: 44px;
            margin-left: 8px !important;
            font-size: 13px;
            padding: 8px 12px !important;
          }

          .header-actions {
            flex: 1 1 auto;
            justify-content: flex-end;
            gap: 2px;
          }

          /* Hide group labels */
          .header-group-label {
            display: none;
          }

          .header-group {
            padding: 0 3px;
            gap: 2px;
            border-right: none;
            height: 36px;
          }

          /* Hide less-essential buttons on tablet */
          /* CSV builder, upload replace, onlyoffice, keyboard shortcuts */
          .header-group > button[data-action="showCSVBuilder()"],
          .header-group > button[data-action="uploadReplacementFile()"],
          .header-group > button[data-action="openInOnlyOffice()"],
          .header-group > button[data-action="toggleKeyboardHelp()"] {
            display: none !important;
          }

          /* Ensure all header buttons are touch-sized */
          .header-group .btn,
          .header-group .btn-icon {
            min-height: 36px;
            min-width: 36px;
          }

          /* Row 2: nav tabs — full width, scrollable */
          .ide-header nav {
            order: 10;
            flex: 0 0 100%;
            width: 100%;
            margin-left: 0 !important;
            margin-right: 0;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            gap: 0 !important;
            padding: 0;
            border-top: 1px solid var(--border-color);
            margin-top: 6px;
          }
          .ide-header nav::-webkit-scrollbar { display: none; }

          /* Tab buttons — clean, no highlight artifacts */
          .tab-btn {
            padding: 0 16px;
            font-size: 13px;
            white-space: nowrap;
            min-height: 44px;
            height: 44px;
            flex-shrink: 0;
            border-bottom-width: 3px;
            outline: none !important;
            -webkit-tap-highlight-color: transparent !important;
            background: transparent !important;
          }
          .tab-btn:focus,
          .tab-btn:active,
          .tab-btn:focus-visible {
            outline: none !important;
            box-shadow: none !important;
            -webkit-tap-highlight-color: transparent !important;
          }
          /* Restore active state backgrounds */
          .tab-btn.active {
            background: transparent !important;
            border-bottom: 3px solid var(--accent-primary);
            color: var(--accent-primary);
          }
          .tab-btn.agent-ide-tab {
            background: rgba(0, 122, 204, 0.08) !important;
          }
          .tab-btn.agent-ide-tab.active {
            background: rgba(0, 122, 204, 0.15) !important;
            border-bottom-color: #00aaff;
          }
        }

        /* ============================================================
           HEADER RESPONSIVE — Small tablet / portrait (≤768px)
           ============================================================ */
        @media (max-width: 768px) {
          .ide-header {
            padding: 4px 8px 0 8px;
          }

          /* Hide brain name, show only emoji */
          #brainPickerLabel {
            display: none;
          }
          #brainPickerBtn {
            padding: 6px 10px !important;
            min-height: 40px;
          }

          /* Hide even more action buttons — keep only Save, AI, Settings */
          .header-group > button[data-action="createNewFile()"],
          .header-group > button[data-action="createNewFolder()"],
          .header-group > button[data-action="downloadCurrentFile()"],
          .header-group > button[data-action="toggleSearch()"],
          .header-group > button[data-action="togglePreview()"],
          .header-group > button[data-action="toggleSnapshotHistory()"],
          #save-all-btn {
            display: none !important;
          }

          /* Compact header groups */
          .header-group {
            padding: 0 2px;
            gap: 2px;
          }

          /* Tab buttons — icon only */
          .tab-btn {
            padding: 0 12px;
            font-size: 12px;
          }
          /* Hide text labels, show only icons */
          .tab-btn svg,
          .tab-btn span[style*="font-size: 14px"] {
            margin-right: 0;
          }
        }

        /* ============================================================
           TABLET / TOUCH RESPONSIVE — Panels & Content
           ============================================================ */

        /* --- Global touch optimizations (all tablets) --- */
        @media (max-width: 1200px) and (pointer: coarse),
               (max-width: 1200px) and (hover: none) {
          html, body {
            overscroll-behavior: none;
            -webkit-text-size-adjust: 100%;
          }

          /* Touch-friendly taps */
          button, .btn, .tab-btn, .file-item, .folder-item,
          .sidebar-header button, .ai-send-btn, #ai-send-btn,
          .brain-toggle, .breadcrumb-item, [onclick] {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
          }

          /* All scroll containers */
          .file-tree, .ai-chat-messages, .tabs-bar,
          .editor-wrapper, .explore-sidebar, .hub-sidebar,
          #chat-history-panel, .settings-panel {
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
          }

          /* Disable resize handles on touch — they don't work well */
          .resize-handle {
            display: none !important;
          }
        }

        /* --- Tablet Landscape (≤1200px): Narrower panels --- */
        @media (max-width: 1200px) {
          .sidebar {
            width: 200px !important;
            min-width: 0 !important;
          }

          .ai-panel {
            width: 280px !important;
            min-width: 0 !important;
          }

          /* File tree touch targets */
          .file-item, .folder-item {
            min-height: 40px;
            padding: 8px 12px 8px 8px;
            font-size: 14px;
          }

          .folder-chevron {
            width: 24px;
            min-width: 24px;
            font-size: 12px;
            text-align: center;
          }

          /* AI chat touch comfort */
          .ai-message.user {
            padding: 14px 16px;
          }

          #ai-input {
            font-size: 16px; /* Prevents iOS zoom on focus */
            min-height: 44px;
          }

          #ai-send-btn, .ai-send-btn {
            min-height: 44px;
            min-width: 44px;
            font-size: 15px;
            padding: 8px 20px !important;
            border-radius: 22px !important;
          }

          /* Editor tabs touch targets */
          .tabs-bar {
            height: 44px;
          }
          .tabs-bar .tab {
            min-height: 44px;
            padding: 0 14px;
            font-size: 13px;
          }
          .tabs-bar .tab .close-tab {
            width: 24px;
            height: 24px;
            font-size: 14px;
          }
        }

        /* --- Tablet Portrait (≤900px): Panel switcher mode --- */
        @media (max-width: 900px) {
          /* The ide-body becomes a stacking context for panel switching */
          .ide-body {
            position: relative;
          }

          /* Sidebar becomes a slide-out drawer */
          .sidebar {
            position: absolute !important;
            left: 0;
            top: 0;
            bottom: 0;
            width: 280px !important;
            max-width: 80vw !important;
            z-index: 500;
            transform: translateX(-100%);
            transition: transform 0.25s ease;
            box-shadow: none;
            border-right: 1px solid var(--border-color);
          }

          .sidebar.tablet-open {
            transform: translateX(0);
            box-shadow: 4px 0 24px rgba(0,0,0,0.4);
          }

          /* When sidebar is collapsed (desktop toggle), also ensure hidden */
          .sidebar.collapsed {
            transform: translateX(-100%) !important;
          }

          /* Override desktop collapsed styling so drawer can open */
          .sidebar.collapsed.tablet-open {
            width: 280px !important;
            min-width: 0 !important;
            overflow: visible;
            border-right: 1px solid var(--border-color);
            transform: translateX(0) !important;
            box-shadow: 4px 0 24px rgba(0,0,0,0.4);
          }
          .sidebar.collapsed.tablet-open * {
            opacity: 1;
            pointer-events: auto;
          }

          /* Backdrop for sidebar drawer */
          .tablet-sidebar-backdrop {
            display: none;
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.35);
            z-index: 499;
          }
          .tablet-sidebar-backdrop.visible {
            display: block;
          }

          /* Editor container takes full width */
          .editor-container {
            min-width: 0 !important;
            flex: 1 1 100% !important;
          }

          /* AI panel becomes a slide-up bottom sheet */
          .ai-panel {
            position: absolute !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            top: auto !important;
            width: 100% !important;
            max-width: 100% !important;
            height: 55vh;
            max-height: 70vh;
            z-index: 500;
            transform: translateY(100%);
            transition: transform 0.25s ease;
            border-left: none !important;
            border-top: 1px solid var(--border-color);
            border-radius: 12px 12px 0 0;
            box-shadow: none;
          }

          .ai-panel.tablet-open {
            transform: translateY(0);
            box-shadow: 0 -4px 24px rgba(0,0,0,0.4);
          }

          .ai-panel.hidden {
            display: flex !important; /* Override display:none — we use transform */
            transform: translateY(100%) !important;
          }
          .ai-panel.hidden.tablet-open {
            transform: translateY(0) !important;
          }

          /* Drag handle for bottom sheet */
          .ai-panel::before {
            content: '';
            display: block;
            width: 40px;
            height: 4px;
            background: var(--text-secondary);
            opacity: 0.4;
            border-radius: 2px;
            margin: 8px auto 4px;
            flex-shrink: 0;
          }

          /* Backdrop for AI panel */
          .tablet-ai-backdrop {
            display: none;
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.35);
            z-index: 499;
          }
          .tablet-ai-backdrop.visible {
            display: block;
          }

          /* Bottom tab bar for panel switching */
          .tablet-panel-bar {
            display: flex !important;
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 52px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
            z-index: 498;
            align-items: center;
            justify-content: space-around;
            padding-bottom: env(safe-area-inset-bottom, 0);
          }

          .tablet-panel-bar button {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 10px;
            font-weight: 600;
            padding: 6px 0;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 48px;
          }
          .tablet-panel-bar button.active {
            color: var(--accent-primary);
          }
          .tablet-panel-bar button svg {
            width: 22px;
            height: 22px;
          }

          /* Push ide-body content above the tab bar */
          .ide-body {
            padding-bottom: 52px;
          }

          /* Sidebar expand btn: override to be a tab-bar-based toggle */
          .sidebar-expand-btn {
            display: none !important;
          }

          /* File tree — bigger touch targets */
          .file-item, .folder-item {
            min-height: 44px;
            padding: 10px 12px 10px 8px;
            font-size: 15px;
          }

          .folder-chevron {
            width: 28px;
            min-width: 28px;
            font-size: 13px;
          }

          /* AI chat — virtual keyboard friendly */
          .ai-input-container {
            padding: 10px 12px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom, 0));
          }

          #ai-input {
            font-size: 16px;
            min-height: 44px;
          }

          #ai-send-btn, .ai-send-btn {
            min-height: 48px;
            min-width: 64px;
            font-size: 16px;
          }

          /* File names truncation */
          .file-item .file-name, .folder-item .folder-name {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 100%;
          }

          /* Search panel, settings panel, edit queue — full width on tablet portrait */
          .search-panel {
            width: 100% !important;
            max-width: 100% !important;
            right: 0 !important;
          }

          .settings-panel {
            width: 100% !important;
            max-width: 100% !important;
          }

          .edit-queue-panel {
            width: 100% !important;
            max-width: 100% !important;
          }
        }

        /* Hide the tablet panel bar on desktop */
        .tablet-panel-bar {
          display: none;
        }
        .tablet-sidebar-backdrop,
        .tablet-ai-backdrop {
          display: none;
        }

    </style>
    <link rel="stylesheet" href="css/ui-tokens.css">
    <link rel="stylesheet" href="css/ui-shell.css">
    <link rel="stylesheet" href="css/ui-components.css">
    <link rel="stylesheet" href="css/ui-responsive.css">
    <link rel="stylesheet" href="/vendor/xterm/css/xterm.css">
</head>
<body>
    <script>
        // Apply theme and embedded mode immediately based on URL params
        const _params = new URLSearchParams(window.location.search);
        if (_params.get('theme') === 'light') {
            document.body.classList.add('light-theme');
        }
        if (_params.get('embedded') === 'true') {
            document.body.classList.add('embedded');
            // In embedded mode, ensure files/Agent IDE tab is active after DOM loads
            document.addEventListener('DOMContentLoaded', () => {
                if (typeof switchBrainTab === 'function') {
                    switchBrainTab('files');
                }
            });
        }
    </script>
    <div class="ide-container">
        <!-- Header -->
        <div class="ide-header">
            <div class="ide-title">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="opacity: 0.9;">
                    <path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7z"/>
                    <path d="M9 21h6"/>
                    <path d="M10 17v4"/>
                    <path d="M14 17v4"/>
                    <circle cx="12" cy="9" r="2"/>
                </svg>
                <div style="display: flex; flex-direction: column;">
                    <span id="brainStudioTitle" style="line-height: 1.2;">Brain Studio</span>
                    <span id="modeDescription" style="font-size: 9px; color: var(--text-secondary); font-weight: 400; opacity: 0.8;">Action-oriented workspace</span>
                </div>
            </div>

            <!-- Brain Picker Button -->
            <button id="brainPickerBtn" data-action="toggleBrainPicker()" style="margin-left: 12px; padding: 4px 10px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); cursor: pointer; font-size: 11px; display: flex; align-items: center; gap: 5px; white-space: nowrap;" data-tooltip="Connect or switch brain" aria-label="Connect or switch brain">
                🧠 <span id="brainPickerLabel">No Brain</span>
            </button>

            <!-- BRAIN STUDIO TABS (Main App Modes) -->
            <nav style="display: flex; gap: 8px; margin-left: 32px; height: 100%; align-items: center;">
                <button class="tab-btn" data-tab="readme" data-action="switchBrainTab('readme')" data-tooltip="Documentation: View the platform README and guide.">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>
                    Docs
                </button>
                <button class="tab-btn" data-tab="query" data-action="switchBrainTab('query')" data-tooltip="Research Mode: Deep dive into memory, find evidence, and synthesize knowledge.">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/><path d="M11 8v6"/><path d="M8 11h6"/></svg>
                    Research
                </button>
                <button class="tab-btn active agent-ide-tab" data-tab="files" data-action="switchBrainTab('files')" data-tooltip="Agent IDE: Operation mode. Create files, write code, and execute tasks.">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>
                    Agent IDE
                </button>
                <button class="tab-btn" data-tab="explore" data-action="switchBrainTab('explore')" data-tooltip="Explore Mode: Visualize and navigate the knowledge graph.">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"/></svg>
                    Explore
                </button>
                <button class="tab-btn openclaw-tab" data-tab="openclaw" data-action="switchBrainTab('openclaw')" data-tooltip="OpenClaw: AI agent with memory and tools" style="display: none;">
                    <span style="font-size: 14px;">🐾</span>
                    <span class="openclaw-tab-name">OpenClaw</span>
                </button>
            </nav>
            
            <div class="header-actions">
                <!-- Group 1: File Operations -->
                <div class="header-group">
                    <span class="header-group-label">File</span>
                    <button class="btn btn-icon" data-action="createNewFile()" data-tooltip="New File (Cmd+N)" title="Create new file">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="12" y1="18" x2="12" y2="12"/><line x1="9" y1="15" x2="15" y2="15"/></svg>
                    </button>
                    <button class="btn btn-icon" data-action="createNewFolder()" data-tooltip="New Folder" title="Create new folder">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/><line x1="12" y1="11" x2="12" y2="17"/><line x1="9" y1="14" x2="15" y2="14"/></svg>
                    </button>
                    <button class="btn btn-icon low-frequency-action" data-action="showCSVBuilder()" data-tooltip="New CSV Table" title="Create CSV spreadsheet">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="3" y1="15" x2="21" y2="15"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="15" y1="3" x2="15" y2="21"/></svg>
                    </button>
                    <button class="btn btn-icon" data-action="downloadCurrentFile()" id="download-btn" disabled data-tooltip="Download File">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                    </button>
                    <button class="btn btn-icon low-frequency-action" data-action="uploadReplacementFile()" id="upload-replace-btn" disabled data-tooltip="Upload Replacement (Re-upload edited file)" title="Upload an edited version to replace this file" style="display: none;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                    </button>
                    <button class="btn low-frequency-action" data-action="openInOnlyOffice()" id="onlyoffice-edit-btn" disabled data-tooltip="Edit in OnlyOffice (Full WYSIWYG)" title="Enterprise-grade Office editor" style="display: none; gap: 4px;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                        Edit
                    </button>
                </div>

                <!-- Group 2: Editor Tools -->
                <div class="header-group">
                    <span class="header-group-label">Tools</span>
                    <button class="btn btn-icon" data-action="toggleSearch()" data-tooltip="Search (Cmd+F)">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
                    </button>
                    <button class="btn btn-icon" data-action="togglePreview()" id="preview-btn" data-tooltip="Toggle Preview" style="display: none;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                    </button>
                    <button class="btn btn-icon low-frequency-action" data-action="toggleSnapshotHistory()" data-tooltip="File History" id="snapshot-btn" disabled>
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                    </button>
                    <button class="btn active" data-action="toggleAI()" id="ai-btn" data-tooltip="AI Assistant (Cmd+K A)" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); margin-left: 4px; border-radius: 16px; padding: 4px 12px; height: 28px; display: flex; align-items: center; gap: 4px;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2z"/></svg>
                        AI
                    </button>
                    <button class="btn" data-action="toggleTerminalDock()" data-tooltip="Terminal (Cmd+J)" title="Toggle Terminal (Cmd+J)" style="display: flex; align-items: center; gap: 4px;">
                        <span aria-hidden="true">⌨</span>
                        Terminal
                    </button>
                </div>

                <!-- Group 3: Save Actions -->
                <div class="header-group">
                    <button class="btn" data-action="saveCurrentFile()" id="save-btn" disabled data-tooltip="Save (Cmd+S)" style="display: flex; align-items: center; gap: 4px;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>
                        Save
                    </button>
                    <button class="btn btn-secondary" data-action="saveAllFiles()" id="save-all-btn" disabled data-tooltip="Save All (Cmd+Shift+S)">Save All</button>
                </div>

                <!-- Group 4: System -->
                <div class="header-group">
                    <div class="header-overflow">
                        <button class="btn btn-icon" id="header-overflow-btn" data-action="toggleHeaderOverflow()" data-tooltip="More Actions" aria-haspopup="menu" aria-expanded="false">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="1.5"/><circle cx="19" cy="12" r="1.5"/><circle cx="5" cy="12" r="1.5"/></svg>
                        </button>
                        <div class="header-overflow-menu" id="header-overflow-menu" role="menu" aria-label="More actions">
                            <button class="overflow-item" data-action="showFolderBrowser()" role="menuitem">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6a2 2 0 0 1 2-2h5l2 2h7a2 2 0 0 1 2 2v2H3z"/><path d="M3 10h18v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/></svg>
                                Choose Folder
                            </button>
                            <button class="overflow-item" data-action="createNewFile()" role="menuitem">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"/><path d="M14 2v6h6"/><path d="M12 12v6"/><path d="M9 15h6"/></svg>
                                New File
                            </button>
                            <button class="overflow-item" data-action="createNewFolder()" role="menuitem">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/><path d="M12 11v6"/><path d="M9 14h6"/></svg>
                                New Folder
                            </button>
                            <button class="overflow-item" data-action="downloadCurrentFile()" role="menuitem">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><path d="m7 10 5 5 5-5"/><path d="M12 15V3"/></svg>
                                Download File
                            </button>
                            <button class="overflow-item" data-action="toggleSearch()" role="menuitem">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
                                Search
                            </button>
                            <button class="overflow-item" data-action="saveAllFiles()" role="menuitem">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5z"/><path d="M7 3v5h8"/><path d="M17 21v-8H7v8"/></svg>
                                Save All
                            </button>
                            <div class="overflow-divider" role="separator"></div>
                            <button class="overflow-item" data-action="showCSVBuilder()" role="menuitem">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18M3 15h18M9 3v18M15 3v18"/></svg>
                                New CSV Table
                            </button>
                            <button class="overflow-item" data-action="uploadReplacementFile()" role="menuitem">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><path d="M17 8l-5-5-5 5"/><path d="M12 3v12"/></svg>
                                Upload Replacement
                            </button>
                            <button class="overflow-item" data-action="openInOnlyOffice()" role="menuitem">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                                Edit in OnlyOffice
                            </button>
                            <button class="overflow-item" data-action="toggleSnapshotHistory()" role="menuitem">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                                File History
                            </button>
                            <button class="overflow-item" data-action="toggleKeyboardHelp()" role="menuitem">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="4" width="20" height="16" rx="2"/><path d="M6 8h.001M10 8h.001M14 8h.001M18 8h.001M6 12h.001M10 12h.001M14 12h.001M18 12h.001M8 16h8"/></svg>
                                Keyboard Shortcuts
                            </button>
                            <button class="overflow-item" data-action="toggleTerminalDock()" role="menuitem">
                                <span style="font-size: 14px; line-height: 1;">⌨</span>
                                Terminal (toggle)
                            </button>
                        </div>
                    </div>
                    <button class="btn btn-icon" data-action="toggleSettings()" data-tooltip="Settings">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
                    </button>
                    <button class="btn btn-icon low-frequency-action" data-action="toggleKeyboardHelp()" data-tooltip="Keyboard Shortcuts (?)">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="4" width="20" height="16" rx="2"/><path d="M6 8h.001M10 8h.001M14 8h.001M18 8h.001M6 12h.001M10 12h.001M14 12h.001M18 12h.001M8 16h8"/></svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Tab Panels Container -->
        <div class="brain-studio-tabs">
          <!-- Documentation Panel (README) -->
          <div id="readme-tab-panel" class="brain-tab-panel" style="display: none; flex-direction: column; overflow: hidden; background: var(--bg-primary);">
            <div style="padding: 24px 48px; overflow-y: auto; flex: 1; max-width: 1000px; margin: 0 auto; width: 100%;">
              <div id="readme-content" class="markdown-body">
                <div style="display: flex; justify-content: center; padding: 100px;">
                    <div class="ai-thinking-spinner"></div>
                </div>
              </div>
            </div>
          </div>

          <!-- Query Panel (hidden by default) -->
          <div id="query-tab-panel" class="brain-tab-panel" style="display: none; overflow-y: auto;">
            <!-- Will be populated by query-tab.js -->
          </div>
          
          <!-- Files Panel (IDE - active by default) -->
          <div id="files-tab-panel" class="brain-tab-panel" style="display: flex;">
            
        <!-- Body -->
        <div class="ide-body">
            <!-- Tablet: Sidebar backdrop -->
            <div class="tablet-sidebar-backdrop" id="tablet-sidebar-backdrop" data-action="closeTabletSidebar()"></div>
            <!-- Tablet: AI panel backdrop -->
            <div class="tablet-ai-backdrop" id="tablet-ai-backdrop" data-action="closeTabletAI()"></div>

            <!-- Sidebar Expand Button (visible when collapsed) -->
            <button class="sidebar-expand-btn" id="sidebar-expand-btn" data-action="toggleSidebar()" title="Show Sidebar" style="display: none;">
                ⏵
            </button>
            
            <!-- Sidebar -->
            <div class="sidebar" id="sidebar">
                <div class="resize-handle resize-handle-vertical" data-target="sidebar"></div>
                <div class="sidebar-header">
                    <span>FILES</span>
                    <div class="sidebar-actions" style="display: flex; gap: 4px;">
                        <button class="btn btn-icon" id="choose-folder-btn" data-action="showFolderBrowser()" data-tooltip="Choose Folder" style="background: none; padding: 4px 8px; font-size: 14px;" title="Open folder picker">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6a2 2 0 0 1 2-2h5l2 2h7a2 2 0 0 1 2 2v2H3z"/><path d="M3 10h18v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/></svg>
                        </button>
                        <button class="btn btn-icon" id="go-home-btn" data-action="goToHomeFolder()" data-tooltip="Working Folder" style="background: none; padding: 4px 8px; font-size: 14px;" title="Go to working folder">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 10.5 12 3l9 7.5"/><path d="M5 9.5V20h14V9.5"/></svg>
                        </button>
                        <button class="btn btn-icon" id="go-up-btn" data-action="goUpDirectory()" data-tooltip="Go Up" style="background: none; padding: 4px 8px; font-size: 14px;" title="Go to parent folder">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19V5"/><path d="m6 11 6-6 6 6"/></svg>
                        </button>
                        <button class="btn btn-icon" id="brain-folder-btn" data-action="toggleBrainFolder()" data-tooltip="Brain Folder" style="background: none; padding: 4px 8px; font-size: 14px; display: none;" title="Open connected brain folder">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.7"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7z"/><path d="M9 21h6"/></svg>
                        </button>
                        <button class="btn btn-icon" data-action="refreshFileTree()" data-tooltip="Refresh File Tree" style="background: none; padding: 4px 8px; font-size: 14px;" title="Refresh file tree">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12a9 9 0 1 1-3.95-7.45"/><path d="M21 3v7h-7"/></svg>
                        </button>
                        <button class="btn btn-icon" id="auto-refresh-btn" data-action="toggleAutoRefresh()" data-tooltip="Auto Refresh" style="background: none; padding: 4px 8px; font-size: 14px; opacity: 0.5;" title="Toggle auto-refresh (every 5s)">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="13" r="8"/><path d="M12 9v4l2.5 2.5"/><path d="M8 2h8"/></svg>
                        </button>
                        <button class="btn btn-icon" data-action="toggleSidebar()" data-tooltip="Hide Sidebar" style="background: none; padding: 4px 8px; font-size: 14px;">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m15 6-6 6 6 6"/></svg>
                        </button>
                    </div>
                </div>
                <div class="sidebar-path" id="sidebar-path" style="padding: 4px 12px; font-size: 10px; color: var(--text-secondary); border-bottom: 1px solid var(--border-color); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: pointer;" title="Click to navigate" data-action="showFolderBrowser()">
                    <!-- Current path shown here -->
                </div>
                <div class="file-tree" id="file-tree">
                    <!-- Populated by JavaScript -->
                </div>
            </div>

            <!-- Editor -->
            <div class="editor-container">
                <div class="tabs-bar" id="tabs-bar">
                    <!-- Tabs populated by JavaScript -->
                </div>
                
                <div class="breadcrumb-bar" id="breadcrumb-bar" style="height: 28px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); padding: 0 16px; display: none; align-items: center; font-size: 12px; color: var(--text-secondary); overflow-x: auto; white-space: nowrap;">
                    <!-- Breadcrumb populated by JavaScript -->
                </div>
                
                <div class="editor-split-container">
                    <div class="editor-pane">
                        <div class="editor-wrapper">
                            <div id="monaco-editor"></div>
                            <div id="monaco-diff-editor" class="hidden"></div>
                            <div class="loading-overlay" id="loading-overlay">
                                <span>🌌 Loading Monaco Editor...</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Markdown Preview Pane -->
                    <div class="preview-pane hidden" id="preview-pane">
                        <div class="resize-handle resize-handle-vertical" data-target="preview-pane"></div>
                        <div class="preview-header">
                            <span>📄 Preview</span>
                            <button data-action="togglePreview()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">×</button>
                        </div>
                        <div class="preview-content" id="preview-content">
                            <p style="color: var(--text-secondary);">Preview will appear here...</p>
                        </div>
                    </div>
                    
                        <!-- AI Chat Panel -->
                        <div class="ai-panel" id="ai-panel">
                            <div class="resize-handle resize-handle-vertical" data-target="ai-panel"></div>
                            <div class="ai-header">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span>AI Assistant</span>
                                </div>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <label class="brain-toggle" id="brainContextToggleLabel" title="Use loaded brain context in this AI chat. This does not load or switch brains.">
                                        <input type="checkbox" id="brainEnabled" checked>
                                        <span class="brain-toggle-label">Use Brain</span>
                                    </label>
                                    <label class="brain-toggle" id="pgsToggleLabel" title="Use PGS retrieval strategy for this chat when Brain context is enabled (slower, deeper).">
                                        <input type="checkbox" id="query-pgs" onchange="togglePGSControls()">
                                        <span class="brain-toggle-label">Use PGS</span>
                                    </label>
                                    <div id="pgs-controls" style="display:none; align-items:center; gap:6px;">
                                        <select id="query-pgs-mode" style="background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 2px 6px; font-size: 10px;">
                                            <option value="full" selected>full</option>
                                            <option value="continue">continue</option>
                                            <option value="targeted">targeted</option>
                                        </select>
                                        <input id="query-pgs-session" placeholder="session" value="default" style="width:90px; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 2px 6px; font-size: 10px;" />
                                    </div>
                                    <button class="btn-icon" id="history-toggle-btn" data-action="toggleChatHistory()" title="History">H</button>
                                    <button class="btn-icon" data-action="startNewChat()" title="New Chat">+</button>
                                    <button class="btn-icon" data-action="toggleAI()" title="Close">x</button>
                                </div>
                            </div>
                            <div id="ai-context-hint" style="padding: 6px 12px; border-bottom: 1px solid var(--border-color); background: var(--bg-secondary); font-size: 10px; color: var(--text-secondary);">
                                Load/Switch brain from the top <strong>Load Brain</strong> button. Toggles here only affect this chat request.
                            </div>
                            
                            <!-- Model Selector (Inline Style) -->
                            <div style="padding: 10px 12px; border-bottom: 1px solid var(--border-color); background: var(--bg-secondary); display: flex; align-items: center; justify-content: space-between;">
                                <span style="font-size: 10px; color: var(--text-secondary); font-weight: 700;">MODEL</span>
                                <select id="ai-model-select" style="background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 11px; outline: none; cursor: pointer;">
                                    <option value="claude-opus-4-6">Claude Opus 4.6</option>
                                    <option value="claude-sonnet-4-5">Claude Sonnet 4.5</option>
                                    <option value="claude-sonnet-5">Claude Sonnet 5</option>
                                    <option value="claude-opus-4-5">Claude Opus 4.5</option>
                                    <option value="gpt-5.2">GPT-5.2</option>
                                    <option value="gpt-5.3-codex">GPT-5.3-Codex</option>
                                    <option value="gpt-5.3-codex-spark">GPT-5.3-Codex-Spark</option>
                                    <option value="grok-code-fast-1">Grok (xAI)</option>
                                </select>
                            </div>
                            
                            <!-- Chat History Panel (Drawer-style) -->
                            <div id="chat-history-panel" class="hidden">
                                <div class="chat-history-header">
                                    <span style="font-size: 10px; font-weight: 700; color: var(--text-secondary);">CONVERSATIONS</span>
                                    <button onclick="chatHistory.clearDirectory()" style="background: none; border: none; color: var(--error-color); cursor: pointer; font-size: 10px; font-weight: 600;" title="Delete all history for this directory">
                                        Clear All
                                    </button>
                                </div>
                                <div id="chat-history-list" style="overflow-y: auto; flex: 1; min-height: 0;">
                                    <!-- Populated dynamically -->
                                </div>
                            </div>
                            
                            <div class="ai-chat-messages" id="ai-chat-messages">
                                <div style="padding: 40px 20px; text-align: center; color: var(--text-secondary); font-size: 13px; opacity: 0.6;">
                                    <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-bottom: 16px; opacity: 0.5;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
                                    <div>Ask me anything about your brain or documents.</div>
                                </div>
                            </div>
                            
                            <div class="ai-input-container">
                                <div class="ai-input-wrapper">
                                    <textarea id="ai-input" placeholder="Message AI Assistant..." onkeydown="handleAIInputKeydown(event)"></textarea>
                                    <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 4px;">
                                        <span style="font-size: 9px; color: var(--text-secondary); opacity: 0.5; padding-left: 4px;">Enter to send, Shift+Enter for new line</span>
                                        <div style="display: flex; gap: 8px;">
                                            <button class="btn btn-secondary" id="ai-stop-btn" onclick="stopAIRequest()" style="display: none; padding: 4px 12px; background: var(--error-color); color: white; border: none;">Stop</button>
                                            <button class="btn" id="ai-send-btn" onclick="sendAIMessage()" style="padding: 4px 16px; height: 28px; border-radius: 14px;">Send</button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Token Counter - Context Window Management -->
                            <div class="ai-token-counter" id="ai-token-counter">
                                <div class="token-display">
                                    <span id="token-count" class="token-count">0</span>
                                    <span>/ 200K tokens</span>
                                </div>
                                <div class="token-status-bar">
                                    <div id="token-status-fill" class="token-status-fill" data-status="green" style="width: 0%;"></div>
                                </div>
                                <button id="summarize-btn" class="summarize-btn" onclick="summarizeConversation()" title="Summarize older messages to reduce context">
                                    Summarize
                                </button>
                            </div>
                        </div>
                </div>
            </div>
        </div>

        <div class="terminal-dock hidden" id="terminal-dock">
            <div class="terminal-resize-handle" id="terminal-resize-handle"></div>
            <div class="terminal-header">
                <div class="terminal-tabs" id="terminal-tabs"></div>
                <div class="terminal-actions">
                    <button id="terminal-new-btn" title="New Terminal">+</button>
                    <button id="terminal-kill-btn" title="Kill Active Terminal">Kill</button>
                    <button id="terminal-toggle-btn" title="Hide Terminal">Hide</button>
                </div>
            </div>
            <div class="terminal-body" id="terminal-body">
                <div class="terminal-empty" id="terminal-empty">
                    No terminal session. Create one with + or Cmd+Shift+`
                </div>
            </div>
        </div>

          </div>
          <!-- End Files Tab Panel -->
          
          <!-- Explore Panel (hidden by default) -->
          <div id="explore-tab-panel" class="brain-tab-panel" style="display: none; overflow-y: auto;">
            <!-- Will be populated by explore-tab.js -->
          </div>
          
          <!-- OpenClaw Chat Panel (hidden by default) -->
          <div id="openclaw-tab-panel" class="brain-tab-panel" style="display: none; flex-direction: column; width: 100%; height: 100%; background: var(--bg-primary);">
            <div id="openclaw-messages" style="flex: 1; overflow-y: auto; padding: 16px; display: flex; flex-direction: column; gap: 12px;">
              <div style="color: var(--text-secondary); text-align: center; padding: 40px;">
                <span style="font-size: 48px;">🐾</span>
                <p style="margin-top: 16px;" id="openclaw-welcome-title">OpenClaw Agent</p>
                <p style="font-size: 12px; opacity: 0.7;">AI assistant with memory and tools</p>
              </div>
            </div>
            <div style="border-top: 1px solid var(--border-color); padding: 12px; display: flex; gap: 8px; background: var(--bg-secondary);">
              <input type="text" id="openclaw-input" placeholder="Ask OpenClaw..." 
                style="flex: 1; padding: 10px 14px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary); font-size: 14px;"
                onkeydown="if(event.key==='Enter' && !event.shiftKey) { event.preventDefault(); sendOpenclawMessage(); }">
              <button onclick="sendOpenclawMessage()" 
                style="padding: 10px 20px; border-radius: 8px; background: var(--accent-primary); color: white; border: none; cursor: pointer; font-weight: 500;">
                Send
              </button>
            </div>
          </div>
        </div>
        <!-- End Tab Panels Container -->

        <!-- Tablet: Bottom panel switcher bar -->
        <div class="tablet-panel-bar" id="tablet-panel-bar">
          <button id="tablet-btn-files" data-action="tabletShowPanel('files')" title="File Tree">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/></svg>
            Files
          </button>
          <button id="tablet-btn-editor" class="active" data-action="tabletShowPanel('editor')" title="Editor">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>
            Editor
          </button>
          <button id="tablet-btn-chat" data-action="tabletShowPanel('chat')" title="AI Chat">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z"/></svg>
            Chat
          </button>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-left">
                <span id="status-file">No file open</span>
                <span id="status-line">Ln 1, Col 1</span>
                <span id="status-selection"></span>
                <span id="status-dirty"></span>
            </div>
            <div class="status-right">
                <span id="status-edits" class="status-item" data-action="toggleEditQueue()" style="display:none; cursor:pointer; color: #3b82f6;" title="Click to open AI Edits panel"></span>
                <span id="status-size"></span>
                <span id="status-words"></span>
                <span id="status-lang">Plain Text</span>
                <span id="status-encoding">UTF-8</span>
            </div>
        </div>
    </div>

    <!-- Command Palette -->
    <div class="command-palette hidden" id="command-palette">
        <input type="text" id="command-input" placeholder="Type a command or search files (Cmd+Shift+P)..." />
        <div class="command-results" id="command-results"></div>
    </div>

    <!-- Search Panel -->
    <div class="search-panel hidden" id="search-panel">
        <div class="search-input-group">
            <input type="text" class="search-input" id="search-input" placeholder="Find..." />
        </div>
        <div class="search-input-group">
            <input type="text" class="search-input" id="replace-input" placeholder="Replace..." />
        </div>
        <div class="search-options">
            <label class="search-option">
                <input type="checkbox" id="search-case" />
                <span>Match Case</span>
            </label>
            <label class="search-option">
                <input type="checkbox" id="search-whole" />
                <span>Whole Word</span>
            </label>
            <label class="search-option">
                <input type="checkbox" id="search-regex" />
                <span>Regex</span>
            </label>
        </div>
        <div style="margin-top: 12px; display: flex; gap: 8px;">
            <button class="btn" onclick="findNext()" style="flex: 1;">Find Next</button>
            <button class="btn btn-secondary" onclick="replaceOne()" style="flex: 1;">Replace</button>
        </div>
        <div style="margin-top: 8px;">
            <button class="btn btn-secondary" onclick="replaceAll()" style="width: 100%;">Replace All</button>
        </div>
    </div>

    <!-- OnlyOffice Editor Modal -->
    <div id="onlyoffice-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000;">
        <div style="position: absolute; top: 10px; right: 10px; z-index: 10001;">
            <button onclick="closeOnlyOfficeEditor()" style="background: #ef4444; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600;">
                ✕ Close Editor
            </button>
        </div>
        <div id="onlyoffice-editor" style="width: 100%; height: 100%;"></div>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settings-panel">
        <div class="settings-header">
            <span>⚙️ Settings</span>
            <button onclick="toggleSettings()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">×</button>
        </div>
        <div class="settings-content">
            <div class="setting-group">
                <div class="setting-group-title">Editor</div>
                <div class="setting-item">
                    <label class="setting-label">Theme</label>
                    <select class="setting-input" id="setting-theme" onchange="applyTheme()">
                        <option value="vs">Light (default)</option>
                        <option value="vs-dark">Dark</option>
                        <option value="hc-black">High Contrast Dark</option>
                        <option value="hc-light">High Contrast Light</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label class="setting-label">Font Size</label>
                    <input type="number" class="setting-input" id="setting-font-size" value="14" min="10" max="24" onchange="applyFontSize()" />
                </div>
                <div class="setting-item">
                    <label class="setting-label">Tab Size</label>
                    <input type="number" class="setting-input" id="setting-tab-size" value="2" min="2" max="8" onchange="applyTabSize()" />
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-group-title">View</div>
                <div class="setting-item">
                    <label class="setting-checkbox">
                        <input type="checkbox" id="setting-minimap" checked onchange="applyMinimap()" />
                        <span>Show Minimap</span>
                    </label>
                </div>
                <div class="setting-item">
                    <label class="setting-checkbox">
                        <input type="checkbox" id="setting-line-numbers" checked onchange="applyLineNumbers()" />
                        <span>Show Line Numbers</span>
                    </label>
                </div>
                <div class="setting-item">
                    <label class="setting-checkbox">
                        <input type="checkbox" id="setting-word-wrap" checked onchange="applyWordWrap()" />
                        <span>Word Wrap</span>
                    </label>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-group-title">Auto-Save</div>
                <div class="setting-item">
                    <label class="setting-label">Auto-Save Mode</label>
                    <select class="setting-input" id="setting-auto-save" onchange="applyAutoSave()">
                        <option value="off">Off</option>
                        <option value="afterDelay">After Delay</option>
                        <option value="onFocusChange">On Focus Change</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label class="setting-label">Auto-Save Delay (ms)</label>
                    <input type="number" class="setting-input" id="setting-auto-save-delay" value="1000" min="500" max="5000" step="500" />
                </div>
            </div>
            <div style="margin-top: 24px;">
                <button class="btn" onclick="resetSettings()" style="width: 100%;">Reset to Defaults</button>
            </div>
        </div>
    </div>

    <!-- Keyboard Help -->
    <div class="keyboard-help hidden" id="keyboard-help">
        <div class="keyboard-help-header">
            <span>⌨️ Keyboard Shortcuts</span>
            <button onclick="toggleKeyboardHelp()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">×</button>
        </div>
        <div class="keyboard-help-content">
            <div class="shortcut-section">
                <div class="shortcut-section-title">File Operations</div>
                <div class="shortcut-item"><span>Save File</span><span class="shortcut-keys">Cmd+S / Ctrl+S</span></div>
                <div class="shortcut-item"><span>Save All Files</span><span class="shortcut-keys">Cmd+Shift+S</span></div>
                <div class="shortcut-item"><span>Close File</span><span class="shortcut-keys">Cmd+W / Ctrl+W</span></div>
            </div>
            <div class="shortcut-section">
                <div class="shortcut-section-title">Navigation</div>
                <div class="shortcut-item"><span>Command Palette</span><span class="shortcut-keys">Cmd+Shift+P</span></div>
                <div class="shortcut-item"><span>Quick Open File</span><span class="shortcut-keys">Cmd+P</span></div>
                <div class="shortcut-item"><span>Go to Line</span><span class="shortcut-keys">Cmd+G / Ctrl+G</span></div>
            </div>
            <div class="shortcut-section">
                <div class="shortcut-section-title">Editing</div>
                <div class="shortcut-item"><span>Find</span><span class="shortcut-keys">Cmd+F / Ctrl+F</span></div>
                <div class="shortcut-item"><span>Replace</span><span class="shortcut-keys">Cmd+H / Ctrl+H</span></div>
                <div class="shortcut-item"><span>Format Document</span><span class="shortcut-keys">Shift+Alt+F</span></div>
                <div class="shortcut-item"><span>Toggle Comment</span><span class="shortcut-keys">Cmd+/ / Ctrl+/</span></div>
            </div>
            <div class="shortcut-section">
                <div class="shortcut-section-title">View</div>
                <div class="shortcut-item"><span>Toggle Sidebar</span><span class="shortcut-keys">Cmd+B / Ctrl+B</span></div>
                <div class="shortcut-item"><span>Toggle Preview</span><span class="shortcut-keys">Cmd+K V</span></div>
                <div class="shortcut-item"><span>Toggle AI Assistant</span><span class="shortcut-keys">Cmd+K A</span></div>
                <div class="shortcut-item"><span>Settings</span><span class="shortcut-keys">Cmd+,</span></div>
            </div>
            <div class="shortcut-section">
                <div class="shortcut-section-title">AI Assistant</div>
                <div class="shortcut-item"><span>Send Message</span><span class="shortcut-keys">Cmd+Enter</span></div>
                <div class="shortcut-item"><span>Improve Selection</span><span class="shortcut-keys">Right-click → AI menu</span></div>
            </div>
            <div class="shortcut-section">
                <div class="shortcut-section-title">Help</div>
                <div class="shortcut-item"><span>Keyboard Shortcuts</span><span class="shortcut-keys">? / Cmd+K Cmd+S</span></div>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu hidden" id="context-menu">
        <!-- Populated dynamically -->
    </div>

    <!-- Overlay -->
    <div class="overlay hidden" id="overlay" onclick="closeAllModals()"></div>

    <!-- Folder Browser Modal -->
    <div class="keyboard-help hidden" id="folder-browser" style="width: 900px; max-width: 90vw;">
        <div class="keyboard-help-header">
            <span>Browse for Folder</span>
            <button onclick="closeFolderBrowser()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">×</button>
        </div>
        <div class="keyboard-help-content" style="padding: 0; max-height: 70vh;">
            <div style="padding: 12px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color);">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                    <button onclick="navigateUp()" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;">Up</button>
                    <button onclick="navigateToHome()" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;" title="Jump to working folder start">Working</button>
                    <div style="flex: 1; padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 12px; font-family: monospace; overflow-x: auto; white-space: nowrap;" id="current-path-display">
                        /Users
                    </div>
                </div>
                <div style="display: flex; gap: 8px;">
                    <input type="text" id="manual-path-input" placeholder="Or type path directly... (e.g., /path/to/folder)" 
                           style="flex: 1; padding: 8px 12px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 12px; font-family: monospace;"
                           onkeypress="if(event.key==='Enter') goToManualPath()">
                    <button onclick="goToManualPath()" class="btn" style="padding: 8px 16px; font-size: 12px;">Go</button>
                </div>
            </div>
            <div id="folder-list" style="padding: 12px; overflow-y: auto; max-height: calc(70vh - 120px);">
                <div style="text-align: center; color: var(--text-secondary); padding: 40px;">Loading...</div>
            </div>
            <div style="padding: 12px; background: var(--bg-secondary); border-top: 1px solid var(--border-color); display: flex; gap: 8px;">
                <button onclick="closeFolderBrowser()" class="btn btn-secondary" style="flex: 1;">Cancel</button>
                <button onclick="selectCurrentFolder()" class="btn" style="flex: 2;">✓ Open This Folder</button>
            </div>
        </div>
    </div>

    <!-- Edit Queue Panel (Cursor-style edit review) -->
    <div id="edit-queue-panel" class="edit-queue-panel hidden">
        <div class="edit-queue-header">
            <h3>AI Edits (<span id="edit-count">0</span>)</h3>
            <button onclick="toggleEditQueue()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">×</button>
        </div>
        
        <div class="edit-queue-actions">
            <button class="btn btn-primary" onclick="editQueue.acceptAll()" title="Accept all pending edits">
                ✓ Accept All
            </button>
            <button class="btn btn-secondary" onclick="editQueue.rejectAll()" title="Reject all pending edits">
                ✗ Reject All
            </button>
            <button class="btn btn-secondary" onclick="editQueue.clearProcessed()" title="Clear accepted/rejected edits">
                Clear
            </button>
        </div>
        
        <div id="edit-queue-list" class="edit-queue-list">
            <div style="text-align: center; color: var(--text-secondary); padding: 40px; font-size: 13px;">
                No pending edits
            </div>
        </div>
    </div>

    <!-- Snapshot History Panel -->
    <div id="snapshot-history-panel" class="edit-queue-panel hidden" style="width: 400px;">
        <div class="edit-queue-header">
            <h3>⏪ File History: <span id="snapshot-file-name">-</span></h3>
            <button onclick="toggleSnapshotHistory()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">×</button>
        </div>
        
        <div class="edit-queue-actions" style="padding: 12px; border-bottom: 1px solid var(--border-color);">
            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">
                Auto-snapshots created before AI edits
            </div>
            <button class="btn btn-secondary" onclick="clearAllSnapshots()" style="width: 100%; font-size: 12px;">
                🗑️ Clear All History
            </button>
        </div>
        
        <div id="snapshot-list" class="edit-queue-list">
            <div style="text-align: center; color: var(--text-secondary); padding: 40px; font-size: 13px;">
                No snapshots yet
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu hidden" id="context-menu">
        <!-- Populated dynamically -->
    </div>

    <!-- CSV Table Builder Modal -->
    <div class="keyboard-help hidden" id="csv-builder" style="width: 800px; max-width: 90vw;">
        <div class="keyboard-help-header">
            <span>Create CSV Table</span>
            <button onclick="closeCSVBuilder()" style="background: none; border: none; color: var(--text-primary); cursor: pointer; font-size: 18px;">×</button>
        </div>
        <div class="keyboard-help-content" style="padding: 20px;">
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600;">File Name:</label>
                <input type="text" id="csv-filename" value="data.csv" 
                       style="width: 100%; padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-family: monospace;">
            </div>
            
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600;">Table Size:</label>
                <div style="display: flex; gap: 12px;">
                    <div>
                        <label style="font-size: 12px; color: var(--text-secondary);">Rows:</label>
                        <input type="number" id="csv-rows" value="5" min="1" max="100" 
                               style="width: 80px; padding: 6px; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px;">
                    </div>
                    <div>
                        <label style="font-size: 12px; color: var(--text-secondary);">Columns:</label>
                        <input type="number" id="csv-cols" value="4" min="1" max="50" 
                               style="width: 80px; padding: 6px; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px;">
                    </div>
                    <button class="btn btn-secondary" onclick="generateCSVGrid()" style="margin-left: auto;">
                        Generate Grid
                    </button>
                </div>
            </div>
            
            <div style="margin-bottom: 16px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600;">Edit Table:</label>
                <div id="csv-grid" style="overflow: auto; max-height: 400px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-tertiary);">
                    <p style="text-align: center; padding: 40px; color: var(--text-secondary);">Click "Generate Grid" to start</p>
                </div>
            </div>
            
            <div style="display: flex; gap: 8px; justify-content: flex-end;">
                <button onclick="closeCSVBuilder()" class="btn btn-secondary">
                    Cancel
                </button>
                <button onclick="createCSVFile()" class="btn btn-primary">
                    Create CSV File
                </button>
            </div>
        </div>
    </div>

    <!-- Monaco Loader -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>

    <script>
        // ============================================================================
        // MARKDOWN & SYNTAX HIGHLIGHTING CONFIGURATION
        // ============================================================================
        
        // Configure marked.js with highlight.js for beautiful code rendering
        marked.setOptions({
            highlight: function(code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return hljs.highlight(code, { language: lang }).value;
                    } catch (err) {
                        return hljs.highlightAuto(code).value;
                    }
                }
                return hljs.highlightAuto(code).value;
            },
            breaks: true,
            gfm: true,
            headerIds: false,
            mangle: false
        });
        
        // ============================================================================
        // STATE MANAGEMENT
        // ============================================================================
        
        // Parse URL parameters
        const params = new URLSearchParams(window.location.search);
        let folderPath = params.get('path');
        let initialFileName = params.get('file');
        window.uiRefreshEnabled = false;

        const STORAGE_KEYS = {
            settings: 'evobrew-settings',
            layoutV2: 'evobrew.ui.layout.v2',
            shortcutsV2: 'evobrew.ui.shortcuts.v2',
            themeV2: 'evobrew.ui.theme.v2'
        };

        // Theme detection - supports ?theme=light or defaults based on preference
        const themeParam = params.get('theme');
        const isLightTheme = themeParam === 'light' ||
                            (!themeParam && window.matchMedia('(prefers-color-scheme: light)').matches);

        if (isLightTheme) {
            document.body.classList.add('light-theme');
            document.body.setAttribute('data-theme', 'light');
        }

        // Export theme for Monaco editor
        window.IDE_THEME = isLightTheme ? 'vs' : 'vs-dark';

        // Standalone mode - filesystem only
        const IDE_MODE = 'filesystem';
        const runName = null;
        const systemId = null;
        
        // Show folder picker on startup if no path
        if (!folderPath) {
            // Folder picker is now opened on-demand or if no brain is loaded
            // See main DOMContentLoaded handler for auto-loading logic
        }
        
        // FileAPI - filesystem only
        function getBrowseDepthForPath(pathValue) {
            if (!pathValue) return 2;
            if (pathValue === '/' || /^[A-Za-z]:\\\\?$/.test(pathValue)) return 2;
            const segments = pathValue.split('/').filter(Boolean);
            if (segments.length <= 1) return 3;
            return 8;
        }

        const FileAPI = {
            async listFiles() {
                const depth = getBrowseDepthForPath(folderPath);
                const query = new URLSearchParams({
                    path: folderPath,
                    depth: String(depth),
                    includeFiles: 'true'
                });
                const res = await fetch(`/api/folder/browse?${query.toString()}`);
                if (!res.ok) {
                    return { success: false, error: `HTTP ${res.status}: ${res.statusText}` };
                }
                return await res.json();
            },
            async readFile(filePath) {
                const res = await fetch(`/api/folder/read?path=${encodeURIComponent(filePath)}`);
                if (!res.ok) {
                    return { success: false, error: `HTTP ${res.status}: ${res.statusText}` };
                }
                return await res.json();
            },
            async writeFile(filePath, content) {
                // Use special endpoint for docx files - pass contentType for proper round-trip
                const isDocx = filePath.toLowerCase().endsWith('.docx');
                const endpoint = isDocx ? '/api/folder/write-docx' : '/api/folder/write';
                
                // For DOCX, include contentType so server knows how to handle it
                const body = { path: filePath, content };
                if (isDocx && window._docxContentType && window._docxContentType[filePath]) {
                    body.contentType = window._docxContentType[filePath];
                }
                
                const res = await fetch(endpoint, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                if (!res.ok) {
                    return { success: false, error: `HTTP ${res.status}: ${res.statusText}` };
                }
                return await res.json();
            },
            getDisplayName() {
                return folderPath ? folderPath.split('/').pop() || folderPath : 'Filesystem';
            }
        };
        
        /**
         * Resolve a path relative to the current working folder
         * Handles: relative paths (README.md), dot-relative (./src), and absolute paths
         * @param {string} inputPath - The path from AI tool commands
         * @returns {string} Absolute path ready for API calls
         */
        function resolvePathForAPI(inputPath) {
            if (!inputPath) return inputPath;
            
            // Get the current working folder based on IDE mode
            const currentFolder = IDE_MODE === 'filesystem' 
                ? folderPath 
                : (currentBrowsePath || '.');
            
            // Already absolute? Return as-is
            if (inputPath.startsWith('/')) {
                return inputPath;
            }
            
            // Handle . and ./ (current directory)
            if (inputPath === '.' || inputPath === './') {
                return currentFolder;
            }
            
            // Handle ./ prefix
            if (inputPath.startsWith('./')) {
                inputPath = inputPath.slice(2);
            }
            
            // Join with current folder
            // Simple join - avoid double slashes
            const base = currentFolder.endsWith('/') ? currentFolder.slice(0, -1) : currentFolder;
            return `${base}/${inputPath}`;
        }

        // Core state
        let editor = null;
        let openFiles = new Map();
        let activeFile = null;
        let allFiles = [];
        let availableSystems = [];
        let autoSaveTimer = null;
        let previewUpdateTimer = null;
        let selectedCommandIndex = 0;
        let pinnedTabs = new Set(); // Track pinned file paths
        let recentFiles = []; // Track recently opened files
        const MAX_RECENT_FILES = 20;
        
        // Settings
        const defaultSettings = {
            theme: 'vs',  // Default to light mode
            fontSize: 14,
            tabSize: 2,
            minimap: true,
            lineNumbers: true,
            wordWrap: true,
            autoSave: 'off',
            autoSaveDelay: 1000,
            shortcuts: {},
        };
        
        let settings = loadSettings();
        
        // Apply theme from settings on page load
        if (settings.theme === 'vs' || settings.theme === 'hc-light') {
            document.body.classList.add('light-theme');
            document.body.setAttribute('data-theme', 'light');
        } else {
            document.body.classList.remove('light-theme');
            document.body.setAttribute('data-theme', 'dark');
        }
        window.IDE_THEME = settings.theme;

        // ============================================================================
        // EDIT QUEUE MANAGER - Cursor-style edit review system
        // ============================================================================
        
        class EditQueueManager {
            constructor() {
                this.queue = [];
                this.onUpdate = null;
            }
            
            addEdit(filePath, original, modified) {
                const edit = {
                    id: `edit-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    filePath,
                    fileName: filePath.split('/').pop(),
                    originalContent: original,
                    modifiedContent: modified,
                    summary: this.generateSummary(original, modified),
                    status: 'pending',
                    timestamp: new Date().toISOString()
                };
                
                this.queue.push(edit);
                
                // Auto-open panel on first pending edit in this session
                if (this.getPending().length === 1) {
                    showEditQueue();
                    showToast('AI proposed edits – review in the AI Edits panel', 'success');
                }
                
                this.notify();
                return edit.id;
            }
            
            async acceptEdit(id) {
                const edit = this.queue.find(e => e.id === id);
                if (edit && edit.status === 'pending') {
                    edit.status = 'accepted';
                    await this.applyEdit(edit);
                    this.notify();
                }
            }
            
            rejectEdit(id) {
                const edit = this.queue.find(e => e.id === id);
                if (edit && edit.status === 'pending') {
                    edit.status = 'rejected';
                    this.notify();
                }
            }
            
            async acceptAll() {
                const pending = this.queue.filter(e => e.status === 'pending');
                for (const e of pending) {
                    await this.acceptEdit(e.id);
                }
            }
            
            rejectAll() {
                const pending = this.queue.filter(e => e.status === 'pending');
                pending.forEach(e => this.rejectEdit(e.id));
            }
            
            clearProcessed() {
                this.queue = this.queue.filter(e => e.status === 'pending');
                this.notify();
            }
            
            getPending() {
                return this.queue.filter(e => e.status === 'pending');
            }
            
            getAll() {
                return this.queue;
            }
            
            generateSummary(original, modified) {
                const origLines = original.split('\n').length;
                const modLines = modified.split('\n').length;
                const diff = modLines - origLines;
                if (diff > 0) return `+${diff} lines added`;
                if (diff < 0) return `${Math.abs(diff)} lines removed`;
                return 'Modified';
            }
            
            async applyEdit(edit) {
                try {
                    // Create snapshot before applying AI edit
                    console.log(`[SNAPSHOT] Creating snapshot before applying edit to ${edit.fileName}`);
                    await createSnapshot(edit.filePath, edit.originalContent, `Before AI edit: ${edit.summary}`);
                    
                    // Always save to disk first
                    const saveResult = await FileAPI.writeFile(edit.filePath, edit.modifiedContent);
                    if (!saveResult.success) {
                        showToast(`Failed to save ${edit.fileName}: ${saveResult.error}`, 'error');
                        return;
                    }

                    console.log(`[EDIT] ✓ Saved to disk: ${edit.filePath}`);

                    // Update in-memory model if file is open
                    const fileData = openFiles.get(edit.filePath);
                    if (fileData) {
                        fileData.model.setValue(edit.modifiedContent);
                        fileData.dirty = false;  // Already saved!
                        updateTabDirtyState(edit.filePath, false);
                        updateSaveButtons();
                    }

                    showToast(`✓ Saved: ${edit.fileName}`, 'success');
                    
                } catch (error) {
                    console.error(`[EDIT] Failed to apply edit:`, error);
                    showToast(`Failed to save ${edit.fileName}: ${error.message}`, 'error');
                }
            }
            
            notify() {
                if (this.onUpdate) {
                    this.onUpdate(this.queue);
                }
                updateEditQueueUI();
            }
        }
        
        // Global edit queue instance
        const editQueue = new EditQueueManager();
        
        /**
         * Add surgical edit to queue (from function calling)
         * Applies surgical edit markers to get full content, then queues for review
         */
        async function addToEditQueue(filePath, instructions, surgicalEditContent) {
            try {
                // Read current file content
                const result = await FileAPI.readFile(filePath);
                if (!result.success) {
                    console.error(`Cannot queue edit for ${filePath}: file not found`);
                    showToast(`Cannot edit ${filePath}: file not found`, 'error');
                    return;
                }
                
                const originalContent = result.content;
                
                // Apply surgical edit to get full modified content
                // Direct replacement (no surgical parsing - simpler, more reliable)
                const modifiedContent = surgicalEditContent;
                
                // Add to queue
                const editId = editQueue.addEdit(filePath, originalContent, modifiedContent);
                
                console.log(`[EDIT QUEUE] Added edit for ${filePath}: ${instructions}`);
                
            } catch (error) {
                console.error(`Error adding edit to queue:`, error);
                showToast(`Error queuing edit: ${error.message}`, 'error');
            }
        }
        
        // ============================================================================
        // CHAT HISTORY MANAGER - Directory-specific conversation persistence
        // ============================================================================
        
        class ChatHistoryManager {
            constructor() {
                this.currentConversationId = null;
                this.currentConversationData = null;
                this.allConversations = [];
                this.autoSaveTimeout = null;
            }
            
            getCurrentDirectory() {
                return IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
            }
            
            async loadConversationsFromServer() {
                try {
                    const response = await fetch('/api/conversations');

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    if (data.success) {
                        this.allConversations = data.conversations;
                        return this.allConversations;
                    }
                } catch (e) {
                    console.error('Failed to load conversations:', e);
                }
                return [];
            }
            
            startNewConversation() {
                this.currentConversationId = null;
                this.currentConversationData = {
                    id: null,
                    title: `Chat ${new Date().toLocaleString()}`,
                    timestamp: new Date().toISOString(),
                    folder: this.getCurrentDirectory(),
                    brainPath: window.currentBrainInfo?.brainPath || null,
                    messages: []
                };
                return this.currentConversationId;
            }
            
            async saveMessage(role, content, fileContext = null) {
                // Add to in-memory conversation
                if (!this.currentConversationData) {
                    this.startNewConversation();
                }
                
                this.currentConversationData.messages.push({ role, content, timestamp: new Date().toISOString() });
                
                // Auto-save after 2 seconds of inactivity (debounced)
                clearTimeout(this.autoSaveTimeout);
                this.autoSaveTimeout = setTimeout(() => this.autoSaveConversation(), 2000);
            }
            
            async autoSaveConversation() {
                if (!this.currentConversationData || this.currentConversationData.messages.length === 0) {
                    return;
                }
                
                try {
                    // Generate title from first message if new conversation
                    if (!this.currentConversationId) {
                        const firstUserMsg = this.currentConversationData.messages.find(m => m.role === 'user');
                        if (firstUserMsg) {
                            const preview = firstUserMsg.content.substring(0, 50);
                            this.currentConversationData.title = preview + (firstUserMsg.content.length > 50 ? '...' : '');
                        }
                    }
                    
                    const url = this.currentConversationId 
                        ? `/api/conversations/${this.currentConversationId}`
                        : '/api/conversations';
                    
                    const method = this.currentConversationId ? 'PUT' : 'POST';
                    
                    const response = await fetch(url, {
                        method,
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            title: this.currentConversationData.title,
                            messages: this.currentConversationData.messages,
                            folder: this.currentConversationData.folder,
                            brainPath: this.currentConversationData.brainPath,
                            summary: this.currentConversationData.summary || null
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    
                    if (data.success) {
                        if (!this.currentConversationId) {
                            this.currentConversationId = data.id || data.conversation.id;
                            this.currentConversationData.id = this.currentConversationId;
                        }
                        console.log('[CHAT] Auto-saved conversation:', this.currentConversationId);
                    }
                } catch (e) {
                    console.error('Failed to auto-save conversation:', e);
                }
            }
            
            async loadConversation(conversationId) {
                try {
                    const response = await fetch(`/api/conversations/${conversationId}`);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();

                    if (data.success) {
                        this.currentConversationId = conversationId;
                        this.currentConversationData = data.conversation;
                        return data.conversation;
                    }
                } catch (e) {
                    console.error('Failed to load conversation:', e);
                }
                return null;
            }
            
            getRecentConversations(directory = null) {
                const dir = directory || this.getCurrentDirectory();
                const currentBrainPath = window.currentBrainInfo?.brainPath;
                
                // Filter by directory if specified AND brainPath to prevent cross-contamination
                return this.allConversations
                    .filter(c => {
                        const dirMatch = !dir || c.folder === dir;
                        const brainMatch = !currentBrainPath || c.brainPath === currentBrainPath;
                        return dirMatch && brainMatch;
                    })
                    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            }
            
            async clearDirectory(directory = null) {
                const dir = directory || this.getCurrentDirectory();
                const conversations = this.getRecentConversations(dir);

                if (!confirm(`Delete all ${conversations.length} conversations for this folder?`)) {
                    return;
                }

                try {
                    for (const conv of conversations) {
                        const response = await fetch(`/api/conversations/${conv.id}`, { method: 'DELETE' });
                        if (!response.ok) {
                            console.warn(`Failed to delete conversation ${conv.id}: HTTP ${response.status}`);
                        }
                    }
                    await this.loadConversationsFromServer();
                    showToast('All conversations deleted', 'success');
                } catch (e) {
                    console.error('Failed to clear conversations:', e);
                    showToast('Error deleting conversations', 'error');
                }
            }

            // Update current conversation with latest messages and summary
            async updateCurrentConversation() {
                if (!this.currentConversationData) {
                    return;
                }

                // Sync in-memory messages with global state
                this.currentConversationData.messages = aiConversationHistory.map(m => ({
                    role: m.role,
                    content: m.content,
                    timestamp: m.timestamp || new Date().toISOString()
                }));

                // Store summary if exists
                this.currentConversationData.summary = conversationSummary || null;

                // Force immediate save
                await this.autoSaveConversation();
            }
        }
        
        // Global chat history manager
        const chatHistory = new ChatHistoryManager();
        
        // ============================================================================
        // DIFF AND PATH UTILITIES
        // ============================================================================
        
        /**
         * Simple line-based diff (no external dependencies)
         * Returns array of {type: 'add'|'remove'|'same', line: string, oldIndex, newIndex}
         */
        function computeLineDiff(oldText, newText) {
            const oldLines = oldText.split('\n');
            const newLines = newText.split('\n');
            const diffs = [];
            let i = 0, j = 0;

            while (i < oldLines.length || j < newLines.length) {
                const oldLine = oldLines[i];
                const newLine = newLines[j];

                if (oldLine === undefined) {
                    diffs.push({ type: 'add', line: newLine, oldIndex: null, newIndex: j });
                    j++;
                } else if (newLine === undefined) {
                    diffs.push({ type: 'remove', line: oldLine, oldIndex: i, newIndex: null });
                    i++;
                } else if (oldLine === newLine) {
                    diffs.push({ type: 'same', line: oldLine, oldIndex: i, newIndex: j });
                    i++; j++;
                } else {
                    // Treat as remove + add (simple approach)
                    diffs.push({ type: 'remove', line: oldLine, oldIndex: i, newIndex: null });
                    diffs.push({ type: 'add', line: newLine, oldIndex: null, newIndex: j });
                    i++; j++;
                }
            }

            return diffs;
        }
        
        /**
         * Normalize relative paths like ./ and ../ against a base path
         * Handles both absolute and relative paths safely
         */
        function normalizePath(base, relative) {
            if (relative.startsWith('/')) return relative;

            const stack = base.split('/').filter(Boolean);
            const parts = relative.split('/');

            // If base ends with a file (has a dot), drop it
            if (stack.length && stack[stack.length - 1].includes('.')) {
                stack.pop();
            }

            for (const part of parts) {
                if (!part || part === '.') continue;
                if (part === '..') {
                    stack.pop();
                } else {
                    stack.push(part);
                }
            }

            return '/' + stack.join('/');
        }
        

        /**
         * Apply surgical edit (Cursor-style) - FAST edits with only changed sections
         * Parses // ... existing code ... markers and applies only the changes
         */


/**
 * Cursor-Style Surgical Edit Parser (Enterprise-Grade)
 * 
 * Based on Cursor's edit_file tool specification:
 * - Parses // ... existing code ... markers
 * - Uses context lines to find exact positions
 * - Handles multiple edits in sequence
 * - Robust matching with context validation
 */
        function applySurgicalEdit(originalContent, editContent) {
            // Check for surgical edit markers
            const markerPattern = /(?:\/\/|#|<!--|--)\s*\.\.\.\s*existing code\s*\.\.\.(?:\s*-->)?/gi;
            if (!markerPattern.test(editContent)) {
                // No markers - treat as full file replacement
                return editContent;
            }
    
            console.log('[SURGICAL EDIT] Parsing Cursor-style surgical edit...');
    
            // Extract INSTRUCTIONS if present (first line starting with INSTRUCTIONS:)
            let instructions = '';
            let codeContent = editContent;
            const instructionsMatch = editContent.match(/^INSTRUCTIONS:\s*(.+?)$/m);
            if (instructionsMatch) {
                instructions = instructionsMatch[1];
                codeContent = editContent.replace(/^INSTRUCTIONS:.*?$\n*/m, '');
                console.log(`[SURGICAL EDIT] Instructions: ${instructions}`);
            }
    
            // Split into sections by the markers
            // Use a more flexible regex that captures different comment styles
            const markerRegex = /(?:\/\/|#|<!--|\/\*)\s*\.\.\.\s*existing code\s*\.\.\.\s*(?:-->|\*\/)?/gi;
            const parts = codeContent.split(markerRegex);
    
            // parts[0] might be empty or have leading content
            // parts[1], parts[3], parts[5]... are the changed sections (between markers)
            // The pattern is: [optional prefix] MARKER [change1] MARKER [change2] MARKER [optional suffix]
    
            const changedBlocks = [];
            for (let i = 0; i < parts.length; i++) {
                const part = parts[i].trim();
                if (part) {
                    changedBlocks.push({
                        content: part,
                        index: i
                    });
                }
            }
    
            if (changedBlocks.length === 0) {
                console.warn('[SURGICAL EDIT] No content blocks found');
                return editContent;
            }
    
            console.log(`[SURGICAL EDIT] Processing ${changedBlocks.length} change blocks`);
    
            // Build the result by applying each change in order
            const originalLines = originalContent.split('\n');
            let result = [...originalLines];
            let offsetAdjustment = 0; // Track line number shifts from previous edits
    
            for (const block of changedBlocks) {
                const blockLines = block.content.split('\n');
        
                // Find context lines (lines that should exist in original to anchor this change)
                // Look for lines with actual code (not just comments or whitespace)
                const contextLines = blockLines.filter(line => {
                    const trimmed = line.trim();
                    return trimmed && 
                           !trimmed.startsWith('//') && 
                           !trimmed.startsWith('#') && 
                           !trimmed.startsWith('*') &&
                           !trimmed.startsWith('/*');
                });
        
                if (contextLines.length === 0) {
                    console.warn('[SURGICAL EDIT] Block has no significant lines - skipping');
                    continue;
                }
        
                // Use first significant line as anchor to find position
                const anchorLine = contextLines[0].trim();
                const searchLength = Math.min(anchorLine.length, 50);
                const searchStr = anchorLine.substring(0, searchLength);
        
                // Find this line in the original (accounting for offset from previous edits)
                let foundAt = -1;
                for (let i = offsetAdjustment; i < result.length; i++) {
                    if (result[i].trim().includes(searchStr)) {
                        foundAt = i;
                        console.log(`[SURGICAL EDIT] Found anchor at line ${foundAt + 1}: "${searchStr.substring(0, 30)}..."`);
                        break;
                    }
                }
        
                if (foundAt === -1) {
                    console.warn(`[SURGICAL EDIT] Could not find anchor: "${searchStr.substring(0, 30)}..."`);
                    // Fallback: append at end
                    result.push('', ...blockLines);
                    continue;
                }
        
                // Determine how many lines this edit replaces
                // This is tricky - we need to figure out the span of the original code this edit covers
                // For now, use a heuristic: same number of lines as the block
                const linesToReplace = blockLines.length;
        
                // Apply the edit
                result.splice(foundAt, linesToReplace, ...blockLines);
        
                // Adjust offset for next iteration
                offsetAdjustment = foundAt + blockLines.length;
        
                console.log(`[SURGICAL EDIT] Replaced ${linesToReplace} lines at position ${foundAt + 1}`);
            }
    
            const finalContent = result.join('\n');
            console.log(`[SURGICAL EDIT] Complete - ${originalLines.length} → ${result.length} lines`);
    
            return finalContent;
        }

        // ============================================================================
        // EDIT QUEUE UI FUNCTIONS
        // ============================================================================
        
        function toggleEditQueue() {
            const panel = document.getElementById('edit-queue-panel');
            panel.classList.toggle('hidden');
        }
        
        function showEditQueue() {
            const panel = document.getElementById('edit-queue-panel');
            panel.classList.remove('hidden');
        }
        
        function hideEditQueue() {
            const panel = document.getElementById('edit-queue-panel');
            panel.classList.add('hidden');
        }
        
        function updateEditQueueUI() {
            const queue = editQueue.getAll();
            const pending = editQueue.getPending();
            const countEl = document.getElementById('edit-count');
            const listEl = document.getElementById('edit-queue-list');
            
            // Update count
            countEl.textContent = pending.length;
            
            // Update list
            if (queue.length === 0) {
                listEl.innerHTML = `
                    <div style="text-align: center; color: var(--text-secondary); padding: 40px; font-size: 13px;">
                        No pending edits
                    </div>
                `;
                return;
            }
            
            listEl.innerHTML = queue.map(edit => `
                <div class="edit-item ${edit.status}" data-edit-id="${edit.id}">
                    <div class="edit-item-header">
                        <div class="edit-item-file" title="${edit.filePath}">${edit.fileName}</div>
                        <span class="edit-item-status ${edit.status}">${edit.status}</span>
                    </div>
                    <div class="edit-item-summary">${edit.summary}</div>
                    <div class="edit-item-actions">
                        <button class="btn btn-secondary" onclick="viewEditDiff('${edit.id}')" title="View changes">
                            👁️ View
                        </button>
                        <button class="btn btn-primary" onclick="editQueue.acceptEdit('${edit.id}')" title="Accept this edit">
                            ✓
                        </button>
                        <button class="btn btn-secondary" onclick="editQueue.rejectEdit('${edit.id}')" title="Reject this edit">
                            ✗
                        </button>
                    </div>
                </div>
            `).join('');
            
            // Update status bar indicator
            const statusEdits = document.getElementById('status-edits');
            if (statusEdits) {
                if (pending.length > 0) {
                    statusEdits.style.display = 'inline';
                    statusEdits.textContent = `AI Edits: ${pending.length}`;
                } else {
                    statusEdits.style.display = 'none';
                    statusEdits.textContent = '';
                }
            }
        }
        
        async function viewEditDiff(editId) {
            const edit = editQueue.getAll().find(e => e.id === editId);
            if (!edit) return;
            
            // Open file if not already open
            if (!openFiles.has(edit.filePath)) {
                const fileName = edit.fileName;
                try {
                    // Wait for file to open before showing diff
                    await openFile(edit.filePath, fileName);
                } catch (err) {
                    console.error('Could not open file:', err);
                    showToast('Could not open file for diff view', 'error');
                    return; // Don't show diff if file couldn't be opened
                }
            }
            
            // Show diff using existing modal (now that file is loaded)
            showDiffPreview(edit.originalContent, edit.modifiedContent, () => {
                editQueue.acceptEdit(editId);
            });
        }

        // ============================================================================
        // SNAPSHOT HISTORY
        // ============================================================================

        async function toggleSnapshotHistory() {
            const panel = document.getElementById('snapshot-history-panel');
            const isHidden = panel.classList.contains('hidden');
            
            if (isHidden) {
                // Show panel
                panel.classList.remove('hidden');
                await loadSnapshotHistory();
            } else {
                // Hide panel
                panel.classList.add('hidden');
            }
        }

        async function loadSnapshotHistory() {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) {
                showToast('No file open', 'error');
                return;
            }
            
            const filePath = activeFile;
            const fileName = fileData.name;
            
            // Update panel title
            document.getElementById('snapshot-file-name').textContent = fileName;
            
            try {
                const response = await fetch(`/api/snapshots?filePath=${encodeURIComponent(filePath)}`);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (!data.success) {
                    showToast('Failed to load snapshots', 'error');
                    return;
                }

                renderSnapshotList(data.snapshots);
            } catch (error) {
                console.error('Error loading snapshots:', error);
                showToast('Error loading file history', 'error');
            }
        }

        function renderSnapshotList(snapshots) {
            const listEl = document.getElementById('snapshot-list');
            
            if (!snapshots || snapshots.length === 0) {
                listEl.innerHTML = `
                    <div style="text-align: center; color: var(--text-secondary); padding: 40px; font-size: 13px;">
                        No snapshots yet<br>
                        <span style="font-size: 11px; margin-top: 8px; display: block;">Snapshots are created automatically before AI edits</span>
                    </div>
                `;
                return;
            }
            
            let html = '';
            for (const snapshot of snapshots) {
                const date = new Date(snapshot.timestamp);
                const timeAgo = getTimeAgo(date);
                const sizeKB = Math.round(snapshot.size / 1024);
                
                html += `
                    <div class="edit-item" style="padding: 12px; border-bottom: 1px solid var(--border-color);">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                            <div style="flex: 1; min-width: 0;">
                                <div style="font-size: 12px; font-weight: 500; color: var(--text-primary); margin-bottom: 4px;">
                                    ${escapeHtml(snapshot.reason)}
                                </div>
                                <div style="font-size: 11px; color: var(--text-secondary);">
                                    ${timeAgo} • ${sizeKB} KB
                                </div>
                            </div>
                        </div>
                        <div class="edit-item-actions" style="display: flex; gap: 8px; margin-top: 8px;">
                            <button class="btn btn-secondary" onclick="viewSnapshotDiff('${snapshot.id}')" title="View changes" style="flex: 1; font-size: 11px;">
                                👁️ View
                            </button>
                            <button class="btn btn-primary" onclick="restoreSnapshot('${snapshot.id}')" title="Restore this version" style="flex: 1; font-size: 11px;">
                                ↩️ Restore
                            </button>
                            <button class="btn btn-secondary" onclick="deleteSnapshot('${snapshot.id}')" title="Delete snapshot" style="padding: 4px 8px; font-size: 11px;">
                                🗑️
                            </button>
                        </div>
                    </div>
                `;
            }
            
            listEl.innerHTML = html;
        }

        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            if (seconds < 60) return 'Just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
            return date.toLocaleDateString();
        }

        async function createSnapshot(filePath, content, reason = 'Manual snapshot') {
            try {
                const response = await fetch('/api/snapshots', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filePath, content, reason })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (data.success) {
                    console.log(`[SNAPSHOT] Created: ${reason}`);
                    return data.id;
                } else {
                    console.error('[SNAPSHOT] Failed:', data.error);
                    return null;
                }
            } catch (error) {
                console.error('[SNAPSHOT] Error:', error);
                return null;
            }
        }

        async function viewSnapshotDiff(snapshotId) {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) return;

            try {
                const response = await fetch(`/api/snapshots/${snapshotId}?filePath=${encodeURIComponent(activeFile)}`);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (!data.success) {
                    showToast('Failed to load snapshot', 'error');
                    return;
                }

                const currentContent = fileData.model.getValue();
                const snapshotContent = data.snapshot.content;

                showDiffPreview(snapshotContent, currentContent, () => {
                    restoreSnapshot(snapshotId);
                }, 'Snapshot vs Current');
            } catch (error) {
                console.error('Error viewing snapshot:', error);
                showToast('Error loading snapshot', 'error');
            }
        }

        async function restoreSnapshot(snapshotId) {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) return;

            if (!confirm('Restore this version? Current changes will be replaced.')) {
                return;
            }

            try {
                const response = await fetch(`/api/snapshots/${snapshotId}?filePath=${encodeURIComponent(activeFile)}`);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (!data.success) {
                    showToast('Failed to load snapshot', 'error');
                    return;
                }

                // Create a snapshot of current state before restoring
                await createSnapshot(activeFile, fileData.model.getValue(), 'Before restore');

                // Restore the snapshot content
                fileData.model.setValue(data.snapshot.content);
                markFileAsModified(activeFile);

                showToast(`Restored from ${new Date(data.snapshot.timestamp).toLocaleString()}`, 'success');

                // Refresh snapshot list
                await loadSnapshotHistory();
            } catch (error) {
                console.error('Error restoring snapshot:', error);
                showToast('Error restoring snapshot', 'error');
            }
        }

        async function deleteSnapshot(snapshotId) {
            if (!confirm('Delete this snapshot?')) {
                return;
            }

            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) return;

            try {
                const response = await fetch(`/api/snapshots/${snapshotId}?filePath=${encodeURIComponent(activeFile)}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (data.success) {
                    showToast('Snapshot deleted', 'success');
                    await loadSnapshotHistory();
                } else {
                    showToast('Failed to delete snapshot', 'error');
                }
            } catch (error) {
                console.error('Error deleting snapshot:', error);
                showToast('Error deleting snapshot', 'error');
            }
        }

        async function clearAllSnapshots() {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) return;

            if (!confirm('Delete all snapshots for this file?')) {
                return;
            }

            try {
                const response = await fetch(`/api/snapshots?filePath=${encodeURIComponent(activeFile)}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (data.success) {
                    showToast('All snapshots cleared', 'success');
                    await loadSnapshotHistory();
                } else {
                    showToast('Failed to clear snapshots', 'error');
                }
            } catch (error) {
                console.error('Error clearing snapshots:', error);
                showToast('Error clearing snapshots', 'error');
            }
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        // Start a new conversation on load
        chatHistory.startNewConversation();
        
        if (IDE_MODE === 'picker') {
            showSystemPickerModal();
        } else {
            initializeMonaco();
        }

        // ============================================================================
        // SYSTEM PICKER
        // ============================================================================
        
        async function showSystemPickerModal() {
            try {
                const response = await fetch('/api/compiled-docs/all');
                const data = await response.json();
                
                if (!data.success || data.systems.length === 0) {
                    document.getElementById('loading-overlay').innerHTML = `
                        <div style="text-align: center;">
                            <div style="font-size: 18px; margin-bottom: 12px;">No Compiled Systems Yet</div>
                            <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 20px;">
                                Compile your first system from the Query tab in Intelligence.
                            </div>
                            <a href="/intelligence" 
                               style="background: #0e639c; color: white; padding: 10px 20px; border-radius: 6px; text-decoration: none; font-size: 13px;">
                                Go to Intelligence Dashboard
                            </a>
                        </div>
                    `;
                    return;
                }
                
                let html = `
                    <div style="text-align: center; max-width: 500px;">
                        <div style="font-size: 18px; margin-bottom: 8px; color: var(--text-primary);">Select Documentation System</div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 20px;">
                            ${data.systems.length} compiled ${data.systems.length === 1 ? 'system' : 'systems'} available
                        </div>
                        <select id="initial-system-picker" 
                                style="width: 100%; padding: 10px; background: var(--border-color); border: 1px solid #5a5a5a; color: var(--text-primary); border-radius: 4px; font-size: 13px; margin-bottom: 16px;">
                `;
                
                const byRun = {};
                data.systems.forEach(sys => {
                    if (!byRun[sys.runName]) byRun[sys.runName] = [];
                    byRun[sys.runName].push(sys);
                });
                
                for (const [run, systems] of Object.entries(byRun)) {
                    html += `<optgroup label="${run}">`;
                    systems.forEach(sys => {
                        const label = `${sys.systemId} (${sys.mdFiles} docs, ${sys.queryCount || 0} queries)`;
                        html += `<option value="${sys.runName}:${sys.systemId}">${label}</option>`;
                    });
                    html += `</optgroup>`;
                }
                
                html += `
                        </select>
                        <button onclick="loadSelectedSystem()" 
                                style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 10px 24px; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
                            Open Compiled Docs
                        </button>
                        <div style="margin: 20px 0; text-align: center; color: var(--text-secondary); font-size: 12px;">
                            ─────── OR ───────
                        </div>
                        <button onclick="showFolderBrowser()" 
                                style="width: 100%; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 12px 24px; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;">
                            Browse for Folder...
                        </button>
                    </div>
                `;
                
                document.getElementById('loading-overlay').innerHTML = html;
                
            } catch (error) {
                document.getElementById('loading-overlay').innerHTML = `
                    <div style="color: var(--error-color);">Failed to load systems: ${error.message}</div>
                `;
            }
        }
        
        function loadSelectedSystem() {
            const picker = document.getElementById('initial-system-picker');
            const value = picker.value;
            if (!value) return;
            const [run, system] = value.split(':');
            window.location.href = `/docs-ide?run=${run}&system=${system}`;
        }

        function goBackToPicker() {
            // Go back to picker screen
            window.location.href = '/docs-ide';
        }

        // ============================================================================
        // MONACO EDITOR INITIALIZATION
        // ============================================================================
        
        function initializeMonaco() {
            loadAvailableSystems();
            
            require.config({ 
                paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' } 
            });

            require(['vs/editor/editor.main'], async function() {
                console.log('Monaco Editor loaded');

                // Create editor instance
                editor = monaco.editor.create(document.getElementById('monaco-editor'), {
                    theme: settings.theme,
                    fontSize: settings.fontSize,
                    lineNumbers: settings.lineNumbers ? 'on' : 'off',
                    minimap: { enabled: settings.minimap },
                    scrollBeyondLastLine: false,
                    wordWrap: settings.wordWrap ? 'on' : 'off',
                    automaticLayout: true,
                    renderWhitespace: 'selection',
                    tabSize: settings.tabSize,
                    insertSpaces: true,
                    folding: true,
                    lineDecorationsWidth: 10,
                    lineNumbersMinChars: 4,
                    glyphMargin: false,
                    overviewRulerBorder: false,
                    hideCursorInOverviewRuler: true,
                    find: {
                        seedSearchStringFromSelection: 'always',
                        autoFindInSelection: 'never'
                    }
                });

                // Event handlers
                editor.onDidChangeCursorPosition((e) => {
                    document.getElementById('status-line').textContent = 
                        `Ln ${e.position.lineNumber}, Col ${e.position.column}`;
                    updateSelectionInfo();
                });

                editor.onDidChangeCursorSelection(() => {
                    updateSelectionInfo();
                });

                editor.onDidChangeModelContent(() => {
                    if (activeFile) {
                        const fileData = openFiles.get(activeFile);
                        if (fileData && !fileData.dirty) {
                            fileData.dirty = true;
                            updateTabDirtyState(activeFile, true);
                            updateSaveButtons();
                        }
                        updateFileStats();
                        schedulePreviewUpdate();
                    }
                });

                // Add context menu actions for AI
                editor.addAction({
                    id: 'ai-improve-selection',
                    label: '🤖 AI: Improve Selection',
                    contextMenuGroupId: 'ai',
                    contextMenuOrder: 1,
                    run: async function(ed) {
                        const selection = ed.getSelection();
                        if (selection && !selection.isEmpty()) {
                            // Open AI panel if closed
                            const aiPanel = document.getElementById('ai-panel');
                            if (aiPanel.classList.contains('hidden')) {
                                toggleAI();
                            }
                            // Set quick action
                            await aiQuickAction('improve');
                        }
                    }
                });

                editor.addAction({
                    id: 'ai-fix-grammar',
                    label: '✓ AI: Check Grammar',
                    contextMenuGroupId: 'ai',
                    contextMenuOrder: 2,
                    run: async function(ed) {
                        const aiPanel = document.getElementById('ai-panel');
                        if (aiPanel.classList.contains('hidden')) {
                            toggleAI();
                        }
                        await aiQuickAction('grammar');
                    }
                });

                editor.addAction({
                    id: 'ai-custom',
                    label: '💬 Ask AI About This...',
                    contextMenuGroupId: 'ai',
                    contextMenuOrder: 3,
                    run: function(ed) {
                        const aiPanel = document.getElementById('ai-panel');
                        if (aiPanel.classList.contains('hidden')) {
                            toggleAI();
                        }
                        document.getElementById('ai-input').focus();
                    }
                });

                // Keyboard shortcuts
                setupKeyboardShortcuts();

                // Hide loading overlay
                document.getElementById('loading-overlay').classList.add('hidden');

                // Load file tree (skip in picker mode)
                if (IDE_MODE !== 'picker') {
                await loadFileTree();
                }
                
                // Restore workspace state
                restoreWorkspaceState();
            });
        }

        // ============================================================================
        // KEYBOARD SHORTCUTS
        // ============================================================================
        
        function setupKeyboardShortcuts() {
            if (window.uiRefreshEnabled === false) {
                // Save
                editor.addCommand(
                    monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_S,
                    () => saveCurrentFile()
                );

                // Save All
                editor.addCommand(
                    monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KEY_S,
                    () => saveAllFiles()
                );

                // Close Tab
                editor.addCommand(
                    monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_W,
                    () => { if (activeFile) closeTab(activeFile); }
                );

                // Command Palette
                editor.addCommand(
                    monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KEY_P,
                    () => toggleCommandPalette()
                );

                // Quick Open
                editor.addCommand(
                    monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_P,
                    () => toggleCommandPalette('file')
                );

                // Find
                editor.addCommand(
                    monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_F,
                    () => toggleSearch()
                );

                // Toggle Sidebar
                editor.addCommand(
                    monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_B,
                    () => toggleSidebar()
                );

                // Settings
                editor.addCommand(
                    monaco.KeyMod.CtrlCmd | monaco.KeyCode.US_COMMA,
                    () => toggleSettings()
                );

                // Recent Files
                editor.addCommand(
                    monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_E,
                    () => showRecentFiles()
                );

                // Find in Files
                editor.addCommand(
                    monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KEY_F,
                    () => showFindInFiles()
                );

                // Toggle AI Panel
                editor.addCommand(
                    monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_K,
                    () => {
                        // Wait for next key
                        const nextKeyHandler = (e) => {
                            if (e.key === 'a' || e.key === 'A') {
                                toggleAI();
                                document.removeEventListener('keydown', nextKeyHandler);
                            }
                        };
                        document.addEventListener('keydown', nextKeyHandler);
                        setTimeout(() => document.removeEventListener('keydown', nextKeyHandler), 2000);
                    }
                );
            } else if (window.UIRefreshShortcuts?.init) {
                window.UIRefreshShortcuts.init();
            }

            // Global keyboard listener for non-editor shortcuts
            document.addEventListener('keydown', (e) => {
                // Escape - close modals
                if (e.key === 'Escape') {
                    closeAllModals();
                }
                
                // Cmd/Ctrl+? - help (changed from plain ? to allow typing question marks)
                if (e.key === '?' && (e.metaKey || e.ctrlKey)) {
                    toggleKeyboardHelp();
                    e.preventDefault();
                }
                
                // Arrow navigation in command palette
                const palette = document.getElementById('command-palette');
                if (!palette.classList.contains('hidden')) {
                    if (e.key === 'ArrowDown') {
                        navigateCommands(1);
                        e.preventDefault();
                    } else if (e.key === 'ArrowUp') {
                        navigateCommands(-1);
                        e.preventDefault();
                    } else if (e.key === 'Enter') {
                        executeSelectedCommand();
                        e.preventDefault();
                    }
                }
            });
        }

        // ============================================================================
        // FILE TREE
        // ============================================================================
        
        async function loadFileTree() {
            try {
                const tree = document.getElementById('file-tree');
                if (!folderPath) {
                    if (tree) {
                        tree.innerHTML = '<div class="browse-empty">No folder selected. Use <strong>Choose Folder</strong> to start.</div>';
                    }
                    if (window.UIRefreshOnboarding?.updateVisibility) {
                        window.UIRefreshOnboarding.updateVisibility();
                    }
                    return;
                }

                // Update sidebar path display
                const sidebarPath = document.getElementById('sidebar-path');
                if (sidebarPath) {
                    sidebarPath.textContent = folderPath;
                }

                // Update go-up button state
                const goUpBtn = document.getElementById('go-up-btn');
                if (goUpBtn) {
                    goUpBtn.style.opacity = folderPath === '/' ? '0.3' : '1';
                    goUpBtn.style.pointerEvents = folderPath === '/' ? 'none' : 'auto';
                }

                if (typeof refreshFolderContextButtons === 'function') {
                    refreshFolderContextButtons();
                }

                const data = await FileAPI.listFiles();

                if (!data.success) {
                    throw new Error(data.error || 'Failed to load files');
                }

                allFiles = data.files || [];

                tree.innerHTML = '';

                if (Array.isArray(data.partialErrors) && data.partialErrors.length > 0) {
                    const warning = document.createElement('div');
                    warning.className = 'browse-meta';
                    warning.textContent = `${data.partialErrors.length} folders could not be read. Showing available files.`;
                    tree.appendChild(warning);
                }

                if (data.truncated) {
                    const truncatedNotice = document.createElement('div');
                    truncatedNotice.className = 'browse-meta';
                    truncatedNotice.textContent = 'Listing truncated for performance. Narrow your folder path to load deeper.';
                    tree.appendChild(truncatedNotice);
                }

                if (allFiles.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'browse-empty';
                    empty.textContent = 'No files found';
                    tree.appendChild(empty);
                    return;
                }

                // Build hierarchical tree from flat list
                const treeStructure = buildTreeStructure(allFiles, folderPath);
                renderTree(treeStructure, tree);

                // Auto-open file
                let fileToOpen = null;
                
                if (initialFileName) {
                    fileToOpen = findFileInTree(allFiles, initialFileName);
                }
                
                if (!fileToOpen) {
                    fileToOpen = findFileInTree(allFiles, 'INDEX.md');
                }
                
                if (fileToOpen) {
                    setTimeout(() => openFile(fileToOpen.path, fileToOpen.name), 100);
                }

            } catch (error) {
                console.error('Failed to load file tree:', error);
                const tree = document.getElementById('file-tree');
                if (tree) {
                    tree.innerHTML = `<div class="browse-error">Failed to load files: ${escapeHtml(error.message || String(error))}</div>`;
                }
                showToast('Failed to load files: ' + error.message, 'error');
            }
        }

        function buildTreeStructure(flatFiles, rootPath) {
            const tree = {};
            
            flatFiles.forEach(file => {
                // Get relative path from root
                const relativePath = file.path.startsWith(rootPath) 
                    ? file.path.substring(rootPath.length).replace(/^\//, '')
                    : file.path;
                
                if (!relativePath) return; // Skip root itself
                
                const parts = relativePath.split('/');
                let current = tree;
                
                // Build nested structure
                parts.forEach((part, index) => {
                    if (!current[part]) {
                        const isLastPart = index === parts.length - 1;
                        current[part] = {
                            name: part,
                            path: file.path,
                            isDirectory: isLastPart ? file.isDirectory : true,
                            children: {}
                        };
                    }
                    current = current[part].children;
                });
            });
            
            // Convert to array format
            const treeToArray = (obj) => {
                return Object.values(obj).map(item => ({
                    name: item.name,
                    path: item.path,
                    isDirectory: item.isDirectory,
                    children: item.isDirectory && Object.keys(item.children).length > 0 
                        ? treeToArray(item.children)
                        : []
                })).sort((a, b) => {
                    // Directories first, then alphabetical
                    if (a.isDirectory && !b.isDirectory) return -1;
                    if (!a.isDirectory && b.isDirectory) return 1;
                    return a.name.localeCompare(b.name);
                });
            };
            
            return treeToArray(tree);
        }
        
        function renderTree(items, container) {
            items.forEach(item => {
                const treeItem = document.createElement('div');
                treeItem.className = 'tree-item';
                
                if (item.isDirectory) {
                    const folderHeader = document.createElement('div');
                    folderHeader.className = 'folder-item';
                    folderHeader.dataset.path = item.path; // Add path for breadcrumb navigation
                    folderHeader.innerHTML = `
                        <span class="folder-chevron">▶</span>
                        <span class="folder-icon">📁</span>
                        <span>${item.name}</span>
                    `;
                    
                    const folderContents = document.createElement('div');
                    folderContents.className = 'folder-contents collapsed';
                    
                    folderHeader.onclick = (e) => {
                        e.stopPropagation();
                        const chevron = folderHeader.querySelector('.folder-chevron');
                        chevron.classList.toggle('expanded');
                        folderContents.classList.toggle('collapsed');
                    };
                    
                    // Context menu for folders
                    folderHeader.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showContextMenu(e.clientX, e.clientY, item.path);
                    });
                    
                    treeItem.appendChild(folderHeader);
                    treeItem.appendChild(folderContents);
                    
                    if (item.children && item.children.length > 0) {
                        renderTree(item.children, folderContents);
                    }
                } else {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.dataset.path = item.path;
                    
                    const icon = getFileIcon(item.name);
                    
                    fileItem.innerHTML = `
                        <span class="file-icon">${icon}</span>
                        <span>${item.name}</span>
                    `;
                    
                    fileItem.onclick = () => openFile(item.path, item.name);
                    
                    // Context menu (Cursor-style)
                    fileItem.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showContextMenu(e.clientX, e.clientY, item.path);
                    });
                    
                    treeItem.appendChild(fileItem);
                }
                
                container.appendChild(treeItem);
            });
        }

        function findFileInTree(items, fileName) {
            for (const item of items) {
                if (item.type !== 'directory' && item.name === fileName) {
                    return item;
                }
                if (item.children) {
                    const found = findFileInTree(item.children, fileName);
                    if (found) return found;
                }
            }
            return null;
        }

        // ============================================================================
        // FILE OPERATIONS
        // ============================================================================
        
        async function openFile(filePath, fileName) {
            if (openFiles.has(filePath)) {
                setActiveFile(filePath);
                return;
            }
            
            // If fileName not provided, derive it from filePath
            if (!fileName) {
                fileName = filePath.split('/').pop();
            }

            try {
                // Check if this is a special file type that needs handling
                const ext = fileName.split('.').pop().toLowerCase();
                const isOfficeFile = ['docx', 'xlsx', 'xls', 'msg'].includes(ext);
                const isImageFile = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico'].includes(ext);
                
                let fileContent = '';
                let isReadOnly = false;
                
                if (isImageFile) {
                    // Image files - show placeholder and auto-open preview
                    fileContent = `============================================
IMAGE FILE: ${fileName}
File Type: ${ext.toUpperCase()}
This is a binary image file.
Click the Preview button (Cmd+K V) to view the image.
============================================

Image path: ${filePath}

To view this image:
1. Click the Preview button (👁️) in the toolbar
2. Or press Cmd+K V

The image will be displayed in the preview pane.`;
                    isReadOnly = true;
                } else if (isOfficeFile) {
                    // Office files - professional handling
                    const isDocx = ext === 'docx';
                    const isExcel = ext === 'xlsx' || ext === 'xls';
                    const isMsg = ext === 'msg';
                    
                    if (isDocx || isExcel) {
                        // DOCX/XLSX: Extract text for preview, or handle empty/corrupted files
                        const response = await fetch(`/api/extract-office-text?path=${encodeURIComponent(filePath)}`);
                        const result = await response.json();
                        
                        const fileTypeLabel = isDocx ? 'Word Document' : 'Excel Spreadsheet';
                        
                        if (result.success && result.content && result.content.trim()) {
                            // Valid file with content
                            fileContent = `╔══════════════════════════════════════════════════════════════════════════════╗
║  ${fileTypeLabel.toUpperCase().padEnd(74)}║
║  ${fileName.substring(0, 74).padEnd(74)}║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ✏️ EDIT        - Click the green EDIT button to open in OnlyOffice editor   ║
║  📥 DOWNLOAD    - Click Download button (↓) to get the file                  ║
║  📤 RE-UPLOAD   - Click Upload (↑) to replace with your edited version       ║
║  👁️ PREVIEW     - Click Preview (Cmd+K V) to see formatted content           ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

─────────────────────────────────────────────────────────────────────────────────
TEXT CONTENT (for reference/search):
─────────────────────────────────────────────────────────────────────────────────

${result.content}`;
                            isReadOnly = true;
                        } else {
                            // Empty or corrupted file - show message to use OnlyOffice editor
                            fileContent = `╔══════════════════════════════════════════════════════════════════════════════╗
║  ${fileTypeLabel.toUpperCase()} - NEW OR EMPTY FILE${' '.repeat(Math.max(0, 74 - fileTypeLabel.length - 23))}║
║  ${fileName.substring(0, 74).padEnd(74)}║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  This file is empty or could not be read.                                    ║
║                                                                              ║
║  ✏️ Click the green EDIT button to open in OnlyOffice editor                 ║
║                                                                              ║
║  OnlyOffice will create a proper formatted document for you.                 ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝`;
                            isReadOnly = true;
                        }
                    } else if (isMsg) {
                        // MSG files - email preview
                        const response = await fetch(`/api/extract-office-text?path=${encodeURIComponent(filePath)}`);
                        const result = await response.json();
                        
                        if (result.success) {
                            fileContent = `╔══════════════════════════════════════════════════════════════════════════════╗
║  OUTLOOK EMAIL MESSAGE                                                       ║
║  ${fileName.substring(0, 74).padEnd(74)}║
╠══════════════════════════════════════════════════════════════════════════════╣
║  👁️ PREVIEW: Click Preview (Cmd+K V) for formatted email view               ║
║  📥 DOWNLOAD: Click Download (↓) to get the original .msg file               ║
╚══════════════════════════════════════════════════════════════════════════════╝

${result.content}`;
                            isReadOnly = true;
                        } else {
                            throw new Error(result.error || 'Failed to extract email content');
                        }
                    } else {
                        // Other Office files
                        const response = await fetch(`/api/extract-office-text?path=${encodeURIComponent(filePath)}`);
                        const result = await response.json();
                        
                        if (result.success) {
                            fileContent = `============================================
EXTRACTED CONTENT FROM: ${fileName}
File Type: ${ext.toUpperCase()}
============================================

${result.content}`;
                            isReadOnly = true;
                        } else {
                            throw new Error(result.error || 'Failed to extract content');
                        }
                    }
                } else {
                    // Regular text file
                    const data = await FileAPI.readFile(filePath);

                    if (!data.success) {
                        throw new Error(data.error || 'Failed to load file');
                    }
                    
                    fileContent = data.content;
                }

                // Detect language - Office files use plaintext since they're read-only previews
                const language = isOfficeFile ? 'plaintext' : detectLanguage(fileName);

                // Check if model already exists and dispose it
                const uri = monaco.Uri.file(filePath);
                let model = monaco.editor.getModel(uri);
                
                if (model) {
                    // Model exists - dispose it first
                    model.dispose();
                }
                
                // Create new model
                model = monaco.editor.createModel(
                    fileContent,
                    language,
                    uri
                );
                
                // Make Office files read-only
                if (isReadOnly) {
                    model.updateOptions({ readOnly: true });
                }

                openFiles.set(filePath, {
                    model,
                    dirty: false,
                    name: fileName,
                    path: filePath,
                    originalContent: fileContent,
                    isOfficeFile: isOfficeFile,
                    isImageFile: isImageFile,
                    readOnly: isReadOnly
                });

                addTab(filePath, fileName);
                setActiveFile(filePath);

                console.log('Opened:', fileName, 'Language:', language, 
                    isOfficeFile ? '(Office File - Download to Edit)' : 
                    isImageFile ? '(Image File)' : '');
                
                // Auto-open preview for Office files and images
                if (isOfficeFile || isImageFile) {
                    const previewPane = document.getElementById('preview-pane');
                    if (previewPane.classList.contains('hidden')) {
                        togglePreview();
                    }
                }

            } catch (error) {
                console.error('Failed to open file:', error);
                showToast('Failed to open file: ' + error.message, 'error');
            }
        }

        function getFileIcon(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const iconMap = {
                // Office Documents
                'docx': '📄',
                'doc': '📄',
                'xlsx': '📊',
                'xls': '📊',
                'pptx': '📽️',
                'ppt': '📽️',
                'msg': '📧',
                
                // Code Files
                'js': '📜',
                'jsx': '⚛️',
                'ts': '📘',
                'tsx': '⚛️',
                'py': '🐍',
                'java': '☕',
                'cpp': '⚙️',
                'c': '⚙️',
                'h': '⚙️',
                'cs': '#️⃣',
                'go': '🔷',
                'rs': '🦀',
                'php': '🐘',
                'rb': '💎',
                'swift': '🐦',
                'kt': '🟣',
                
                // Web
                'html': '🌐',
                'htm': '🌐',
                'css': '🎨',
                'scss': '🎨',
                'sass': '🎨',
                'less': '🎨',
                'vue': '💚',
                
                // Data
                'json': '📋',
                'xml': '📋',
                'yaml': '📋',
                'yml': '📋',
                'csv': '📊',
                'tsv': '📊',
                'sql': '🗄️',
                
                // Documentation
                'md': '📝',
                'markdown': '📝',
                'txt': '📄',
                'pdf': '📕',
                
                // Images
                'png': '🖼️',
                'jpg': '🖼️',
                'jpeg': '🖼️',
                'gif': '🖼️',
                'svg': '🎨',
                'ico': '🖼️',
                'webp': '🖼️',
                
                // Config
                'env': '⚙️',
                'config': '⚙️',
                'conf': '⚙️',
                'ini': '⚙️',
                'toml': '⚙️',
                
                // Archives
                'zip': '📦',
                'tar': '📦',
                'gz': '📦',
                'rar': '📦',
                '7z': '📦',
                
                // Other
                'sh': '⚡',
                'bash': '⚡',
                'zsh': '⚡',
                'log': '📜',
                'lock': '🔒'
            };
            return iconMap[ext] || '📄';
        }

        function detectLanguage(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const langMap = {
                'md': 'markdown',
                'markdown': 'markdown',
                'json': 'json',
                'js': 'javascript',
                'ts': 'typescript',
                'py': 'python',
                'html': 'html',
                'css': 'css',
                'yaml': 'yaml',
                'yml': 'yaml',
                'csv': 'csv',
                'tsv': 'csv',
                'txt': 'plaintext'
            };
            return langMap[ext] || 'plaintext';
        }

        function setActiveFile(filePath) {
            activeFile = filePath;
            const fileData = openFiles.get(filePath);

            if (!fileData) return;

            editor.setModel(fileData.model);

            document.querySelectorAll('.file-item').forEach(item => {
                item.classList.toggle('active', item.dataset.path === filePath);
            });

            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.path === filePath);
            });

            document.getElementById('status-file').textContent = fileData.name;
            document.getElementById('status-lang').textContent = 
                fileData.model.getLanguageId().toUpperCase();

            updateSaveButtons();
            updateFileStats();
            
            // Show/hide preview button for previewable file types
            const language = fileData.model.getLanguageId();
            const fileName = fileData.name.toLowerCase();
            const isImage = /\.(png|jpg|jpeg|gif|webp|svg|bmp|ico)$/i.test(fileName);
            const isPDF = fileName.endsWith('.pdf');
            const isOfficeFile = /\.(docx|xlsx|xls|msg)$/i.test(fileName);
            const isPreviewable = ['markdown', 'html', 'json', 'css', 'svg'].includes(language) || isImage || isPDF || isOfficeFile;
            document.getElementById('preview-btn').style.display = isPreviewable ? 'flex' : 'none';
            
            // Update preview if it's open and file is previewable
            const previewPane = document.getElementById('preview-pane');
            if (isPreviewable && !previewPane.classList.contains('hidden')) {
                updatePreview();
                updatePreviewHeader();
            } else if (!isPreviewable && !previewPane.classList.contains('hidden')) {
                // Hide preview if switching to non-previewable file
                previewPane.classList.add('hidden');
            }
            
            updateBreadcrumb();
            addToRecentFiles(filePath, fileData.name);
            saveWorkspaceState();
        }
        
        function updateBreadcrumb() {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            const breadcrumbBar = document.getElementById('breadcrumb-bar');
            
            if (!fileData) {
                breadcrumbBar.style.display = 'none';
                return;
            }
            
            breadcrumbBar.style.display = 'flex';
            const fullPath = activeFile;
            const pathParts = fullPath.split('/').filter(p => p);
            
            let html = '';
            let currentPath = '';
            
            for (let i = 0; i < pathParts.length; i++) {
                const part = pathParts[i];
                currentPath += '/' + part;
                const isLast = i === pathParts.length - 1;
                const partPath = currentPath;
                
                if (i > 0) {
                    html += `<span class="breadcrumb-separator">▸</span>`;
                }
                
                if (isLast) {
                    // Last item (filename) - not clickable
                    html += `<span class="breadcrumb-item active">${part}</span>`;
                } else {
                    // Folder - clickable
                    html += `<span class="breadcrumb-item" onclick="openFolderInTree('${partPath.replace(/'/g, "\\'")}')" title="Open folder in tree">${part}</span>`;
                }
            }
            
            breadcrumbBar.innerHTML = html;
        }
        
        function openFolderInTree(folderPath) {
            // Ensure file tree panel is visible
            const fileTreePanel = document.getElementById('file-tree');
            if (fileTreePanel) {
                fileTreePanel.style.display = 'block';
            }
            
            // Expand all parent folders leading to this path
            const pathParts = folderPath.split('/').filter(Boolean);
            let currentPath = '';
            pathParts.forEach(part => {
                currentPath += '/' + part;
                const folders = document.querySelectorAll('.folder-item');
                folders.forEach(folder => {
                    if (folder.dataset.path === currentPath) {
                        const folderContents = folder.parentElement?.querySelector('.folder-contents');
                        const chevron = folder.querySelector('.folder-chevron');
                        if (folderContents) {
                            folderContents.classList.remove('collapsed');
                        }
                        if (chevron) {
                            chevron.classList.add('expanded');
                        }
                    }
                });
            });
            
            // Find and highlight the target folder
            const folders = document.querySelectorAll('.folder-item');
            folders.forEach(folder => {
                folder.style.backgroundColor = ''; // Clear previous highlights
                if (folder.dataset.path === folderPath) {
                    // Highlight briefly
                    folder.style.backgroundColor = 'var(--accent-color)';
                    folder.style.transition = 'background-color 0.3s';
                    setTimeout(() => {
                        folder.style.backgroundColor = '';
                    }, 1500);
                    // Scroll into view
                    folder.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            });
        }
        
        function addToRecentFiles(filePath, fileName) {
            // Remove if already in list
            recentFiles = recentFiles.filter(f => f.path !== filePath);
            
            // Add to front
            recentFiles.unshift({ path: filePath, name: fileName, timestamp: Date.now() });
            
            // Limit size
            if (recentFiles.length > MAX_RECENT_FILES) {
                recentFiles = recentFiles.slice(0, MAX_RECENT_FILES);
            }
            
            // Save to localStorage
            try {
                if (folderPath) localStorage.setItem(`evobrew-recent-files-${folderPath}`, JSON.stringify(recentFiles));
            } catch (e) {
                console.error('Failed to save recent files:', e);
            }
        }
        
        function loadRecentFiles() {
            try {
                if (!folderPath) return;  // No folder selected yet
                const saved = folderPath ? localStorage.getItem(`evobrew-recent-files-${folderPath}`) : null;
                if (saved) {
                    recentFiles = JSON.parse(saved);
                }
            } catch (e) {
                console.error('Failed to load recent files:', e);
                recentFiles = [];
            }
        }
        
        function showRecentFiles() {
            if (recentFiles.length === 0) {
                showToast('No recent files', 'error');
                return;
            }
            
            // Show in command palette
            toggleCommandPalette('recent');
        }

        async function saveCurrentFile() {
            if (!activeFile) return;

            const fileData = openFiles.get(activeFile);
            if (!fileData || !fileData.dirty) return;

            try {
                const content = fileData.model.getValue();

                const data = await FileAPI.writeFile(fileData.path, content);

                if (!data.success) {
                    throw new Error(data.error || 'Save failed');
                }

                fileData.dirty = false;
                fileData.originalContent = content;
                updateTabDirtyState(activeFile, false);
                updateSaveButtons();

                showToast(`Saved: ${fileData.name}`, 'success');
                console.log('Saved:', fileData.path);

            } catch (error) {
                console.error('Save failed:', error);
                showToast('Save failed: ' + error.message, 'error');
            }
        }

        async function saveAllFiles() {
            const dirtyFiles = Array.from(openFiles.entries())
                .filter(([path, data]) => data.dirty);

            if (dirtyFiles.length === 0) {
                showToast('No files to save', 'info');
                return;
            }

            let savedCount = 0;
            let failedCount = 0;

            showToast(`Saving ${dirtyFiles.length} file(s)...`, 'info');

            for (const [filePath, fileData] of dirtyFiles) {
                try {
                    const content = fileData.model.getValue();

                    const data = await FileAPI.writeFile(fileData.path, content);

                    if (data.success) {
                        fileData.dirty = false;
                        fileData.originalContent = content;
                        updateTabDirtyState(filePath, false);
                        savedCount++;
                    } else {
                        failedCount++;
                    }

                } catch (error) {
                    console.error('Failed to save:', fileData.path, error);
                    failedCount++;
                }
            }

            updateSaveButtons();

            if (failedCount === 0) {
                showToast(`✅ Saved ${savedCount} ${savedCount === 1 ? 'file' : 'files'}`, 'success');
            } else {
                showToast(`⚠️ Saved ${savedCount}, failed ${failedCount}`, 'error');
            }
        }

        // ============================================================================
        // TAB MANAGEMENT
        // ============================================================================
        
        function addTab(filePath, fileName) {
            const tab = document.createElement('button');
            tab.className = 'tab';
            if (pinnedTabs.has(filePath)) {
                tab.classList.add('pinned');
            }
            tab.dataset.path = filePath;
            tab.draggable = true;
            
            // Create tab content
            const pinIcon = document.createElement('span');
            pinIcon.className = 'tab-pin';
            pinIcon.textContent = pinnedTabs.has(filePath) ? '📌' : '📍';
            pinIcon.title = pinnedTabs.has(filePath) ? 'Unpin tab' : 'Pin tab';
            pinIcon.onclick = (e) => {
                e.stopPropagation();
                togglePinTab(filePath);
            };
            
            const tabName = document.createElement('span');
            tabName.className = 'tab-name';
            tabName.textContent = fileName;
            
            const closeBtn = document.createElement('span');
            closeBtn.className = 'tab-close';
            closeBtn.textContent = '×';
            closeBtn.onclick = (e) => {
                e.stopPropagation();
                closeTab(filePath);
            };
            
            tab.appendChild(pinIcon);
            tab.appendChild(tabName);
            tab.appendChild(closeBtn);
            tab.onclick = () => setActiveFile(filePath);
            
            // Drag and drop handlers
            tab.addEventListener('dragstart', handleTabDragStart);
            tab.addEventListener('dragover', handleTabDragOver);
            tab.addEventListener('drop', handleTabDrop);
            tab.addEventListener('dragend', handleTabDragEnd);
            
            // Context menu (right-click)
            tab.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showContextMenu(e.clientX, e.clientY, filePath);
            });
            
            // Insert tab in correct position (pinned tabs first)
            const tabsBar = document.getElementById('tabs-bar');
            if (pinnedTabs.has(filePath)) {
                // Find position among pinned tabs
                const pinnedTabElements = Array.from(tabsBar.querySelectorAll('.tab.pinned'));
                tabsBar.insertBefore(tab, pinnedTabElements[pinnedTabElements.length] || tabsBar.firstChild);
            } else {
                tabsBar.appendChild(tab);
            }
        }
        
        // Tab drag and drop
        let draggedTab = null;
        
        function handleTabDragStart(e) {
            draggedTab = e.currentTarget;
            e.currentTarget.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', e.currentTarget.dataset.path);
        }
        
        function handleTabDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            
            const target = e.currentTarget;
            if (target !== draggedTab && target.classList.contains('tab')) {
                target.classList.add('drag-over');
            }
            return false;
        }
        
        function handleTabDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            const target = e.currentTarget;
            target.classList.remove('drag-over');
            
            if (draggedTab !== target) {
                const tabsBar = document.getElementById('tabs-bar');
                const allTabs = Array.from(tabsBar.children);
                const draggedIndex = allTabs.indexOf(draggedTab);
                const targetIndex = allTabs.indexOf(target);
                
                if (draggedIndex < targetIndex) {
                    tabsBar.insertBefore(draggedTab, target.nextSibling);
                } else {
                    tabsBar.insertBefore(draggedTab, target);
                }
            }
            
            return false;
        }
        
        function handleTabDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('drag-over');
            });
        }
        
        function togglePinTab(filePath) {
            if (pinnedTabs.has(filePath)) {
                pinnedTabs.delete(filePath);
            } else {
                pinnedTabs.add(filePath);
            }
            
            // Update tab appearance
            const tab = document.querySelector(`.tab[data-path="${filePath}"]`);
            if (tab) {
                tab.classList.toggle('pinned');
                const pinIcon = tab.querySelector('.tab-pin');
                if (pinIcon) {
                    pinIcon.textContent = pinnedTabs.has(filePath) ? '📌' : '📍';
                    pinIcon.title = pinnedTabs.has(filePath) ? 'Unpin tab' : 'Pin tab';
                }
                
                // Move tab to correct position
                const tabsBar = document.getElementById('tabs-bar');
                tab.remove();
                
                if (pinnedTabs.has(filePath)) {
                    const pinnedTabElements = Array.from(tabsBar.querySelectorAll('.tab.pinned'));
                    tabsBar.insertBefore(tab, pinnedTabElements[pinnedTabElements.length] || tabsBar.firstChild);
                } else {
                    const firstUnpinned = tabsBar.querySelector('.tab:not(.pinned)');
                    if (firstUnpinned) {
                        tabsBar.insertBefore(tab, firstUnpinned.nextSibling);
                    } else {
                        tabsBar.appendChild(tab);
                    }
                }
            }
            
            saveWorkspaceState();
        }

        function closeTab(filePath) {
            const fileData = openFiles.get(filePath);

            if (!fileData) return;

            if (fileData.dirty) {
                if (!confirm(`File has unsaved changes. Close anyway?`)) {
                    return;
                }
            }

            fileData.model.dispose();
            openFiles.delete(filePath);

            const tab = document.querySelector(`.tab[data-path="${filePath}"]`);
            if (tab) {
                tab.remove();
            }

            if (activeFile === filePath) {
                const remainingFiles = Array.from(openFiles.keys());
                if (remainingFiles.length > 0) {
                    setActiveFile(remainingFiles[0]);
                } else {
                    activeFile = null;
                    editor.setModel(null);
                    document.getElementById('status-file').textContent = 'No file open';
                    document.getElementById('status-lang').textContent = '';
                    updateSaveButtons();
                }
            }
            
            saveWorkspaceState();
        }

        function updateTabDirtyState(filePath, dirty) {
            const tab = document.querySelector(`.tab[data-path="${filePath}"]`);
            if (!tab) return;

            const fileData = openFiles.get(filePath);
            const nameSpan = tab.querySelector('.tab-name');
            
            if (dirty) {
                nameSpan.textContent = '● ' + fileData.name;
            } else {
                nameSpan.textContent = fileData.name;
            }
        }

        // ============================================================================
        // COMMAND PALETTE
        // ============================================================================
        
        // Commands will be initialized after all functions are defined
        let commands = [];

        function toggleCommandPalette(mode = 'command') {
            const palette = document.getElementById('command-palette');
            const input = document.getElementById('command-input');
            const overlay = document.getElementById('overlay');
            
            if (palette.classList.contains('hidden')) {
                palette.classList.remove('hidden');
                overlay.classList.remove('hidden');
                input.value = '';
                
                if (mode === 'file') {
                    input.placeholder = 'Type to search files...';
                    renderFileCommands();
                } else if (mode === 'recent') {
                    input.placeholder = 'Recent files...';
                    renderRecentFileCommands();
                } else {
                    input.placeholder = 'Type a command or search files...';
                    renderCommands('');
                }
                
                input.focus();
                input.dataset.mode = mode;
            } else {
                palette.classList.add('hidden');
                overlay.classList.add('hidden');
            }
        }

        function renderCommands(query) {
            const results = document.getElementById('command-results');
            selectedCommandIndex = 0;
            
            let filtered = commands;
            
            if (query) {
                query = query.toLowerCase();
                filtered = commands.filter(cmd => 
                    cmd.label.toLowerCase().includes(query) ||
                    cmd.id.toLowerCase().includes(query)
                );
            }
            
            results.innerHTML = filtered.map((cmd, idx) => `
                <div class="command-item ${idx === 0 ? 'selected' : ''}" data-index="${idx}" onclick="executeCommand('${cmd.id}')">
                    <span class="command-label">${cmd.label}</span>
                    ${cmd.keys ? `<span class="command-keys">${cmd.keys}</span>` : ''}
                </div>
            `).join('');
        }

        function getCommandRegistry() {
            return commands;
        }
        window.getCommandRegistry = getCommandRegistry;

        function renderFileCommands() {
            const results = document.getElementById('command-results');
            selectedCommandIndex = 0;
            
            const flatFiles = [];
            const collectFiles = (items) => {
                items.forEach(item => {
                    if (item.type !== 'directory') {
                        flatFiles.push(item);
                    }
                    if (item.children) {
                        collectFiles(item.children);
                    }
                });
            };
            collectFiles(allFiles);
            
            results.innerHTML = flatFiles.map((file, idx) => `
                <div class="command-item ${idx === 0 ? 'selected' : ''}" data-index="${idx}" onclick="openFileFromPalette('${file.path}', '${file.name}')">
                    <span class="command-label">${file.path}</span>
                </div>
            `).join('');
        }
        
        function renderRecentFileCommands() {
            const results = document.getElementById('command-results');
            selectedCommandIndex = 0;
            
            if (recentFiles.length === 0) {
                results.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: var(--text-secondary);">
                        No recent files
                    </div>
                `;
                return;
            }
            
            results.innerHTML = recentFiles.map((file, idx) => {
                const timeAgo = formatTimeAgo(file.timestamp);
                return `
                    <div class="command-item ${idx === 0 ? 'selected' : ''}" data-index="${idx}" onclick="openFileFromPalette('${file.path}', '${file.name}')">
                        <span class="command-label">${file.name}</span>
                        <span class="command-keys">${timeAgo}</span>
                    </div>
                `;
            }).join('');
        }
        
        function formatTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            return `${days}d ago`;
        }

        function executeCommand(commandId) {
            const cmd = commands.find(c => c.id === commandId);
            if (cmd && cmd.action) {
                cmd.action();
                toggleCommandPalette();
            }
        }

        function executeCommandById(commandId) {
            const cmd = commands.find(c => c.id === commandId);
            if (cmd && cmd.action) {
                cmd.action();
            }
        }
        window.executeCommandById = executeCommandById;

        function executeSelectedCommand() {
            const selected = document.querySelector('.command-item.selected');
            if (selected) {
                selected.click();
            }
        }

        function openFileFromPalette(path, name) {
            openFile(path, name);
            toggleCommandPalette();
        }

        function navigateCommands(direction) {
            const items = document.querySelectorAll('.command-item');
            if (items.length === 0) return;
            
            items[selectedCommandIndex].classList.remove('selected');
            selectedCommandIndex = (selectedCommandIndex + direction + items.length) % items.length;
            items[selectedCommandIndex].classList.add('selected');
            
            items[selectedCommandIndex].scrollIntoView({ block: 'nearest' });
        }

        // Listen to input changes
        document.addEventListener('DOMContentLoaded', () => {
            const input = document.getElementById('command-input');
            if (input) {
                input.addEventListener('input', (e) => {
                    const query = e.target.value;
                    const mode = e.target.dataset.mode || 'command';
                    
                    if (mode === 'command') {
                        renderCommands(query);
                    } else if (mode === 'file') {
                        // Could filter files by query here
                        renderFileCommands();
                    } else if (mode === 'recent') {
                        // Could filter recent files by query here
                        renderRecentFileCommands();
                    }
                });
            }
            
            // Load recent files on startup
            loadRecentFiles();
        });

        // ============================================================================
        // MARKDOWN PREVIEW
        // ============================================================================
        
        function togglePreview() {
            const pane = document.getElementById('preview-pane');
            pane.classList.toggle('hidden');
            
            if (!pane.classList.contains('hidden')) {
                updatePreview();
                updatePreviewHeader();
            }
        }
        
        function updatePreviewHeader() {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) return;
            
            const language = fileData.model.getLanguageId();
            const fileName = fileData.name.toLowerCase();
            const previewHeader = document.querySelector('.preview-header span');
            
            if (language === 'markdown') {
                previewHeader.textContent = '📄 Markdown Preview';
            } else if (language === 'html') {
                previewHeader.textContent = '🌐 HTML Preview';
            } else if (language === 'json') {
                previewHeader.textContent = '📊 JSON Viewer';
            } else if (language === 'css') {
                previewHeader.textContent = '🎨 CSS Preview';
            } else if (language === 'svg' || fileName.endsWith('.svg')) {
                previewHeader.textContent = '🖼️ SVG Preview';
            } else if (fileName.endsWith('.pdf')) {
                previewHeader.textContent = '📑 PDF Viewer';
            } else if (/\.(png|jpg|jpeg|gif|webp|bmp|ico)$/i.test(fileName)) {
                previewHeader.textContent = '🖼️ Image Preview';
            } else if (fileName.endsWith('.docx')) {
                previewHeader.textContent = '📄 Word Document Preview';
            } else if (/\.(xlsx|xls)$/i.test(fileName)) {
                previewHeader.textContent = '📊 Excel Spreadsheet Preview';
            } else if (fileName.endsWith('.msg')) {
                previewHeader.textContent = '📧 Outlook Message Preview';
            } else {
                previewHeader.textContent = '👁️ Preview';
            }
        }

        function schedulePreviewUpdate() {
            if (document.getElementById('preview-pane').classList.contains('hidden')) return;
            
            clearTimeout(previewUpdateTimer);
            previewUpdateTimer = setTimeout(updatePreview, 500);
        }

        function updatePreview() {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) return;
            
            const language = fileData.model.getLanguageId();
            const fileName = fileData.name.toLowerCase();
            const content = fileData.model.getValue();
            const previewContent = document.getElementById('preview-content');
            
            try {
                if (language === 'markdown') {
                    // Parse markdown to HTML
            const html = renderMarkdownSafe(content);
                    previewContent.innerHTML = html;
                    
                } else if (language === 'html') {
                    // Render HTML in sandboxed iframe
                    previewContent.innerHTML = `
                        <iframe 
                            id="html-preview-frame" 
                            style="width: 100%; height: 100%; border: none; background: white;"
                            sandbox="allow-same-origin allow-scripts"
                        ></iframe>
                    `;
                    const iframe = document.getElementById('html-preview-frame');
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    iframeDoc.open();
                    iframeDoc.write(content);
                    iframeDoc.close();
                    
                } else if (language === 'json') {
                    // JSON formatted tree view
                    try {
                        const parsed = JSON.parse(content);
                        const formatted = JSON.stringify(parsed, null, 2);
                        previewContent.innerHTML = `
                            <div style="padding: 20px; font-family: 'Monaco', monospace; font-size: 13px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 16px; border-bottom: 1px solid #3e3e42; padding-bottom: 12px;">
                                    <strong style="color: var(--text-active);">JSON Structure</strong>
                                    <button onclick="copyJsonToClipboard()" class="btn btn-secondary" style="padding: 4px 12px; font-size: 11px;">
                                        Copy Formatted
                                    </button>
                                </div>
                                <div id="json-tree-view"></div>
                            </div>
                        `;
                        renderJsonTree(parsed, document.getElementById('json-tree-view'));
                    } catch (e) {
                        previewContent.innerHTML = `
                            <div style="color: var(--error-color); padding: 20px;">
                                <strong>Invalid JSON</strong><br>
                                ${e.message}
                                <pre style="margin-top: 12px; padding: 12px; background: var(--bg-secondary); border-radius: 4px; overflow-x: auto;">${content}</pre>
                            </div>
                        `;
                    }
                    
                } else if (language === 'css') {
                    // CSS preview with test HTML
                    previewContent.innerHTML = `
                        <iframe 
                            id="css-preview-frame" 
                            style="width: 100%; height: 100%; border: none; background: white;"
                            sandbox="allow-same-origin"
                        ></iframe>
                    `;
                    const iframe = document.getElementById('css-preview-frame');
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    const testHTML = `
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <style>${content}</style>
                        </head>
                        <body>
                            <h1>Heading 1</h1>
                            <h2>Heading 2</h2>
                            <h3>Heading 3</h3>
                            <p>This is a paragraph with <strong>bold</strong> and <em>italic</em> text.</p>
                            <p>Another paragraph with a <a href="#">link</a>.</p>
                            <ul>
                                <li>Unordered list item 1</li>
                                <li>Unordered list item 2</li>
                                <li>Unordered list item 3</li>
                            </ul>
                            <ol>
                                <li>Ordered list item 1</li>
                                <li>Ordered list item 2</li>
                                <li>Ordered list item 3</li>
                            </ol>
                            <button>Button</button>
                            <input type="text" placeholder="Text input" />
                            <table>
                                <tr><th>Header 1</th><th>Header 2</th></tr>
                                <tr><td>Cell 1</td><td>Cell 2</td></tr>
                                <tr><td>Cell 3</td><td>Cell 4</td></tr>
                            </table>
                            <div class="box">Box with class "box"</div>
                            <div id="special">Div with id "special"</div>
                        </body>
                        </html>
                    `;
                    iframeDoc.open();
                    iframeDoc.write(testHTML);
                    iframeDoc.close();
                    
                } else if (language === 'svg' || fileName.endsWith('.svg')) {
                    // SVG preview
                    previewContent.innerHTML = `
                        <div style="padding: 20px; text-align: center; background: white; height: 100%; overflow: auto;">
                            ${content}
                        </div>
                    `;
                    
                } else if (fileName.endsWith('.pdf')) {
                    // PDF viewer (requires base64 encoded content or URL)
                    previewContent.innerHTML = `
                        <div style="padding: 20px; text-align: center;">
                            <p style="color: var(--text-secondary); margin-bottom: 16px;">
                                PDF preview requires a URL or base64 encoded content.
                            </p>
                            <button onclick="downloadCurrentFile()" class="btn">
                                Download PDF to View
                            </button>
                        </div>
                    `;
                    
                } else if (/\.(png|jpg|jpeg|gif|webp|bmp|ico)$/i.test(fileName)) {
                    // Image preview - load image as base64 and display
                    previewContent.innerHTML = `
                        <div style="padding: 20px; text-align: center; background: #f5f5f5; height: 100%; overflow: auto;">
                            <div style="color: #666; margin-bottom: 16px; font-size: 13px; font-weight: 600;">
                                ${fileData.name}
                            </div>
                            <div style="color: #999; margin-bottom: 16px;">
                                Loading image...
                            </div>
                        </div>
                    `;
                    
                    // Display image using server endpoint
                    const imageUrl = `/api/serve-file?path=${encodeURIComponent(activeFile)}`;
                    previewContent.innerHTML = `
                        <div style="padding: 20px; text-align: center; background: #f5f5f5; height: 100%; overflow: auto; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                            <div style="color: #666; margin-bottom: 16px; font-size: 13px; font-weight: 600;">
                                ${fileData.name}
                            </div>
                            <div style="max-width: 100%; max-height: calc(100% - 100px); display: inline-block;">
                                <img src="${imageUrl}" 
                                     style="max-width: 100%; max-height: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);"
                                     onerror="this.style.display='none'; const err = document.createElement('div'); err.style.cssText='color:#e74c3c; padding: 20px;'; err.textContent='Unable to load image: ${fileData.name}'; this.parentElement.appendChild(err);"
                                     alt="${fileData.name}">
                            </div>
                            <div style="margin-top: 16px; font-size: 11px; color: #999; max-width: 600px; word-wrap: break-word;">
                                Path: ${activeFile}
                            </div>
                        </div>
                    `;
                    
                } else if (/\.(docx|xlsx|xls|msg)$/i.test(fileName)) {
                    // Office file preview - load HTML from server
                    previewContent.innerHTML = `
                        <div style="padding: 20px; text-align: center;">
                            <div style="color: var(--text-secondary); margin-bottom: 16px;">
                                Loading preview...
                            </div>
                        </div>
                    `;
                    
                    // Fetch HTML preview from server
                    fetch(`/api/preview-office-file?path=${encodeURIComponent(activeFile)}`)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`Failed to load preview: ${response.statusText}`);
                            }
                            return response.text();
                        })
                        .then(html => {
                            // Render in iframe for safety
                            previewContent.innerHTML = `
                                <iframe 
                                    id="office-preview-frame" 
                                    style="width: 100%; height: 100%; border: none; background: white;"
                                    sandbox="allow-same-origin"
                                ></iframe>
                            `;
                            const iframe = document.getElementById('office-preview-frame');
                            const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                            iframeDoc.open();
                            iframeDoc.write(html);
                            iframeDoc.close();
                        })
                        .catch(error => {
                            previewContent.innerHTML = `
                                <div style="color: var(--error-color); padding: 20px;">
                                    <strong>Preview Error</strong><br>
                                    ${error.message}
                                    <br><br>
                                    <button onclick="downloadCurrentFile()" class="btn">
                                        Download File to View
                                    </button>
                                </div>
                            `;
                        });
                }
                
            } catch (error) {
                console.error('Preview error:', error);
                previewContent.innerHTML = 
                    `<div style="color: var(--error-color); padding: 20px;">
                        <strong>Preview Error</strong><br>
                        ${error.message}
                    </div>`;
            }
        }
        
        // Helper function to render JSON tree
        function renderJsonTree(obj, container, level = 0) {
            const indent = level * 20;
            
            if (obj === null) {
                container.innerHTML += `<div style="margin-left: ${indent}px; color: #569cd6;">null</div>`;
                return;
            }
            
            if (typeof obj !== 'object') {
                const color = typeof obj === 'string' ? '#ce9178' : 
                             typeof obj === 'number' ? '#b5cea8' : 
                             typeof obj === 'boolean' ? '#569cd6' : '#cccccc';
                const value = typeof obj === 'string' ? `"${obj}"` : String(obj);
                container.innerHTML += `<div style="margin-left: ${indent}px; color: ${color};">${value}</div>`;
                return;
            }
            
            const isArray = Array.isArray(obj);
            const entries = Object.entries(obj);
            
            if (entries.length === 0) {
                container.innerHTML += `<div style="margin-left: ${indent}px; color: #808080;">${isArray ? '[]' : '{}'}</div>`;
                return;
            }
            
            for (let i = 0; i < entries.length; i++) {
                const [key, value] = entries[i];
                const isLast = i === entries.length - 1;
                const isExpandable = value !== null && typeof value === 'object';
                
                const line = document.createElement('div');
                line.style.marginLeft = indent + 'px';
                line.style.marginTop = '2px';
                
                if (isExpandable) {
                    const toggle = document.createElement('span');
                    toggle.textContent = '▼ ';
                    toggle.style.cursor = 'pointer';
                    toggle.style.color = '#808080';
                    toggle.style.fontSize = '10px';
                    toggle.style.marginRight = '4px';
                    
                    const keySpan = document.createElement('span');
                    keySpan.style.color = '#9cdcfe';
                    keySpan.textContent = isArray ? `[${key}]` : `"${key}"`;
                    
                    const colonSpan = document.createElement('span');
                    colonSpan.textContent = ': ';
                    colonSpan.style.color = '#cccccc';
                    
                    const typeSpan = document.createElement('span');
                    typeSpan.style.color = '#808080';
                    typeSpan.textContent = Array.isArray(value) ? `Array(${value.length})` : 'Object';
                    
                    const childContainer = document.createElement('div');
                    childContainer.style.marginLeft = '20px';
                    
                    toggle.onclick = () => {
                        const isCollapsed = childContainer.style.display === 'none';
                        childContainer.style.display = isCollapsed ? 'block' : 'none';
                        toggle.textContent = isCollapsed ? '▼ ' : '▶ ';
                    };
                    
                    line.appendChild(toggle);
                    line.appendChild(keySpan);
                    line.appendChild(colonSpan);
                    line.appendChild(typeSpan);
                    container.appendChild(line);
                    container.appendChild(childContainer);
                    
                    renderJsonTree(value, childContainer, level + 1);
                } else {
                    const keySpan = document.createElement('span');
                    keySpan.style.color = '#9cdcfe';
                    keySpan.style.marginLeft = '16px';
                    keySpan.textContent = isArray ? `[${key}]` : `"${key}"`;
                    
                    const colonSpan = document.createElement('span');
                    colonSpan.textContent = ': ';
                    colonSpan.style.color = '#cccccc';
                    
                    const valueColor = typeof value === 'string' ? '#ce9178' : 
                                      typeof value === 'number' ? '#b5cea8' : 
                                      typeof value === 'boolean' ? '#569cd6' : '#cccccc';
                    const valueSpan = document.createElement('span');
                    valueSpan.style.color = valueColor;
                    valueSpan.textContent = typeof value === 'string' ? `"${value}"` : String(value);
                    
                    line.appendChild(keySpan);
                    line.appendChild(colonSpan);
                    line.appendChild(valueSpan);
                    container.appendChild(line);
                }
            }
        }
        
        function copyJsonToClipboard() {
            if (!activeFile) return;
            const fileData = openFiles.get(activeFile);
            if (!fileData) return;
            
            try {
                const content = fileData.model.getValue();
                const parsed = JSON.parse(content);
                const formatted = JSON.stringify(parsed, null, 2);
                copyToClipboard(formatted);
            } catch (e) {
                showToast('Invalid JSON, cannot copy', 'error');
            }
        }

        // ============================================================================
        // SEARCH & REPLACE
        // ============================================================================
        
        function toggleSearch() {
            const panel = document.getElementById('search-panel');
            panel.classList.toggle('hidden');
            
            if (!panel.classList.contains('hidden')) {
                document.getElementById('search-input').focus();
            }
        }

        function findNext() {
            const query = document.getElementById('search-input').value;
            if (!query || !editor) return;
            
            const caseSensitive = document.getElementById('search-case').checked;
            const wholeWord = document.getElementById('search-whole').checked;
            const regex = document.getElementById('search-regex').checked;
            
            // Use Monaco's find controller with our options
            const findController = editor.getContribution('editor.contrib.findController');
            if (findController) {
                findController.start({
                    forceRevealReplace: false,
                    seedSearchStringFromSelection: 'never',
                    seedSearchStringFromGlobalClipboard: false,
                    shouldFocus: 2, // FindInputFocusType.FindInput
                    shouldAnimate: true,
                    updateSearchScope: false,
                    loop: true
                });
                
                // Set the search string and options
                const state = findController.getState();
                if (state) {
                    state.change({
                        searchString: query,
                        isRegex: regex,
                        matchCase: caseSensitive,
                        wholeWord: wholeWord
                    }, false);
                }
                
                // Find next match
                findController.moveToNextMatch();
            }
        }

        function replaceOne() {
            const find = document.getElementById('search-input').value;
            const replace = document.getElementById('replace-input').value;
            if (!find || !editor) return;
            
            const caseSensitive = document.getElementById('search-case').checked;
            const wholeWord = document.getElementById('search-whole').checked;
            const regex = document.getElementById('search-regex').checked;
            
            // Get current selection
            const selection = editor.getSelection();
            if (!selection) return;
            
            const model = editor.getModel();
            if (!model) return;
            
            const text = model.getValueInRange(selection);
            
            // Check if selection matches search (accounting for options)
            let matches = false;
            if (regex) {
                try {
                    const regexPattern = new RegExp(find, caseSensitive ? '' : 'i');
                    matches = regexPattern.test(text);
                } catch (e) {
                    showToast('Invalid regex pattern', 'error');
                    return;
                }
            } else {
                matches = caseSensitive ? text === find : text.toLowerCase() === find.toLowerCase();
                if (wholeWord && matches) {
                    // Check word boundaries
                    const start = selection.getStartPosition();
                    const end = selection.getEndPosition();
                    const startCol = start.column;
                    const endCol = end.column;
                    const line = model.getLineContent(start.lineNumber);
                    
                    const beforeChar = startCol > 1 ? line[startCol - 2] : ' ';
                    const afterChar = endCol <= line.length ? line[endCol - 1] : ' ';
                    
                    const wordBoundary = /\W/;
                    matches = wordBoundary.test(beforeChar) && wordBoundary.test(afterChar);
                }
            }
            
            if (matches) {
                editor.executeEdits('replace', [{
                    range: selection,
                    text: replace
                }]);
                showToast('Replaced 1 occurrence', 'success');
                
                // Find next match after replace
                setTimeout(() => findNext(), 100);
            } else {
                showToast('Selection does not match search', 'error');
            }
        }
        
        function replaceAll() {
            const find = document.getElementById('search-input').value;
            const replace = document.getElementById('replace-input').value;
            if (!find || !editor) return;
            
            const caseSensitive = document.getElementById('search-case').checked;
            const wholeWord = document.getElementById('search-whole').checked;
            const regex = document.getElementById('search-regex').checked;
            
            const model = editor.getModel();
            if (!model) return;
            
            let searchRegex;
            try {
                if (regex) {
                    searchRegex = new RegExp(find, 'g' + (caseSensitive ? '' : 'i'));
                } else {
                    const escapedFind = find.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const pattern = wholeWord ? `\\b${escapedFind}\\b` : escapedFind;
                    searchRegex = new RegExp(pattern, 'g' + (caseSensitive ? '' : 'i'));
                }
            } catch (e) {
                showToast('Invalid search pattern', 'error');
                return;
            }
            
            const content = model.getValue();
            const newContent = content.replace(searchRegex, replace);
            const matches = (content.match(searchRegex) || []).length;
            
            if (matches > 0) {
                model.setValue(newContent);
                showToast(`Replaced ${matches} occurrence${matches === 1 ? '' : 's'}`, 'success');
            } else {
                showToast('No matches found', 'error');
            }
        }

        // ============================================================================
        // SETTINGS
        // ============================================================================
        
        function loadSettings() {
            try {
                const saved = localStorage.getItem(STORAGE_KEYS.settings);
                const savedTheme = localStorage.getItem(STORAGE_KEYS.themeV2);
                const savedShortcuts = localStorage.getItem(STORAGE_KEYS.shortcutsV2);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    if (savedTheme) parsed.theme = savedTheme;
                    if (savedShortcuts) {
                        try {
                            parsed.shortcuts = JSON.parse(savedShortcuts);
                        } catch (_error) {
                            parsed.shortcuts = parsed.shortcuts || {};
                        }
                    }
                    // Validate and merge with defaults
                    return { ...defaultSettings, ...parsed };
                }

                const fallback = { ...defaultSettings };
                if (savedTheme) fallback.theme = savedTheme;
                if (savedShortcuts) {
                    try {
                        fallback.shortcuts = JSON.parse(savedShortcuts);
                    } catch (_error) {
                        fallback.shortcuts = {};
                    }
                }
                return fallback;
            } catch (e) {
                console.error('Failed to load settings:', e);
                // Clear corrupted settings
                localStorage.removeItem(STORAGE_KEYS.settings);
            }
            return { ...defaultSettings };
        }

        function saveSettings() {
            localStorage.setItem(STORAGE_KEYS.settings, JSON.stringify(settings));
            localStorage.setItem(STORAGE_KEYS.themeV2, settings.theme);
            localStorage.setItem(STORAGE_KEYS.shortcutsV2, JSON.stringify(settings.shortcuts || {}));
        }

        function toggleSettings() {
            const panel = document.getElementById('settings-panel');
            panel.classList.toggle('open');
            
            if (panel.classList.contains('open')) {
                // Load current settings into UI
                document.getElementById('setting-theme').value = settings.theme;
                document.getElementById('setting-font-size').value = settings.fontSize;
                document.getElementById('setting-tab-size').value = settings.tabSize;
                document.getElementById('setting-minimap').checked = settings.minimap;
                document.getElementById('setting-line-numbers').checked = settings.lineNumbers;
                document.getElementById('setting-word-wrap').checked = settings.wordWrap;
                document.getElementById('setting-auto-save').value = settings.autoSave;
                document.getElementById('setting-auto-save-delay').value = settings.autoSaveDelay;
                document.dispatchEvent(new CustomEvent('evobrew:settings-opened'));
            }
        }

        function applyTheme() {
            settings.theme = document.getElementById('setting-theme').value;
            monaco.editor.setTheme(settings.theme);
            // Also update body class for CSS theming
            if (settings.theme === 'vs' || settings.theme === 'hc-light') {
                document.body.classList.add('light-theme');
                document.body.setAttribute('data-theme', 'light');
            } else {
                document.body.classList.remove('light-theme');
                document.body.setAttribute('data-theme', 'dark');
            }
            saveSettings();
        }

        function applyFontSize() {
            settings.fontSize = parseInt(document.getElementById('setting-font-size').value);
            editor.updateOptions({ fontSize: settings.fontSize });
            saveSettings();
        }

        function applyTabSize() {
            settings.tabSize = parseInt(document.getElementById('setting-tab-size').value);
            editor.updateOptions({ tabSize: settings.tabSize });
            saveSettings();
        }

        function applyMinimap() {
            settings.minimap = document.getElementById('setting-minimap').checked;
            editor.updateOptions({ minimap: { enabled: settings.minimap } });
            saveSettings();
        }

        function applyLineNumbers() {
            settings.lineNumbers = document.getElementById('setting-line-numbers').checked;
            editor.updateOptions({ lineNumbers: settings.lineNumbers ? 'on' : 'off' });
            saveSettings();
        }

        function applyWordWrap() {
            settings.wordWrap = document.getElementById('setting-word-wrap').checked;
            editor.updateOptions({ wordWrap: settings.wordWrap ? 'on' : 'off' });
            saveSettings();
        }

        function applyAutoSave() {
            settings.autoSave = document.getElementById('setting-auto-save').value;
            settings.autoSaveDelay = parseInt(document.getElementById('setting-auto-save-delay').value);
            saveSettings();
            setupAutoSave();
        }

        function setupAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
            }
            
            if (settings.autoSave === 'afterDelay') {
                autoSaveTimer = setInterval(() => {
                    const hasDirty = Array.from(openFiles.values()).some(f => f.dirty);
                    if (hasDirty) {
                        saveAllFiles();
                    }
                }, settings.autoSaveDelay);
            }
        }

        function resetSettings() {
            if (!confirm('Reset all settings to defaults?')) return;
            
            settings = { ...defaultSettings };
            saveSettings();
            toggleSettings();
            
            // Reload to apply all defaults
            location.reload();
        }

        // ============================================================================
        // WORKSPACE STATE PERSISTENCE
        // ============================================================================
        
        function saveWorkspaceState() {
            const state = {
                openTabs: Array.from(openFiles.keys()),
                activeFile: activeFile,
                sidebarCollapsed: document.getElementById('sidebar').classList.contains('collapsed'),
                pinnedTabs: Array.from(pinnedTabs),
            };
            
            const key = folderPath ? `evobrew-workspace-${folderPath}` : 'evobrew-workspace-default';
            localStorage.setItem(key, JSON.stringify(state));
        }

        function restoreWorkspaceState() {
            if (!folderPath) return;  // No folder selected yet
            const key = folderPath ? `evobrew-workspace-${folderPath}` : 'evobrew-workspace-default';
            const saved = localStorage.getItem(key);
            
            if (!saved) return;
            
            try {
                const state = JSON.parse(saved);
                
                // Restore sidebar state
                if (state.sidebarCollapsed) {
                    toggleSidebar();
                }
                
                // Restore pinned tabs
                if (state.pinnedTabs && Array.isArray(state.pinnedTabs)) {
                    pinnedTabs = new Set(state.pinnedTabs);
                }
                
                // Note: Files are already opened by loadFileTree()
                // Pinned status will be applied when tabs are created
            } catch (e) {
                console.error('Failed to restore workspace:', e);
            }
        }

        // ============================================================================
        // UI HELPERS
        // ============================================================================
        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const expandBtn = document.getElementById('sidebar-expand-btn');
            const isCollapsed = sidebar.classList.toggle('collapsed');

            // Show/hide the expand button
            if (expandBtn) {
                expandBtn.style.display = isCollapsed ? 'flex' : 'none';
            }

            // Update button icon and tooltip
            const toggleBtn = document.querySelector('[data-tooltip="Hide Sidebar"], [data-tooltip="Show Sidebar"]');
            if (toggleBtn) {
                toggleBtn.innerHTML = isCollapsed
                    ? '<svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"m9 6 6 6-6 6\"/></svg>'
                    : '<svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"m15 6-6 6 6 6\"/></svg>';
                toggleBtn.setAttribute('data-tooltip', isCollapsed ? 'Show Sidebar' : 'Hide Sidebar');
                toggleBtn.setAttribute('title', isCollapsed ? 'Show Sidebar' : 'Hide Sidebar');
                toggleBtn.setAttribute('aria-label', isCollapsed ? 'Show Sidebar' : 'Hide Sidebar');
            }
        }
        
        async function refreshFileTree() {
            if (!folderPath) {
                showToast('No folder open', 'error');
                return;
            }

            showToast('Refreshing file tree...', 'info');

            try {
                // Reload the file tree
                await loadFileTree(folderPath);
                showToast('File tree refreshed', 'success');
            } catch (error) {
                console.error('Failed to refresh file tree:', error);
                showToast('Error refreshing file tree', 'error');
            }
        }

        async function goUpDirectory() {
            // Stop at root
            if (!folderPath || folderPath === '/') {
                showToast('Already at root', 'info');
                return;
            }

            const parentPath = folderPath.split('/').slice(0, -1).join('/') || '/';
            await selectAndLoadFolder(parentPath);
        }

        async function goToHomeFolder() {
            // Home means user's working folder, not brain outputs.
            const homePath = workingDirectory;
            if (homePath) {
                await selectAndLoadFolder(homePath, { setAsWorkingDirectory: false, forceBrainView: false, toast: false });
                showToast('Back to working folder', 'success');
            } else {
                showToast('No working folder set yet. Choose a folder first.', 'info');
                await showFolderBrowser(isWindows ? 'C:\\Users' : '/Users');
            }
        }

        // Auto-refresh state
        let autoRefreshInterval = null;
        let autoRefreshEnabled = false;
        const AUTO_REFRESH_MS = 5000; // 5 seconds

        function toggleAutoRefresh() {
            autoRefreshEnabled = !autoRefreshEnabled;
            const btn = document.getElementById('auto-refresh-btn');

            if (autoRefreshEnabled) {
                btn.style.opacity = '1';
                btn.style.background = 'var(--accent-primary)';
                btn.title = 'Auto-refresh ON (every 5s) - click to disable';
                startAutoRefresh();
                showToast('Auto-refresh enabled', 'info');
            } else {
                btn.style.opacity = '0.5';
                btn.style.background = 'none';
                btn.title = 'Toggle auto-refresh (every 5s)';
                stopAutoRefresh();
                showToast('Auto-refresh disabled', 'info');
            }
        }

        function startAutoRefresh() {
            if (autoRefreshInterval) clearInterval(autoRefreshInterval);
            autoRefreshInterval = setInterval(async () => {
                if (folderPath && document.visibilityState === 'visible') {
                    await silentRefreshFileTree();
                }
            }, AUTO_REFRESH_MS);
        }

        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }

        // Silent refresh (no toast) - only updates if file count changed
        async function silentRefreshFileTree() {
            if (!folderPath) return;
            try {
                const data = await FileAPI.listFiles();
                if (!data.success) return;

                const files = Array.isArray(data.files) ? data.files : [];
                const newCount = files.length;
                const oldCount = allFiles.length;

                if (newCount !== oldCount) {
                    allFiles = files;
                    const tree = document.getElementById('file-tree');
                    tree.innerHTML = '';
                    const treeStructure = buildTreeStructure(allFiles, folderPath);
                    renderTree(treeStructure, tree);
                    console.log(`🔄 File tree updated: ${oldCount} → ${newCount} files`);
                }
            } catch (error) {
                console.error('Silent refresh failed:', error);
            }
        }

        // Refresh on window focus (always enabled)
        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible' && folderPath) {
                await silentRefreshFileTree();
            }
        });

        function toggleKeyboardHelp() {
            const help = document.getElementById('keyboard-help');
            const overlay = document.getElementById('overlay');
            help.classList.toggle('hidden');
            overlay.classList.toggle('hidden');
        }

        function closeAllModals() {
            document.getElementById('command-palette').classList.add('hidden');
            document.getElementById('keyboard-help').classList.add('hidden');
            document.getElementById('search-panel').classList.add('hidden');
            document.getElementById('context-menu').classList.add('hidden');
            // Also close folder browser + other modal-style panels
            const folderBrowser = document.getElementById('folder-browser');
            if (folderBrowser) folderBrowser.classList.add('hidden');
            const csvBuilder = document.getElementById('csv-builder');
            if (csvBuilder) csvBuilder.classList.add('hidden');
            document.getElementById('overlay').classList.add('hidden');
            if (typeof closeHeaderOverflow === 'function') {
                closeHeaderOverflow();
            }
            // Note: Don't close AI panel on Escape - it's a persistent panel like preview
        }

        // showContextMenu is defined in CONTEXT MENU section below (line ~10576)
        // It handles file/folder right-click menus

        function copyToClipboard(text) {
            if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text).then(() => {
                showToast('Copied to clipboard', 'success');
                }).catch(err => {
                    console.error('Clipboard copy failed:', err);
                    fallbackCopyToClipboard(text);
                });
            } else {
                fallbackCopyToClipboard(text);
            }
        }
        
        function fallbackCopyToClipboard(text) {
            // Fallback for browsers that don't support clipboard API
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                showToast('Copied to clipboard', 'success');
            } catch (err) {
                console.error('Fallback copy failed:', err);
                showToast('Copy failed', 'error');
            }
            document.body.removeChild(textArea);
        }

        function updateSaveButtons() {
            const activeFileData = activeFile ? openFiles.get(activeFile) : null;
            const currentFileDirty = activeFileData?.dirty || false;
            const isReadOnly = activeFileData?.readOnly || false;
            const isOfficeFile = activeFileData?.isOfficeFile || false;
            const hasDirtyFiles = Array.from(openFiles.values()).some(f => f.dirty && !f.readOnly);
            const hasActiveFile = activeFile !== null;

            // Disable save for read-only files (Office files)
            document.getElementById('save-btn').disabled = !currentFileDirty || isReadOnly;
            document.getElementById('save-all-btn').disabled = !hasDirtyFiles;
            document.getElementById('download-btn').disabled = !hasActiveFile;
            document.getElementById('snapshot-btn').disabled = !hasActiveFile;
            
            // Show upload-replace button only for Office files
            const uploadBtn = document.getElementById('upload-replace-btn');
            if (uploadBtn) {
                uploadBtn.style.display = isOfficeFile ? 'flex' : 'none';
                uploadBtn.disabled = !hasActiveFile || !isOfficeFile;
            }
            
            // Show OnlyOffice edit button for Office files (always available)
            const onlyofficeBtn = document.getElementById('onlyoffice-edit-btn');
            if (onlyofficeBtn) {
                const canUseOnlyOffice = isOfficeFile && !activeFileData?.isImageFile;
                onlyofficeBtn.style.display = canUseOnlyOffice ? 'flex' : 'none';
                onlyofficeBtn.disabled = !canUseOnlyOffice;
            }

            const dirtyCount = Array.from(openFiles.values()).filter(f => f.dirty && !f.readOnly).length;
            if (dirtyCount > 0) {
                document.getElementById('status-dirty').textContent = 
                    `${dirtyCount} unsaved ${dirtyCount === 1 ? 'file' : 'files'}`;
                document.getElementById('status-dirty').style.color = 'var(--warning-color)';
            } else if (isOfficeFile) {
                document.getElementById('status-dirty').textContent = 'DOWNLOAD TO EDIT';
                document.getElementById('status-dirty').style.color = 'var(--info-color, #17a2b8)';
            } else if (isReadOnly) {
                document.getElementById('status-dirty').textContent = 'READ ONLY';
                document.getElementById('status-dirty').style.color = 'var(--text-secondary)';
            } else {
                document.getElementById('status-dirty').textContent = '';
            }
        }

        function updateFileStats() {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) {
                document.getElementById('status-size').textContent = '';
                document.getElementById('status-words').textContent = '';
                return;
            }
            
            const content = fileData.model.getValue();
            const bytes = new Blob([content]).size;
            const size = bytes < 1024 ? `${bytes} B` : 
                        bytes < 1024 * 1024 ? `${(bytes / 1024).toFixed(1)} KB` : 
                        `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
            
            const words = content.split(/\s+/).filter(w => w.length > 0).length;
            
            document.getElementById('status-size').textContent = size;
            document.getElementById('status-words').textContent = `${words} words`;
        }

        function updateSelectionInfo() {
            const selection = editor.getSelection();
            if (!selection) return;
            
            const model = editor.getModel();
            if (!model) return;
            
            const start = model.getOffsetAt(selection.getStartPosition());
            const end = model.getOffsetAt(selection.getEndPosition());
            const length = end - start;
            
            if (length > 0) {
                const lines = selection.endLineNumber - selection.startLineNumber + 1;
                document.getElementById('status-selection').textContent = 
                    `${length} chars, ${lines} lines selected`;
            } else {
                document.getElementById('status-selection').textContent = '';
            }
        }

        function showToast(message, type = 'success', duration = 3000) {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease-out reverse';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        // ============================================================================
        // SYSTEM SWITCHING
        // ============================================================================
        
        async function loadAvailableSystems() {
            try {
            if (IDE_MODE === 'filesystem') return;  // Standalone mode
                const response = await fetch('/api/compiled-docs/all');
                const data = await response.json();
                
                if (data.success) {
                    availableSystems = data.systems;
                    
                    const picker = document.getElementById('system-picker');
                    picker.innerHTML = '';
                    
                    if (availableSystems.length === 0) {
                        picker.innerHTML = '<option value="">No systems compiled yet</option>';
                        picker.disabled = true;
                        return;
                    }
                    
                    const byRun = {};
                    availableSystems.forEach(sys => {
                        if (!byRun[sys.runName]) byRun[sys.runName] = [];
                        byRun[sys.runName].push(sys);
                    });
                    
                    for (const [run, systems] of Object.entries(byRun)) {
                        const group = document.createElement('optgroup');
                        group.label = run;
                        
                        systems.forEach(sys => {
                            const option = document.createElement('option');
                            option.value = `${sys.runName}:${sys.systemId}`;
                            option.textContent = sys.systemId;
                            
                            if (sys.runName === runName && sys.systemId === systemId) {
                                option.selected = true;
                            }
                            
                            group.appendChild(option);
                        });
                        
                        picker.appendChild(group);
                    }
                }
            } catch (error) {
                console.error('Failed to load available systems:', error);
            }
        }
        
        function switchSystem() {
            if (IDE_MODE === 'filesystem') return;  // Standalone mode
            const picker = document.getElementById('system-picker');
            const value = picker.value;
            
            if (!value) return;
            
            const hasDirty = Array.from(openFiles.values()).some(f => f.dirty);
            if (hasDirty) {
                if (!confirm('You have unsaved changes. Switch anyway?')) {
                    picker.value = `${runName}:${systemId}`;
                    return;
                }
            }
            
            const [newRun, newSystem] = value.split(':');
            window.location.href = `/docs-ide?run=${newRun}&system=${newSystem}`;
        }

        // ============================================================================
        // FILE MANAGEMENT
        // ============================================================================
        
        function closeOtherTabs() {
            if (!activeFile) return;
            
            const tabsToClose = Array.from(openFiles.keys()).filter(path => path !== activeFile);
            
            if (tabsToClose.length === 0) {
                showToast('No other tabs to close', 'error');
                return;
            }
            
            const dirtyTabs = tabsToClose.filter(path => openFiles.get(path)?.dirty);
            if (dirtyTabs.length > 0) {
                if (!confirm(`${dirtyTabs.length} tab(s) have unsaved changes. Close anyway?`)) {
                    return;
                }
            }
            
            tabsToClose.forEach(path => closeTab(path));
            showToast(`Closed ${tabsToClose.length} tab(s)`, 'success');
        }
        
        function closeUnpinnedTabs() {
            const tabsToClose = Array.from(openFiles.keys()).filter(path => !pinnedTabs.has(path));
            
            if (tabsToClose.length === 0) {
                showToast('No unpinned tabs to close', 'error');
                return;
            }
            
            const dirtyTabs = tabsToClose.filter(path => openFiles.get(path)?.dirty);
            if (dirtyTabs.length > 0) {
                if (!confirm(`${dirtyTabs.length} unpinned tab(s) have unsaved changes. Close anyway?`)) {
                    return;
                }
            }
            
            tabsToClose.forEach(path => closeTab(path));
            showToast(`Closed ${tabsToClose.length} unpinned tab(s)`, 'success');
        }
        
        function showNewFileDialog() {
            showToast('File creation requires backend API support', 'error');
            // TODO: Implement file creation via API
            // const fileName = prompt('Enter new file name:');
            // if (fileName) {
            //     createNewFile(fileName);
            // }
        }
        
        function renameFileDialog(filePath) {
            const fileData = openFiles.get(filePath);
            if (!fileData) return;
            
            showToast('File rename requires backend API support', 'error');
            // TODO: Implement file rename via API
            // const newName = prompt('Enter new file name:', fileData.name);
            // if (newName && newName !== fileData.name) {
            //     renameFile(filePath, newName);
            // }
        }
        
        function deleteFileDialog(filePath) {
            const fileData = openFiles.get(filePath);
            if (!fileData) return;
            
            if (!confirm(`Delete ${fileData.name}? This action cannot be undone.`)) {
                return;
            }
            
            showToast('File deletion requires backend API support', 'error');
            // TODO: Implement file deletion via API
            // deleteFile(filePath);
        }
        
        function showFindInFiles() {
            const query = prompt('Find in all files:');
            if (!query) return;
            
            showToast('Searching...', 'success');
            
            // Search through all open files and potentially all files in the system
            const results = [];
            
            // Search in open files
            for (const [path, fileData] of openFiles.entries()) {
                const content = fileData.model.getValue();
                const lines = content.split('\n');
                
                lines.forEach((line, lineNumber) => {
                    if (line.toLowerCase().includes(query.toLowerCase())) {
                        results.push({
                            path,
                            name: fileData.name,
                            line: lineNumber + 1,
                            content: line.trim()
                        });
                    }
                });
            }
            
            if (results.length === 0) {
                showToast('No results found in open files', 'error');
                return;
            }
            
            // Show results in command palette
            const palette = document.getElementById('command-palette');
            const input = document.getElementById('command-input');
            const resultsDiv = document.getElementById('command-results');
            const overlay = document.getElementById('overlay');
            
            palette.classList.remove('hidden');
            overlay.classList.remove('hidden');
            input.value = query;
            input.placeholder = `Found ${results.length} result(s)`;
            
            resultsDiv.innerHTML = results.map((result, idx) => `
                <div class="command-item ${idx === 0 ? 'selected' : ''}" data-index="${idx}" onclick="openFileFromPalette('${result.path}', '${result.name}')">
                    <div>
                        <div class="command-label">${result.name}:${result.line}</div>
                        <div style="font-size: 11px; color: var(--text-secondary); margin-top: 2px;">${result.content.substring(0, 80)}...</div>
                    </div>
                </div>
            `).join('');
        }

        // ============================================================================
        // AI ASSISTANT
        // ============================================================================
        
        let aiConversationHistory = [];
        let aiProcessing = false;
        
        function buildFileTreeContext() {
            // Build a compact representation of file tree for AI
            let totalCount = 0; // Shared counter across all recursion levels
            const maxItems = 100;
            
            const flattenTree = (items, depth = 0) => {
                let result = '';
                
                for (const item of items) {
                    if (totalCount >= maxItems) {
                        result += `${'  '.repeat(depth)}... (truncated at ${maxItems} items)\n`;
                        break;
                    }
                    
                    const indent = '  '.repeat(depth);
                    if (item.isDirectory) {
                        result += `${indent}📁 ${item.name}/\n`;
                        totalCount++;
                        if (item.children && depth < 2 && totalCount < maxItems) {
                            result += flattenTree(item.children, depth + 1);
                        }
                    } else {
                        result += `${indent}📄 ${item.name}\n`;
                        totalCount++;
                    }
                }
                return result;
            };
            
            return allFiles && allFiles.length > 0 ? flattenTree(allFiles) : '';
        }
        
        function toggleAI() {
            const panel = document.getElementById('ai-panel');
            const aiBtn = document.getElementById('ai-btn');
            panel.classList.toggle('hidden');

            if (aiBtn) {
                aiBtn.classList.toggle('active', !panel.classList.contains('hidden'));
            }

            if (!panel.classList.contains('hidden')) {
                document.getElementById('ai-input').focus();
                updateTokenCounter(); // Update when panel opens
            }
        }

        // ============================================================================
        // TOKEN COUNTER & CONTEXT MANAGEMENT
        // ============================================================================

        const TOKEN_LIMIT = 200000;
        const AUTO_SUMMARIZE_TOKENS = 150000;
        const AUTO_SUMMARIZE_MESSAGES = 25;
        let conversationSummary = null; // Stores summary of older messages
        let isSummarizing = false;

        /**
         * Estimate tokens for text (~4 characters per token, rough but useful)
         */
        function estimateTokens(text) {
            if (!text) return 0;
            return Math.ceil(text.length / 4);
        }

        /**
         * Calculate total tokens in conversation
         */
        function calculateConversationTokens() {
            let total = 0;

            // Add summary tokens if exists
            if (conversationSummary) {
                total += estimateTokens(conversationSummary);
            }

            // Add each message
            for (const msg of aiConversationHistory) {
                total += estimateTokens(msg.content);
            }

            return total;
        }

        /**
         * Update the token counter UI
         */
        function updateTokenCounter() {
            const tokens = calculateConversationTokens();
            const messageCount = aiConversationHistory.length;

            // Update count display
            const countEl = document.getElementById('token-count');
            const fillEl = document.getElementById('token-status-fill');
            const summarizeBtn = document.getElementById('summarize-btn');

            if (!countEl || !fillEl) return;

            // Format number with K for thousands
            const displayTokens = tokens >= 1000 ? `${Math.round(tokens / 1000)}K` : tokens;
            countEl.textContent = displayTokens;

            // Calculate percentage and status
            const percentage = Math.min((tokens / TOKEN_LIMIT) * 100, 100);
            fillEl.style.width = `${percentage}%`;

            // Set status color
            let status = 'green';
            if (percentage > 75) status = 'red';
            else if (percentage > 50) status = 'yellow';
            fillEl.dataset.status = status;

            // Enable/disable summarize button
            if (summarizeBtn) {
                summarizeBtn.disabled = messageCount < 4 || isSummarizing;
                if (isSummarizing) {
                    summarizeBtn.classList.add('summarizing');
                    summarizeBtn.textContent = 'Summarizing...';
                } else {
                    summarizeBtn.classList.remove('summarizing');
                    summarizeBtn.textContent = conversationSummary ? 'Re-summarize' : 'Summarize';
                }
            }

            // Check for automatic summarization
            checkAutoSummarize(tokens, messageCount);
        }

        /**
         * Check if automatic summarization should trigger
         */
        function checkAutoSummarize(tokens, messageCount) {
            if (isSummarizing) return;
            if (conversationSummary && messageCount <= 10) return; // Already summarized recently

            const shouldSummarize = tokens > AUTO_SUMMARIZE_TOKENS || messageCount > AUTO_SUMMARIZE_MESSAGES;

            if (shouldSummarize && messageCount > 8) {
                console.log(`[TOKEN] Auto-summarizing: ${tokens} tokens, ${messageCount} messages`);
                showToast('Auto-summarizing conversation to free context...', 'info');
                summarizeConversation(true);
            }
        }

        /**
         * Summarize conversation to reduce context window usage
         */
        async function summarizeConversation(isAutomatic = false) {
            if (isSummarizing) return;
            if (aiConversationHistory.length < 4) {
                showToast('Not enough messages to summarize', 'error');
                return;
            }

            isSummarizing = true;
            updateTokenCounter();

            try {
                // Keep last 8 messages intact, summarize the rest
                const keepCount = 8;
                const messagesToSummarize = aiConversationHistory.slice(0, -keepCount);
                const recentMessages = aiConversationHistory.slice(-keepCount);

                if (messagesToSummarize.length < 2) {
                    showToast('Not enough older messages to summarize', 'info');
                    isSummarizing = false;
                    updateTokenCounter();
                    return;
                }

                // Build summary request
                const summaryRequest = {
                    messages: messagesToSummarize.map(m => ({ role: m.role, content: m.content })),
                    existingSummary: conversationSummary
                };

                const response = await fetch('/api/summarize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(summaryRequest)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();

                if (result.success && result.summary) {
                    // Store the summary and keep only recent messages
                    conversationSummary = result.summary;
                    aiConversationHistory = recentMessages;

                    // Update UI with summary indicator
                    const messagesDiv = document.getElementById('ai-chat-messages');
                    const existingSummaryEl = messagesDiv.querySelector('.conversation-summary');
                    if (existingSummaryEl) existingSummaryEl.remove();

                    const summaryEl = document.createElement('div');
                    summaryEl.className = 'conversation-summary';
                    summaryEl.style.cssText = 'padding: 8px 12px; margin: 8px 0; background: rgba(59, 130, 246, 0.1); border-radius: 6px; font-size: 11px; color: var(--text-secondary);';
                    summaryEl.innerHTML = `<details><summary style="cursor: pointer; font-weight: 600;">📋 Earlier conversation summarized (${messagesToSummarize.length} messages)</summary><div style="margin-top: 8px; white-space: pre-wrap; opacity: 0.8;">${escapeHtml(result.summary)}</div></details>`;
                    messagesDiv.insertBefore(summaryEl, messagesDiv.firstChild);

                    // Clear old messages from UI, keep recent
                    const allMsgEls = messagesDiv.querySelectorAll('.ai-message');
                    allMsgEls.forEach((el, i) => {
                        if (i < allMsgEls.length - keepCount) el.remove();
                    });

                    const savedTokens = result.tokensSaved || (estimateTokens(messagesToSummarize.map(m => m.content).join('')) - estimateTokens(result.summary));
                    showToast(`Summarized ${messagesToSummarize.length} messages, saved ~${Math.round(savedTokens / 1000)}K tokens`, 'success');

                    // Update saved conversation
                    await chatHistory.updateCurrentConversation();
                } else {
                    throw new Error(result.error || 'Summarization failed');
                }
            } catch (error) {
                console.error('[SUMMARIZE] Error:', error);
                showToast(`Summarization failed: ${error.message}`, 'error');
            } finally {
                isSummarizing = false;
                updateTokenCounter();
            }
        }

        /**
         * Update a streaming message in real-time (Cursor-style)
         */
        function updateStreamingMessage(messageId, content) {
            const messageDiv = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageDiv) {
                const contentDiv = messageDiv.querySelector('.ai-message-content');
                if (contentDiv && contentDiv.textContent !== content) {  // Only update if changed
                    // Use plain text during streaming for performance
                    contentDiv.textContent = content;

                    // Smart scroll: only if user is near bottom (within 200px)
                    // Larger threshold makes it easier to scroll up and stay there
                    const messagesContainer = document.getElementById('ai-chat-messages');
                    const isNearBottom = messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight < 200;
                    if (isNearBottom) {
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    }
                }
            }
        }
        
        // Global AbortController for stopping AI requests
        let currentAIAbortController = null;

        function handleAIInputKeydown(event) {
            // Shift+Enter = new line (default behavior, do nothing)
            if (event.shiftKey && event.key === 'Enter') {
                return; // Allow default behavior (new line)
            }
            
            // Enter alone = send message (like Cursor)
            if (event.key === 'Enter') {
                event.preventDefault();
                sendAIMessage();
            }
        }

        function stopAIRequest() {
            if (currentAIAbortController) {
                console.log('[AI] Stopping request...');
                currentAIAbortController.abort();
                currentAIAbortController = null;
            }

            // Also handle OpenClaw in-flight requests
            if (openclawActive) {
                console.log('[OpenClaw] Stopping request...');
                stopOpenClawPolling();
                openclawActive = false;
                openclawStreamEl = null;
                openclawStreamAccum = '';
            }

            // Update UI
            removeThinkingIndicator();
            aiProcessing = false;
            document.getElementById('ai-send-btn').style.display = '';
            document.getElementById('ai-stop-btn').style.display = 'none';
            document.getElementById('ai-input').focus();
            addChatMessage('system', 'Request stopped by user');
        }
        
        function syncBrainContextControls() {
            const brainToggle = document.getElementById('brainEnabled');
            const pgsToggle = document.getElementById('query-pgs');
            const pgsControls = document.getElementById('pgs-controls');
            const brainLabel = document.getElementById('brainContextToggleLabel');
            const pgsLabel = document.getElementById('pgsToggleLabel');

            if (!brainToggle || !pgsToggle) return;

            const canUseBrainContext = !brainToggle.disabled && brainToggle.checked;

            if (brainLabel) {
                brainLabel.classList.toggle('disabled', brainToggle.disabled);
            }

            pgsToggle.disabled = !canUseBrainContext;
            if (!canUseBrainContext) {
                pgsToggle.checked = false;
            }

            if (pgsLabel) {
                pgsLabel.classList.toggle('disabled', !canUseBrainContext);
                pgsLabel.setAttribute(
                    'title',
                    canUseBrainContext
                        ? 'Use PGS retrieval strategy for this chat when brain context is enabled (slower, deeper).'
                        : 'Enable "Use Brain" first to enable PGS retrieval.'
                );
            }

            if (pgsControls) {
                pgsControls.style.display = canUseBrainContext && pgsToggle.checked ? 'flex' : 'none';
            }
        }

        function togglePGSControls() {
            syncBrainContextControls();
        }

        async function sendAIMessage() {
            const input = document.getElementById('ai-input');
            const message = input.value.trim();
            
            if (!message || aiProcessing) return;
            
            // Get current file context
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            const documentContent = fileData ? fileData.model.getValue() : '';
            const fileName = fileData ? fileData.name : 'untitled';
            const language = fileData ? fileData.model.getLanguageId() : 'text';
            
            // Get selected text if any
            const selection = editor.getSelection();
            const selectedText = selection && !selection.isEmpty() ? 
                editor.getModel().getValueInRange(selection) : null;
            
            // Add user message to chat
            addChatMessage('user', message);
            updateTokenCounter();

            // Clear input
            input.value = '';
            
            // Show thinking indicator
            aiProcessing = true;
            addThinkingIndicator();
            document.getElementById('ai-send-btn').style.display = 'none';
            document.getElementById('ai-stop-btn').style.display = '';

            // Prepare streaming message ID but DON'T create it yet
            // We'll create the assistant message when first response_chunk arrives
            const streamingMessageId = `streaming-${Date.now()}`;
            let assistantMessageCreated = false;

            // Use a turn-specific tools container ID - all tools in this turn share ONE container
            const toolsContainerId = `ai-tools-${streamingMessageId}`;

            // Create new AbortController for this request
            currentAIAbortController = new AbortController();
            
            try {
                // Build file tree context (just structure, not content)
                const fileTreeContext = buildFileTreeContext();
                
                // Get selected model
                const selectedModel = document.getElementById('ai-model-select')?.value || 'claude-sonnet-4-5';

                const brainContextEnabled = (document.getElementById('brainEnabled')?.checked ?? false) && !(document.getElementById('brainEnabled')?.disabled ?? false);
                const pgsEnabled = brainContextEnabled && (document.getElementById('query-pgs')?.checked || false) && !(document.getElementById('query-pgs')?.disabled ?? false);

                // Route to OpenClaw Gateway if OpenClaw model selected
                if (selectedModel.startsWith('openclaw:')) {
                    try {
                        await sendViaOpenClaw(message, {
                            fileName, language, documentContent, selectedText,
                            currentFolder: IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.'),
                            fileTreeContext,
                            brainEnabled: brainContextEnabled,
                            brainPath: window.currentBrainInfo?.brainPath || null,
                            terminalClientId: window.getTerminalClientId ? window.getTerminalClientId() : '',
                            conversationHistory: aiConversationHistory.slice(-12)
                        });
                    } catch (err) {
                        removeThinkingIndicator();
                        addChatMessage('error', `OpenClaw error: ${err.message}`);
                        aiProcessing = false;
                        document.getElementById('ai-send-btn').style.display = '';
                        document.getElementById('ai-stop-btn').style.display = 'none';
                    }
                    // Don't reset UI here — response arrives async via Gateway events.
                    // The chat.final event handler resets buttons and state.
                    return;
                }

                // Use streaming for real-time response (Cursor-style)
                const requestBody = {
                    message,
                    documentContent,
                    selectedText,
                    fileName,
                    language,
                    fileTreeContext,
                    currentFolder: IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.'),
                    model: selectedModel,
                    conversationHistory: aiConversationHistory.slice(-12),
                    conversationSummary: conversationSummary, // Include summary for context
                    stream: true,  // Enable streaming
                    brainEnabled: brainContextEnabled,
                    brainPath: window.currentBrainInfo?.brainPath || null,
                    terminalClientId: window.getTerminalClientId ? window.getTerminalClientId() : '',
                    enablePGS: pgsEnabled,
                    pgsMode: document.getElementById('query-pgs-mode')?.value || 'full',
                    pgsSessionId: (document.getElementById('query-pgs-session')?.value || '').trim() || 'default',
                    pgsFullSweep: (document.getElementById('query-pgs-mode')?.value || 'full') === 'full'
                };
                
                // Handle streaming response with incremental file creation (look-ahead pattern)
                let fullResponse = '';
                let data = null;
                let pendingFile = null; // {path, content} - file being streamed
                const currentFolderForRealtime = IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
                let realtimeCreatedPaths = new Set(); // Track files created during streaming
                
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: currentAIAbortController.signal
                });
                
                // Handle SSE streaming with tool feedback
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let toolFeedbackMessage = null;
                let buffer = ''; // Buffer for incomplete lines
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;

                    // Split by SSE message boundary (double newline)
                    const messages = buffer.split('\n\n');

                    // Keep last incomplete message in buffer
                    buffer = messages.pop() || '';

                    // Process complete messages
                    for (const message of messages) {
                        const lines = message.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const jsonStr = line.slice(6).trim();
                                    if (!jsonStr) continue; // Skip empty data lines
                                    const event = JSON.parse(jsonStr);
                                
                                // Handle different event types
                                console.log('[EVENT RECEIVED]', event.type, event);
                                
                                if (event.type === 'error') {
                                    throw new Error(event.error);
                                }

                                else if (event.type === 'debug') {
                                    console.log('[DEBUG FROM SERVER]', event.message);
                                }

                                else if (event.type === 'status') {
                                    // Backend status update - show in thinking indicator
                                    updateThinkingStatus(event.message);
                                }

                                else if (event.type === 'brain_search') {
                                    // Show brain search status in UI
                                    if (event.status === 'searching') {
                                        console.log('[BRAIN] Searching brain...');
                                        // Show searching indicator
                                        const searchingDiv = document.createElement('div');
                                        searchingDiv.className = 'ai-brain-context';
                                        searchingDiv.id = 'brain-searching-indicator';
                                        searchingDiv.innerHTML = `<div style="padding: 8px; color: #c8a8e8;">🧠 Searching brain for relevant knowledge...</div>`;
                                        const chatMessages = document.getElementById('ai-chat-messages');
                                        if (chatMessages) chatMessages.appendChild(searchingDiv);
                                    } else if (event.status === 'not_loaded') {
                                        console.log('[BRAIN] ⚠️ Brain not loaded on server');
                                        const errorDiv = document.createElement('div');
                                        errorDiv.className = 'ai-brain-context';
                                        errorDiv.innerHTML = `<div style="padding: 8px; color: #f0a090;">🧠 ⚠️ Brain not loaded - ${event.error || 'unknown error'}</div>`;
                                        const chatMessages = document.getElementById('ai-chat-messages');
                                        if (chatMessages) chatMessages.appendChild(errorDiv);
                                    }
                                }

                                else if (event.type === 'brain_context') {
                                    // Show brain context in UI - append to chat messages like tools do
                                    // Remove "searching" indicator if present
                                    const searchingIndicator = document.getElementById('brain-searching-indicator');
                                    if (searchingIndicator) searchingIndicator.remove();

                                    if (event.status === 'injected' && event.nodes) {
                                        console.log(`[BRAIN] ✅ ${event.nodesInjected} neurons fired (${event.candidatesFound} candidates from ${event.totalSearched} nodes)`);

                                        // Create brain context UI section
                                        const brainContainer = document.createElement('div');
                                        brainContainer.className = 'ai-brain-context';
                                        brainContainer.id = 'brain-context-' + Date.now();
                                        brainContainer.innerHTML = `
                                            <details>
                                                <summary>🧠 Brain Context: ${event.nodesInjected} neurons fired (${event.candidatesFound} candidates from ${event.totalSearched} nodes)</summary>
                                                <div class="brain-stats">
                                                    <span>Searched: ${event.totalSearched}</span>
                                                    <span>Candidates: ${event.candidatesFound}</span>
                                                    <span>Injected: ${event.nodesInjected}</span>
                                                    <span>Threshold: ${event.scoreThreshold}</span>
                                                </div>
                                                <div class="brain-nodes-list">
                                                    ${event.nodes.map((n, i) => `
                                                        <div class="brain-node ${n.connected ? 'connected' : ''}">
                                                            <div class="brain-node-header">
                                                                <span class="node-rank">#${i+1}</span>
                                                                <span class="node-score" style="background: hsl(${Math.round(n.score * 120)}, 70%, 40%)">${n.score}</span>
                                                                <span class="node-tag">${n.tag || 'untagged'}</span>
                                                                <span class="node-id">id:${n.id}</span>
                                                                ${n.connected ? '<span class="node-connected">⚡ connected</span>' : ''}
                                                            </div>
                                                            <div class="brain-node-preview">${n.preview}...</div>
                                                        </div>
                                                    `).join('')}
                                                </div>
                                            </details>
                                        `;

                                        // Append to chat messages container (same as tools)
                                        const chatMessages = document.getElementById('ai-chat-messages');
                                        if (chatMessages) {
                                            chatMessages.appendChild(brainContainer);
                                            // Scroll to show brain context
                                            brainContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                                        }
                                    } else if (event.status === 'no_results') {
                                        console.log('[BRAIN] No relevant brain nodes found');
                                        // Show "no results" indicator
                                        const noResultsDiv = document.createElement('div');
                                        noResultsDiv.className = 'ai-brain-context';
                                        noResultsDiv.innerHTML = `<div style="padding: 8px; color: #a0a0b0;">🧠 Brain searched ${event.totalSearched || 0} nodes - no relevant matches found</div>`;
                                        const chatMessages = document.getElementById('ai-chat-messages');
                                        if (chatMessages) chatMessages.appendChild(noResultsDiv);
                                    }
                                }

                                else if (event.type === 'iteration') {
                                    console.log(`[AI] Iteration ${event.iteration}/${event.max}`);
                                    updateThinkingStatus(`AI working (step ${event.iteration}/${event.max})...`);
                                }
                                
                                else if (event.type === 'tool_preparing') {
                                    // AI is streaming a tool call from the API - show early feedback
                                    updateThinkingStatus(`Preparing ${event.tool}...`);
                                    const icon = event.tool === 'file_read' ? '📖' :
                                                event.tool === 'list_directory' ? '📁' :
                                                event.tool === 'read_image' ? '🖼️' :
                                                event.tool === 'create_image' ? '🎨' :
                                                event.tool === 'edit_image' ? '✏️' :
                                                event.tool === 'grep_search' ? '🔍' :
                                                event.tool === 'codebase_search' ? '🧠' :
                                                event.tool === 'edit_file' ? '✏️' :
                                                event.tool === 'create_file' ? '📝' :
                                                event.tool === 'create_docx' ? '📄' :
                                                event.tool === 'create_xlsx' ? '📊' :
                                                (event.tool === 'run_terminal' || event.tool.startsWith('terminal_')) ? '💻' :
                                                event.tool === 'delete_file' ? '🗑️' : '🔧';

                                    let toolsContainer = document.getElementById(toolsContainerId);
                                    if (!toolsContainer) {
                                        toolsContainer = document.createElement('div');
                                        toolsContainer.id = toolsContainerId;
                                        toolsContainer.className = 'ai-tools-section';
                                        toolsContainer.innerHTML = `
                                            <details open>
                                                <summary>🔧 Preparing tools...</summary>
                                                <div class="ai-tools-list"></div>
                                            </details>
                                        `;
                                        document.getElementById('ai-chat-messages').appendChild(toolsContainer);
                                    }
                                    const toolsList = toolsContainer.querySelector('.ai-tools-list');
                                    // Only add if not already shown for this tool
                                    if (!toolsContainer.querySelector(`[data-tool-id="${event.id}"]`)) {
                                        const toolDiv = document.createElement('div');
                                        toolDiv.className = 'tool-item tool-preparing';
                                        toolDiv.dataset.toolId = event.id;
                                        toolDiv.innerHTML = `<span class="tool-icon">${icon}</span><span class="tool-status">⏳</span><span class="tool-text">${escapeHtml(event.tool)} (preparing...)</span>`;
                                        toolsList.appendChild(toolDiv);
                                    }
                                }

                                else if (event.type === 'tool_progress') {
                                    // Tool input is being streamed from API - update the preparing item
                                    const toolsContainer = document.getElementById(toolsContainerId);
                                    if (toolsContainer) {
                                        const preparingItem = toolsContainer.querySelector(`[data-tool-id="${event.id}"]`);
                                        if (preparingItem) {
                                            const sizeStr = event.bytes > 1024 ? `${(event.bytes / 1024).toFixed(1)}KB` : `${event.bytes}B`;
                                            const textSpan = preparingItem.querySelector('.tool-text');
                                            if (textSpan) textSpan.textContent = `${event.tool} (receiving ${sizeStr}...)`;
                                        }
                                    }
                                }

                                else if (event.type === 'tools_start') {
                                    // Update thinking indicator - tools are now running
                                    updateThinkingStatus(`Running ${event.tools.length} tool${event.tools.length > 1 ? 's' : ''}...`);
                                    // Create ONE tools container for ALL tools in this entire turn
                                    console.log(`[AI] Starting ${event.tools.length} tools`);
                                    let toolsContainer = document.getElementById(toolsContainerId);
                                    if (!toolsContainer) {
                                        toolsContainer = document.createElement('div');
                                        toolsContainer.id = toolsContainerId;
                                        toolsContainer.className = 'ai-tools-section';
                                        toolsContainer.innerHTML = `
                                            <details open>
                                                <summary>🔧 Running tools...</summary>
                                                <div class="ai-tools-list"></div>
                                            </details>
                                        `;
                                        document.getElementById('ai-chat-messages').appendChild(toolsContainer);
                                    }
                                }
                                
                                else if (event.type === 'tool_start') {
                                    // Tool is now executing - update preparing item or create new
                                    const icon = event.tool === 'file_read' ? '📖' :
                                                event.tool === 'list_directory' ? '📁' :
                                                event.tool === 'read_image' ? '🖼️' :
                                                event.tool === 'create_image' ? '🎨' :
                                                event.tool === 'edit_image' ? '✏️' :
                                                event.tool === 'grep_search' ? '🔍' :
                                                event.tool === 'codebase_search' ? '🧠' :
                                                event.tool === 'edit_file' ? '✏️' :
                                                event.tool === 'create_file' ? '📝' :
                                                event.tool === 'create_docx' ? '📄' :
                                                event.tool === 'create_xlsx' ? '📊' :
                                                (event.tool === 'run_terminal' || event.tool.startsWith('terminal_')) ? '💻' :
                                                event.tool === 'delete_file' ? '🗑️' : '🔧';

                                    // Get or create tools container (using turn-specific ID)
                                    let toolsContainer = document.getElementById(toolsContainerId);
                                    if (!toolsContainer) {
                                        toolsContainer = document.createElement('div');
                                        toolsContainer.id = toolsContainerId;
                                        toolsContainer.className = 'ai-tools-section';
                                        toolsContainer.innerHTML = `
                                            <details open>
                                                <summary>🔧 Running tools...</summary>
                                                <div class="ai-tools-list"></div>
                                            </details>
                                        `;
                                        document.getElementById('ai-chat-messages').appendChild(toolsContainer);
                                    }

                                    // Update summary to "Running"
                                    const summary = toolsContainer.querySelector('summary');
                                    if (summary) summary.textContent = '🔧 Running tools...';

                                    const argStr = event.args?.file_path || event.args?.directory_path || event.args?.query || event.args?.pattern || event.args?.command || '';
                                    const toolsList = toolsContainer.querySelector('.ai-tools-list');

                                    // Check if there's a preparing item for this tool we can update
                                    const preparingItem = toolsContainer.querySelector(`.tool-preparing`);
                                    if (preparingItem && preparingItem.querySelector('.tool-text')?.textContent?.startsWith(event.tool)) {
                                        preparingItem.className = 'tool-item tool-running';
                                        preparingItem.dataset.toolIndex = event.index;
                                        preparingItem.innerHTML = `<span class="tool-icon">${icon}</span><span class="tool-status">⏳</span><span class="tool-text">${escapeHtml(event.tool)}${argStr ? ': ' + escapeHtml(argStr.substring(0, 50)) + (argStr.length > 50 ? '...' : '') : ''}</span>`;
                                    } else {
                                        const toolDiv = document.createElement('div');
                                        toolDiv.className = 'tool-item tool-running';
                                        toolDiv.dataset.toolIndex = event.index;
                                        toolDiv.innerHTML = `<span class="tool-icon">${icon}</span><span class="tool-status">⏳</span><span class="tool-text">${escapeHtml(event.tool)}${argStr ? ': ' + escapeHtml(argStr.substring(0, 50)) + (argStr.length > 50 ? '...' : '') : ''}</span>`;
                                        toolsList.appendChild(toolDiv);
                                    }
                                }
                                
                                else if (event.type === 'tool_complete') {
                                    console.log(`[AI] ${event.tool} complete`);
                                    // Tool complete is just for logging, result will show in tool_result event
                                }
                                
                                else if (event.type === 'thinking') {
                                    // Add thinking to the unified tools container for this turn
                                    console.log('[FRONTEND] THINKING EVENT:', event.content);

                                    // Get or create tools container (using turn-specific ID)
                                    let toolsContainer = document.getElementById(toolsContainerId);
                                    if (!toolsContainer) {
                                        toolsContainer = document.createElement('div');
                                        toolsContainer.id = toolsContainerId;
                                        toolsContainer.className = 'ai-tools-section';
                                        toolsContainer.innerHTML = `
                                            <details open>
                                                <summary>💭 Thinking...</summary>
                                                <div class="ai-tools-list"></div>
                                            </details>
                                        `;
                                        document.getElementById('ai-chat-messages').appendChild(toolsContainer);
                                    }

                                    const toolsList = toolsContainer.querySelector('.ai-tools-list');
                                    const thinkingDiv = document.createElement('div');
                                    thinkingDiv.className = 'thinking-item';
                                    thinkingDiv.innerHTML = `<span class="thinking-icon">💭</span><span class="thinking-text">${escapeHtml(event.content)}</span>`;
                                    toolsList.appendChild(thinkingDiv);

                                    console.log('[FRONTEND] Added thinking message');
                                }
                                
                                else if (event.type === 'tool_result') {
                                    // Update tool status in the unified tools container for this turn
                                    console.log('[FRONTEND] TOOL_RESULT EVENT:', event);

                                    const icon = event.tool === 'list_directory' ? '📁' :
                                                event.tool === 'file_read' ? '📖' :
                                                event.tool === 'read_image' ? '🖼️' :
                                                event.tool === 'create_image' ? '🎨' :
                                                event.tool === 'edit_image' ? '✏️' :
                                                event.tool === 'grep_search' ? '🔍' :
                                                event.tool === 'codebase_search' ? '🧠' :
                                                event.tool === 'edit_file' ? '✏️' :
                                                event.tool === 'create_file' ? '📝' :
                                                event.tool === 'create_docx' ? '📄' :
                                                event.tool === 'create_xlsx' ? '📊' :
                                                (event.tool === 'run_terminal' || event.tool.startsWith('terminal_')) ? '💻' :
                                                event.tool === 'delete_file' ? '🗑️' : '🔧';
                                    const statusIcon = event.success ? '✓' : '✗';

                                    const toolsContainer = document.getElementById(toolsContainerId);
                                    if (toolsContainer) {
                                        // Update existing running tool or append new
                                        let toolDiv = toolsContainer.querySelector(`[data-tool-index="${event.index}"]`);
                                        if (toolDiv) {
                                            toolDiv.className = `tool-item ${event.success ? 'tool-success' : 'tool-error'}`;
                                            toolDiv.innerHTML = `<span class="tool-icon">${icon}</span><span class="tool-status">${statusIcon}</span><span class="tool-text">${escapeHtml(event.summary)}</span>`;
                                        } else {
                                            // Fallback: append as new item
                                            const toolsList = toolsContainer.querySelector('.ai-tools-list');
                                            toolDiv = document.createElement('div');
                                            toolDiv.className = `tool-item ${event.success ? 'tool-success' : 'tool-error'}`;
                                            toolDiv.innerHTML = `<span class="tool-icon">${icon}</span><span class="tool-status">${statusIcon}</span><span class="tool-text">${escapeHtml(event.summary)}</span>`;
                                            toolsList.appendChild(toolDiv);
                                        }
                                    }

                                    console.log('[FRONTEND] Updated tool result');
                                }
                                
                                else if (event.type === 'response_chunk') {
                                    // Remove thinking indicator - response is arriving
                                    removeThinkingIndicator();
                                    // Remove any temp feedback messages
                                    if (toolFeedbackMessage) {
                                        removeChatMessage(toolFeedbackMessage);
                                        toolFeedbackMessage = null;
                                    }

                                    // Create assistant message on FIRST chunk only
                                    if (!assistantMessageCreated) {
                                        addChatMessage('assistant', '', { streaming: true, messageId: streamingMessageId });
                                        assistantMessageCreated = true;
                                    }

                                    fullResponse += event.chunk;
                                    updateStreamingMessage(streamingMessageId, fullResponse);
                                }
                                
                                else if (event.type === 'complete') {
                                        console.log('[FRONTEND] Complete event received, rendering markdown...');

                                        // Mark tools container as completed but keep it open briefly
                                        const toolsContainer = document.getElementById(toolsContainerId);
                                        if (toolsContainer) {
                                            const summary = toolsContainer.querySelector('summary');
                                            if (summary) summary.textContent = '🔧 Tools (completed)';
                                            // Collapse after 3 seconds so user can see what happened
                                            setTimeout(() => {
                                                const details = toolsContainer.querySelector('details');
                                                if (details) details.open = false;
                                            }, 3000);
                                        }

                                        // Remove tool feedback if still showing
                                        if (toolFeedbackMessage) {
                                            removeChatMessage(toolFeedbackMessage);
                                            toolFeedbackMessage = null;
                                        }

                                        // Render final markdown
                                        console.log('[FRONTEND] Complete event - server fullResponse length:', event.fullResponse?.length, 'accumulated fullResponse length:', fullResponse?.length);
                                        const finalContent = event.fullResponse || fullResponse;

                                        // If message wasn't created yet (no chunks received), create it now
                                        // Always create if not yet created — even if empty, so we can show error
                                        if (!assistantMessageCreated) {
                                            addChatMessage('assistant', '', { streaming: true, messageId: streamingMessageId });
                                            assistantMessageCreated = true;
                                        }

                                        const messageDiv = document.querySelector(`[data-message-id="${streamingMessageId}"]`);
                                        console.log('[FRONTEND] Found message div:', !!messageDiv, 'Content length:', finalContent?.length);
                                        
                                        // Handle empty response gracefully
                                        if (!finalContent || !finalContent.trim()) {
                                            if (messageDiv) {
                                                const contentDiv = messageDiv.querySelector('.ai-message-content');
                                                if (contentDiv) {
                                                    contentDiv.innerHTML = '<em style="color: var(--text-secondary);">No response received from model. This may be a temporary API issue — try again.</em>';
                                                }
                                            }
                                        }

                                        if (messageDiv) {
                                            const contentDiv = messageDiv.querySelector('.ai-message-content');
                                            if (contentDiv && finalContent) {
                                                try {
                                                    // Render markdown
                                                    if (typeof marked !== 'undefined' && marked.parse) {
                                                        contentDiv.innerHTML = renderMarkdownSafe(finalContent);
                                                        console.log('[FRONTEND] Markdown rendered successfully');
                                                        
                                                        // Highlight code blocks
                                                        contentDiv.querySelectorAll('pre code').forEach((block) => {
                                                            if (typeof hljs !== 'undefined') {
                                                                hljs.highlightElement(block);
                                                            }
                                                        });
                                                    } else {
                                                        console.warn('[FRONTEND] marked.js not available, using plain text');
                                                        contentDiv.textContent = finalContent;
                                                    }
                                                } catch (err) {
                                                    console.error('[FRONTEND] Error rendering markdown:', err);
                                                    contentDiv.textContent = finalContent; // Fallback to plain text
                                                }
                                            }
                                            // Update header to remove "streaming..."
                                            const headerDiv = messageDiv.querySelector('.ai-message-header');
                                            if (headerDiv) {
                                                headerDiv.textContent = 'AI Assistant';
                                                console.log('[FRONTEND] Header updated to remove streaming indicator');
                                            }
                                        } else {
                                            console.error('[FRONTEND] Could not find streaming message div:', streamingMessageId);
                                        }
                                        
                                        // Handle pending edits (show in queue, not auto-apply)
                                        if (event.pendingEdits && event.pendingEdits.length > 0) {
                                            console.log(`[AI] ${event.pendingEdits.length} edit(s) pending review`);
                                            for (const edit of event.pendingEdits) {
                                                // Add to edit queue for user review
                                                addToEditQueue(edit.file, edit.instructions, edit.edit);
                                            }
                                            
                                            // Show notification
                                            const editsMsg = event.pendingEdits.length === 1 ? '1 edit' : `${event.pendingEdits.length} edits`;
                                            addChatMessage('system', `${editsMsg} added to queue for review`, {});
                                        }
                                        
                                        data = {
                                            success: true,
                                            response: event.fullResponse || fullResponse,
                                            tokensUsed: event.tokensUsed || 0,
                                            iterations: event.iterations || 0,
                                            model: selectedModel
                                        };
                                    }
                                } catch (e) {
                                    console.error('Failed to parse SSE event:', e);
                                }
                            }
                        }
                    }
                }
                
                removeThinkingIndicator();
                
                // Finalize any active details container
                const finalDetailsContainer = document.getElementById('ai-details-active');
                if (finalDetailsContainer) {
                    finalDetailsContainer.id = '';
                }
                
                // Function calling v2: tools executed server-side, response is clean
                // No need to parse for READ_FILE, GREP, etc. - already handled
                
                if (!data || !data.success) {
                    throw new Error(data?.error || 'AI request failed');
                }
                
                // Add final response to conversation history
                aiConversationHistory.push(
                    { role: 'user', content: message },
                    { role: 'assistant', content: data.response }
                );
                
                // Auto-save conversation (Cursor-style)
                await chatHistory.saveMessage('user', message);
                await chatHistory.saveMessage('assistant', data.response);
                
                // Limit history size (keep last 24 messages = 12 exchanges)
                if (aiConversationHistory.length > 24) {
                    aiConversationHistory = aiConversationHistory.slice(-24);
                }

                // Update token counter after response
                updateTokenCounter();

            } catch (error) {
                removeThinkingIndicator();
                
                // Handle abort differently from other errors
                if (error.name === 'AbortError') {
                    console.log('[AI] Request aborted by user');
                    // Remove the streaming message if it was created
                    const streamingMsg = document.querySelector(`[data-message-id="${streamingMessageId}"]`);
                    if (streamingMsg) {
                        streamingMsg.remove();
                    }
                    // Also clean up the tools container for this turn
                    const toolsContainer = document.getElementById(toolsContainerId);
                    if (toolsContainer) {
                        const summary = toolsContainer.querySelector('summary');
                        if (summary) summary.textContent = '🔧 Tools (cancelled)';
                        const details = toolsContainer.querySelector('details');
                        if (details) details.open = false;
                    }
                } else {
                    addChatMessage('error', `Error: ${error.message}`);
                    console.error('AI chat error:', error);
                }
            } finally {
                aiProcessing = false;
                currentAIAbortController = null;
                document.getElementById('ai-send-btn').style.display = '';
                document.getElementById('ai-stop-btn').style.display = 'none';
                input.focus();
            }
        }
        
        // REMOVED OLD TEXT-BASED TOOL HANDLING CODE (~650 lines)
        // Function calling v2 handles all tools server-side (READ_FILE, GREP, etc.)
        
        // addChatMessage defined below (keeping original)

        function addChatMessage(type, content, options = {}) {
            const messagesDiv = document.getElementById('ai-chat-messages');
            
            // Remove welcome message if present (checking for the container or the emoji)
            const welcome = messagesDiv.querySelector('[style*="text-align: center"]');
            if (welcome && (welcome.textContent.includes('Ask me anything') || welcome.textContent.includes('New conversation'))) {
                welcome.remove();
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `ai-message ${type}`;
            
            // Add message ID for streaming updates
            if (options.messageId) {
                messageDiv.dataset.messageId = options.messageId;
            }
            
            const headerText = type === 'user' ? '👤 YOU' : 
                              type === 'assistant' ? (options.streaming ? '🤖 AI Assistant (streaming...)' : '🤖 AI Assistant') : 
                              type === 'system' ? '⚙️ System' :
                              type === 'error' ? '❌ Error' : 
                              '';
            
            // Render content based on type
            let renderedContent;
            if (options.streaming) {
                renderedContent = '▋';
            } else if (type === 'assistant') {
                // Use marked.js for beautiful markdown rendering
                renderedContent = renderMarkdownSafe(content);
            } else {
                // For user/system/error messages, escape HTML
                renderedContent = escapeHtml(content);
            }
            
            let html = `
                <div class="ai-message-header">${headerText}</div>
                <div class="ai-message-content">${renderedContent}</div>
            `;
            
            // Add action buttons for assistant messages
            if (type === 'assistant' && options.canApply) {
                html += `
                    <div class="ai-message-actions">
                        <button class="btn btn-secondary" onclick="applyAISuggestion(this)" style="padding: 4px 12px; font-size: 11px;">
                            ✓ Apply
                        </button>
                        <button class="btn btn-secondary" onclick="copyAISuggestion(this)" style="padding: 4px 12px; font-size: 11px;">
                            📋 Copy
                        </button>
                    </div>
                `;
            }
            
            messageDiv.innerHTML = html;
            
            // Highlight code blocks
            if (type === 'assistant') {
                messageDiv.querySelectorAll('pre code').forEach((block) => {
                    hljs.highlightElement(block);
                });
            }
            
            // Store response content for apply button
            if (options.canApply) {
                messageDiv.dataset.response = content;
                
                // Store original text for diff view
                const selection = editor.getSelection();
                const model = editor.getModel();
                if (selection && !selection.isEmpty()) {
                    messageDiv.dataset.originalText = model.getValueInRange(selection);
                } else if (model) {
                    messageDiv.dataset.originalText = model.getValue();
                }
            }
            
            // Check if user has scrolled up (reading old messages)
            // Use 200px threshold - if user scrolls more than 200px up, don't auto-scroll
            const isNearBottom = messagesDiv.scrollHeight - messagesDiv.scrollTop <= messagesDiv.clientHeight + 200;

            // Always append messages in chronological order
            messagesDiv.appendChild(messageDiv);

            // Only auto-scroll if user is already near the bottom (don't hijack if reading)
            if (isNearBottom) {
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
            
            return messageDiv; // Return for later updates/removal
        }
        
        function updateChatMessage(messageElement, newContent) {
            if (!messageElement) return;
            const contentDiv = messageElement.querySelector('.ai-message-content');
            if (contentDiv) {
                // If it's an assistant message, use marked.js for markdown rendering
                if (messageElement.classList.contains('assistant')) {
                    contentDiv.innerHTML = renderMarkdownSafe(newContent);
                    // Highlight code blocks
                    messageElement.querySelectorAll('pre code').forEach((block) => {
                        hljs.highlightElement(block);
                    });
                } else {
                    contentDiv.textContent = newContent;
                }
                
                // Only auto-scroll if user is near bottom (don't interrupt reading)
                const messagesDiv = document.getElementById('ai-chat-messages');
                const isNearBottom = messagesDiv.scrollHeight - messagesDiv.scrollTop <= messagesDiv.clientHeight + 150;
                if (isNearBottom) {
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                }
            }
        }
        
        function removeChatMessage(messageElement) {
            if (messageElement && messageElement.parentNode) {
                messageElement.remove();
            }
        }
        
        let _thinkingTimerInterval = null;
        let _thinkingStartTime = null;

        function addThinkingIndicator() {
            removeThinkingIndicator(); // Clear any existing
            _thinkingStartTime = Date.now();
            const messagesDiv = document.getElementById('ai-chat-messages');
            const thinking = document.createElement('div');
            thinking.id = 'ai-thinking';
            thinking.className = 'ai-thinking';
            thinking.innerHTML = `
                <div class="ai-thinking-spinner"></div>
                <span class="ai-thinking-text">AI is thinking...</span>
                <span class="ai-thinking-timer">0s</span>
            `;
            messagesDiv.appendChild(thinking);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            // Live elapsed timer - updates every second
            _thinkingTimerInterval = setInterval(() => {
                const el = document.getElementById('ai-thinking');
                if (!el) { clearInterval(_thinkingTimerInterval); return; }
                const elapsed = Math.floor((Date.now() - _thinkingStartTime) / 1000);
                const timerSpan = el.querySelector('.ai-thinking-timer');
                if (timerSpan) timerSpan.textContent = `${elapsed}s`;
            }, 1000);
        }

        function updateThinkingStatus(text) {
            const el = document.getElementById('ai-thinking');
            if (el) {
                const textSpan = el.querySelector('.ai-thinking-text');
                if (textSpan) textSpan.textContent = text;
            }
        }

        function removeThinkingIndicator() {
            if (_thinkingTimerInterval) { clearInterval(_thinkingTimerInterval); _thinkingTimerInterval = null; }
            const thinking = document.getElementById('ai-thinking');
            if (thinking) {
                thinking.remove();
            }
        }
        
        async function aiQuickAction(action) {
            const fileData = activeFile ? openFiles.get(activeFile) : null;
            if (!fileData) {
                showToast('No file open', 'error');
                return;
            }
            
            // Get selected text if any
            const selection = editor.getSelection();
            const selectedText = selection && !selection.isEmpty() ? 
                editor.getModel().getValueInRange(selection) : null;
            
            const actionMap = {
                'improve': selectedText ? 
                    'Improve this selected text - make it clearer and more professional' : 
                    'Review this document and suggest improvements',
                'summarize': 'Provide a concise summary of this document',
                'grammar': selectedText ? 
                    'Check grammar and fix any issues in the selected text' : 
                    'Check grammar and fix any issues in this document',
                'examples': 'Add relevant examples to illustrate the concepts'
            };
            
            const message = actionMap[action] || action;
            
            // Set the message and send
            document.getElementById('ai-input').value = message;
            await sendAIMessage();
        }
        
        function applyAISuggestion(button) {
            const messageDiv = button.closest('.ai-message');
            const suggestion = messageDiv.dataset.response;
            const originalText = messageDiv.dataset.originalText;
            
            if (!suggestion || !editor) return;
            
            // Get current selection or full document
            const selection = editor.getSelection();
            const model = editor.getModel();
            const currentText = selection && !selection.isEmpty() ? 
                model.getValueInRange(selection) : model.getValue();
            
            // Show diff preview before applying
            if (suggestion.length > 100 || currentText.length > 100) {
                showDiffPreview(currentText, suggestion, () => {
                    applyEdit(selection, suggestion);
                });
            } else {
                // For small changes, apply directly with confirmation
                if (confirm('Apply AI suggestion?')) {
                    applyEdit(selection, suggestion);
                }
            }
        }
        
        function applyEdit(selection, newText) {
            if (selection && !selection.isEmpty()) {
                // Replace selection
                editor.executeEdits('ai-edit', [{
                    range: selection,
                    text: newText
                }]);
                showToast('Applied AI suggestion to selection', 'success');
            } else {
                // Replace entire document
                editor.setValue(newText);
                showToast('Document updated with AI suggestion', 'success');
            }
            
            // Mark as dirty
            if (activeFile) {
                const fileData = openFiles.get(activeFile);
                if (fileData) {
                    fileData.dirty = true;
                    updateTabDirtyState(activeFile, true);
                    updateSaveButtons();
                }
            }
        }
        
        function showDiffPreview(original, modified, onAccept, customTitle = null) {
            // Use inline diff viewer instead of modal (Cursor-style UX)
            const fileName = customTitle || (activeFile ? openFiles.get(activeFile)?.name : 'Changes');
            showInlineDiff(original, modified, fileName, onAccept);
        }
        
        function copyAISuggestion(button) {
            const messageDiv = button.closest('.ai-message');
            const suggestion = messageDiv.dataset.response;
            
            if (suggestion) {
                copyToClipboard(suggestion);
                showToast('Copied AI suggestion', 'success');
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function sanitizeRenderedHtml(html) {
            if (window.DOMPurify && typeof window.DOMPurify.sanitize === 'function') {
                return window.DOMPurify.sanitize(html, { USE_PROFILES: { html: true } });
            }
            return escapeHtml(String(html || ''));
        }

        function renderMarkdownSafe(markdown) {
            if (typeof marked !== 'undefined' && marked.parse) {
                return sanitizeRenderedHtml(marked.parse(markdown || ''));
            }
            return `<pre style="white-space:pre-wrap;">${escapeHtml(markdown || '')}</pre>`;
        }
        
        function clearAIChat() {
            const messagesDiv = document.getElementById('ai-chat-messages');
            messagesDiv.innerHTML = `
                <div style="padding: 20px; text-align: center; color: var(--text-secondary); font-size: 12px;">
                    👋 Chat cleared. Ask me anything!
                </div>
            `;
            aiConversationHistory = [];
            conversationSummary = null; // Clear summary too
            updateTokenCounter();
        }

        // ============================================================================
        // EXPORT & DOWNLOAD
        // ============================================================================
        
        function downloadCurrentFile() {
            if (!activeFile) {
                showToast('No file open', 'error');
                return;
            }
            
            const fileData = openFiles.get(activeFile);
            if (!fileData) {
                showToast('File data not found', 'error');
                return;
            }
            
            try {
                // For Office files, download the original binary file from server
                if (fileData.isOfficeFile) {
                    // Use the serve-file endpoint to get the actual binary
                    const downloadUrl = `/api/serve-file?path=${encodeURIComponent(fileData.path)}`;
                    const a = document.createElement('a');
                    a.href = downloadUrl;
                    a.download = fileData.name;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    showToast(`Downloaded: ${fileData.name}`, 'success');
                } else {
                    // For text files, download the editor content
                    const content = fileData.model.getValue();
                    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileData.name;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showToast(`Downloaded: ${fileData.name}`, 'success');
                }
            } catch (error) {
                console.error('Download error:', error);
                showToast('Failed to download file: ' + error.message, 'error');
            }
        }
        
        // Upload a replacement file (for Office files - download, edit locally, re-upload)
        function uploadReplacementFile() {
            if (!activeFile) {
                showToast('No file open', 'error');
                return;
            }
            
            const fileData = openFiles.get(activeFile);
            if (!fileData) {
                showToast('File data not found', 'error');
                return;
            }
            
            // Create hidden file input
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = getAcceptTypeForFile(fileData.name);
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                // Confirm replacement
                const confirmed = confirm(
                    `Replace "${fileData.name}" with "${file.name}"?\n\n` +
                    `This will overwrite the file on the server.`
                );
                
                if (!confirmed) return;
                
                try {
                    showToast('Uploading...', 'info');
                    
                    // Read file as ArrayBuffer
                    const arrayBuffer = await file.arrayBuffer();
                    const uint8Array = new Uint8Array(arrayBuffer);
                    
                    // Convert to base64 for JSON transport
                    const base64 = btoa(String.fromCharCode.apply(null, uint8Array));
                    
                    // Upload to server
                    const response = await fetch('/api/folder/upload-binary', {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            path: fileData.path,
                            content: base64,
                            encoding: 'base64'
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        showToast(`Replaced: ${fileData.name}`, 'success');
                        
                        // Refresh the file view
                        closeTab(activeFile);
                        await openFile(fileData.path);
                    } else {
                        throw new Error(result.error || 'Upload failed');
                    }
                } catch (error) {
                    console.error('Upload error:', error);
                    showToast('Failed to upload: ' + error.message, 'error');
                }
            };
            
            input.click();
        }
        
        function getAcceptTypeForFile(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const acceptTypes = {
                'docx': '.docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                'xlsx': '.xlsx,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                'xls': '.xls,application/vnd.ms-excel',
                'pptx': '.pptx,application/vnd.openxmlformats-officedocument.presentationml.presentation',
                'pdf': '.pdf,application/pdf',
                'msg': '.msg,application/vnd.ms-outlook'
            };
            return acceptTypes[ext] || '*/*';
        }
        
        // ============================================================================
        // OnlyOffice Document Editor Integration
        // ============================================================================
        
        let collaboraFrame = null;
        
        async function openInOnlyOffice() {
            if (!activeFile) {
                showToast('No file open', 'error');
                return;
            }
            
            const fileData = openFiles.get(activeFile);
            if (!fileData || !fileData.isOfficeFile) {
                showToast('Not an Office file', 'error');
                return;
            }
            
            try {
                showToast('Loading Office editor...', 'info');
                
                // Get configuration from server (Collabora WOPI + iframe URL)
                const response = await fetch('/api/collabora/config?t=' + Date.now(), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filePath: fileData.path })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const config = await response.json();
                if (!config.iframeUrl) {
                    throw new Error('Missing editor URL');
                }
                
                // Show modal
                document.getElementById('onlyoffice-modal').style.display = 'block';
                
                const editorContainer = document.getElementById('onlyoffice-editor');
                if (editorContainer) {
                    editorContainer.innerHTML = '';
                    
                    const iframe = document.createElement('iframe');
                    iframe.src = config.iframeUrl;
                    iframe.style.width = '100%';
                    iframe.style.height = '100%';
                    iframe.style.border = '0';
                    iframe.allow = 'clipboard-read; clipboard-write';
                    
                    editorContainer.appendChild(iframe);
                    collaboraFrame = iframe;
                }
                
                showToast('Office editor loaded', 'success');
                
            } catch (error) {
                console.error('Collabora error:', error);
                showToast('Failed to open Office editor: ' + error.message, 'error');
            }
        }
        
        function closeOnlyOfficeEditor() {
            const modal = document.getElementById('onlyoffice-modal');
            if (modal) {
                modal.style.display = 'none';
            }
            
            if (collaboraFrame && collaboraFrame.parentNode) {
                collaboraFrame.parentNode.removeChild(collaboraFrame);
                collaboraFrame = null;
            }
            
            // Clear the editor div
            const editorDiv = document.getElementById('onlyoffice-editor');
            if (editorDiv) {
                editorDiv.innerHTML = '';
            }
            
            // Refresh the file in the IDE
            if (activeFile) {
                const fileData = openFiles.get(activeFile);
                if (fileData) {
                    closeTab(activeFile);
                    setTimeout(() => openFile(fileData.path), 500);
                }
            }
        }
        
        async function downloadAllFiles() {
            showToast('Preparing download...', 'success');
            
            // For a simple implementation without JSZip, we'll download files one by one
            // Or offer to download a bundle via API
            
            try {
                const response = await fetch(`/api/compiled-docs/${runName}/${systemId}/download`);
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${systemId}-docs.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showToast('Downloaded all files', 'success');
                } else {
                    throw new Error('Download failed');
                }
            } catch (error) {
                console.error('Download failed:', error);
                showToast('Download failed. Downloading current file only.', 'error');
                downloadCurrentFile();
            }
        }
        
        function exportMarkdownToPDF() {
            if (!activeFile) {
                showToast('No file open', 'error');
                return;
            }
            
            const fileData = openFiles.get(activeFile);
            if (!fileData || fileData.model.getLanguageId() !== 'markdown') {
                showToast('Only markdown files can be exported to PDF', 'error');
                return;
            }
            
            try {
            // Use browser print for PDF export
            const content = fileData.model.getValue();
            const html = renderMarkdownSafe(content);
            
            const printWindow = window.open('', '_blank');
                if (!printWindow) {
                    showToast('Pop-up blocked. Please allow pop-ups to export to PDF.', 'error');
                    return;
                }
                
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${fileData.name}</title>
                    <style>
                        body {
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                            max-width: 800px;
                            margin: 40px auto;
                            padding: 0 20px;
                            line-height: 1.6;
                            color: #333;
                        }
                        h1, h2, h3 { margin-top: 24px; margin-bottom: 12px; }
                        code {
                            background: #f5f5f5;
                            padding: 2px 6px;
                            border-radius: 3px;
                            font-family: 'Monaco', 'Courier New', monospace;
                        }
                        pre {
                            background: #f5f5f5;
                            padding: 16px;
                            border-radius: 6px;
                            overflow-x: auto;
                        }
                        pre code {
                            background: none;
                            padding: 0;
                        }
                    </style>
                </head>
                <body>
                    ${html}
                </body>
                </html>
            `);
            printWindow.document.close();
            
            setTimeout(() => {
                printWindow.print();
            }, 250);
                
                showToast('Opening print dialog...', 'success');
            } catch (error) {
                console.error('PDF export error:', error);
                showToast('Failed to export to PDF: ' + error.message, 'error');
            }
        }
        
        function exportMarkdownToHTML() {
            if (!activeFile) {
                showToast('No file open', 'error');
                return;
            }
            
            const fileData = openFiles.get(activeFile);
            if (!fileData || fileData.model.getLanguageId() !== 'markdown') {
                showToast('Only markdown files can be exported to HTML', 'error');
                return;
            }
            
            try {
            const content = fileData.model.getValue();
            const html = renderMarkdownSafe(content);
            
            const fullHTML = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${fileData.name}</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            max-width: 800px;
            margin: 40px auto;
            padding: 0 20px;
            line-height: 1.6;
            color: #333;
        }
        h1, h2, h3 { margin-top: 24px; margin-bottom: 12px; color: #1a1a1a; }
        h1 { font-size: 32px; }
        h2 { font-size: 24px; }
        h3 { font-size: 20px; }
        p { margin-bottom: 12px; }
        code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }
        pre {
            background: #f5f5f5;
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 12px 0;
        }
        pre code {
            background: none;
            padding: 0;
        }
        a { color: #0066cc; text-decoration: none; }
        a:hover { text-decoration: underline; }
        blockquote {
            border-left: 4px solid #ddd;
            margin: 12px 0;
            padding-left: 16px;
            color: #666;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 12px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
        }
        th {
            background: #f5f5f5;
            font-weight: 600;
        }
    </style>
</head>
<body>
${html}
</body>
</html>`;
            
            const blob = new Blob([fullHTML], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = fileData.name.replace(/\.md$/, '.html');
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('Exported to HTML', 'success');
            } catch (error) {
                console.error('HTML export error:', error);
                showToast('Failed to export to HTML: ' + error.message, 'error');
            }
        }

        // ============================================================================
        // BEFORE UNLOAD WARNING
        // ============================================================================
        
        window.addEventListener('beforeunload', (e) => {
            const hasDirty = Array.from(openFiles.values()).some(f => f.dirty);
            if (hasDirty) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
                return e.returnValue;
            }
        });

        // ============================================================================
        // PANEL RESIZING
        // ============================================================================
        
        function initPanelResizing() {
            const handles = document.querySelectorAll('.resize-handle-vertical');
            
            console.log('Initializing panel resizing, found', handles.length, 'handles');
            
            handles.forEach((handle, index) => {
                console.log('Setting up resize handle', index, 'for', handle.dataset.target);
                
                let isResizing = false;
                let startX = 0;
                let startWidth = 0;
                let targetPanel = null;
                let targetId = null;
                
                const handleMouseDown = (e) => {
                    console.log('Resize mousedown on', handle.dataset.target);
                    isResizing = true;
                    startX = e.clientX;
                    targetId = handle.dataset.target;
                    targetPanel = document.getElementById(targetId);
                    
                    if (targetPanel) {
                        startWidth = targetPanel.offsetWidth;
                        handle.classList.add('active');
                        document.body.style.cursor = 'col-resize';
                        document.body.style.userSelect = 'none';
                        console.log('Started resizing', targetId, 'from width', startWidth);
                        
                        // Add move and up listeners
                        document.addEventListener('mousemove', handleMouseMove);
                        document.addEventListener('mouseup', handleMouseUp);
                    } else {
                        console.error('Target panel not found:', targetId);
                    }
                    
                    e.preventDefault();
                    e.stopPropagation();
                };
                
                const handleMouseMove = (e) => {
                    if (!isResizing || !targetPanel) return;
                    
                    e.preventDefault();
                    e.stopPropagation();
                    
                    let newWidth;
                    
                    if (targetId === 'sidebar') {
                        // Sidebar: resize from left to right
                        const delta = e.clientX - startX;
                        newWidth = startWidth + delta;
                    } else {
                        // Preview/AI panels: resize from right to left
                        const delta = startX - e.clientX;
                        newWidth = startWidth + delta;
                    }
                    
                    // Apply constraints - generous limits for professional-grade flexibility
                    const minWidth = parseInt(getComputedStyle(targetPanel).minWidth) || 150;
                    const maxWidth = parseInt(getComputedStyle(targetPanel).maxWidth) || 1600;
                    
                    // Ensure minimum 150px for editor area - allow panels to take up to 80% of viewport
                    const editorContainer = document.querySelector('.editor-container');
                    const minEditorWidth = 150;
                    const availableSpace = window.innerWidth - minEditorWidth;
                    
                    // Calculate how much space other panels are using
                    const sidebar = document.getElementById('sidebar');
                    const aiPanel = document.getElementById('ai-panel');
                    const previewPane = document.getElementById('preview-pane');
                    
                    let otherPanelsWidth = 0;
                    if (targetId !== 'sidebar' && sidebar && !sidebar.classList.contains('hidden')) {
                        otherPanelsWidth += sidebar.offsetWidth;
                    }
                    if (targetId !== 'ai-panel' && aiPanel && !aiPanel.classList.contains('hidden')) {
                        otherPanelsWidth += aiPanel.offsetWidth;
                    }
                    if (targetId !== 'preview-pane' && previewPane && !previewPane.classList.contains('hidden')) {
                        otherPanelsWidth += previewPane.offsetWidth;
                    }
                    
                    const maxPanelWidth = availableSpace - otherPanelsWidth;
                    newWidth = Math.max(minWidth, Math.min(maxWidth, maxPanelWidth, newWidth));
                    
                    targetPanel.style.width = newWidth + 'px';
                    targetPanel.style.flexGrow = '0';
                    targetPanel.style.flexShrink = '0';
                    targetPanel.style.flexBasis = 'auto';
                };
                
                const handleMouseUp = (e) => {
                    if (isResizing && targetPanel) {
                        const finalWidth = targetPanel.offsetWidth;
                        
                        savePanelSize(targetId, finalWidth);
                        console.log('Resize complete:', targetId, 'final width:', finalWidth);
                        
                        isResizing = false;
                        handle.classList.remove('active');
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                        
                        // Remove event listeners
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                        
                        targetPanel = null;
                        targetId = null;
                        
                        e.preventDefault();
                        e.stopPropagation();
                    }
                };
                
                // Attach initial mousedown listener
                handle.addEventListener('mousedown', handleMouseDown);
            });
        }
        
        function savePanelSize(panelId, width) {
            try {
                const key = `evobrew-panel-size-${panelId}`;
                localStorage.setItem(key, width.toString());
            } catch (e) {
                console.error('Failed to save panel size:', e);
            }
        }
        
        function restorePanelSizes() {
            const panels = ['sidebar', 'preview-pane', 'ai-panel'];
            
            panels.forEach(panelId => {
                try {
                    const key = `evobrew-panel-size-${panelId}`;
                    const saved = localStorage.getItem(key);
                    if (saved) {
                        const panel = document.getElementById(panelId);
                        if (panel) {
                            panel.style.width = saved + 'px';
                        }
                    }
                } catch (e) {
                    console.error(`Failed to restore ${panelId} size:`, e);
                }
            });
        }

        // ============================================================================
        // FILE CREATION (AI-Triggered or Manual)
        // ============================================================================
        
        // ============================================================================
        // INLINE DIFF VIEWER - Monaco DiffEditor integration
        // ============================================================================
        
        let diffEditor = null;
        let currentDiffCallback = null;
        let currentDiffOriginal = null;
        let currentDiffModified = null;
        
        function showInlineDiff(original, modified, fileName, onAccept) {
            // Store callback and content
            currentDiffCallback = onAccept;
            currentDiffOriginal = original;
            currentDiffModified = modified;
            
            // Hide normal editor, show diff editor
            document.getElementById('monaco-editor').classList.add('hidden');
            document.getElementById('monaco-diff-editor').classList.remove('hidden');
            document.getElementById('diff-action-bar').classList.remove('hidden');
            document.getElementById('diff-file-name').textContent = fileName || 'Changes';
            
            // Create diff editor if it doesn't exist
            const diffContainer = document.getElementById('monaco-diff-editor');
            
            if (!diffEditor) {
                diffEditor = monaco.editor.createDiffEditor(diffContainer, {
                    enableSplitViewResizing: true,
                    renderSideBySide: true,
                    readOnly: false,
                    originalEditable: false,
                    automaticLayout: true,
                    theme: settings.theme || 'vs-dark',
                    fontSize: settings.fontSize || 14,
                    minimap: { enabled: settings.minimap !== false }
                });
            }
            
            // Detect language from filename or use plaintext
            const language = fileName ? detectLanguage(fileName) : 'plaintext';
            
            // Create models
            const originalModel = monaco.editor.createModel(original, language);
            const modifiedModel = monaco.editor.createModel(modified, language);
            
            // Set models in diff editor
            diffEditor.setModel({
                original: originalModel,
                modified: modifiedModel
            });
            
            // Focus the diff editor
            diffEditor.focus();
        }
        
        function acceptCurrentDiff() {
            if (currentDiffCallback) {
                currentDiffCallback();
                currentDiffCallback = null;
            }
            exitDiffMode();
        }
        
        function rejectCurrentDiff() {
            currentDiffCallback = null;
            exitDiffMode();
            showToast('Changes rejected', 'success');
        }
        
        function exitDiffMode() {
            // Dispose diff editor models
            if (diffEditor) {
                const model = diffEditor.getModel();
                if (model) {
                    model.original?.dispose();
                    model.modified?.dispose();
                }
            }
            
            // Hide diff editor, show normal editor
            document.getElementById('monaco-diff-editor').classList.add('hidden');
            document.getElementById('monaco-editor').classList.remove('hidden');
            document.getElementById('diff-action-bar').classList.add('hidden');
            
            // Clear state
            currentDiffCallback = null;
            currentDiffOriginal = null;
            currentDiffModified = null;
            
            // Refocus normal editor
            if (editor) {
                editor.focus();
            }
        }
        
        // ============================================================================
        // CSV TABLE BUILDER
        // ============================================================================
        
        function showCSVBuilder() {
            document.getElementById('csv-builder').classList.remove('hidden');
            document.getElementById('overlay').classList.remove('hidden');
            
            // Generate default grid
            generateCSVGrid();
        }
        
        function closeCSVBuilder() {
            document.getElementById('csv-builder').classList.add('hidden');
            document.getElementById('overlay').classList.add('hidden');
        }
        
        function generateCSVGrid() {
            const rows = parseInt(document.getElementById('csv-rows').value) || 5;
            const cols = parseInt(document.getElementById('csv-cols').value) || 4;
            const gridDiv = document.getElementById('csv-grid');
            
            let html = '<table style="width: 100%; border-collapse: collapse;">';
            
            // Header row
            html += '<tr style="background: var(--bg-secondary);">';
            for (let c = 0; c < cols; c++) {
                html += `<th style="border: 1px solid var(--border-color); padding: 8px;">
                    <input type="text" class="csv-cell" data-row="0" data-col="${c}" 
                           placeholder="Column ${c + 1}" 
                           style="width: 100%; background: transparent; border: none; color: var(--text-primary); font-weight: 600;">
                </th>`;
            }
            html += '</tr>';
            
            // Data rows
            for (let r = 1; r <= rows; r++) {
                html += '<tr>';
                for (let c = 0; c < cols; c++) {
                    html += `<td style="border: 1px solid var(--border-color); padding: 4px;">
                        <input type="text" class="csv-cell" data-row="${r}" data-col="${c}" 
                               placeholder="" 
                               style="width: 100%; background: transparent; border: none; color: var(--text-primary);">
                    </td>`;
                }
                html += '</tr>';
            }
            html += '</table>';
            
            gridDiv.innerHTML = html;
        }
        
        async function createCSVFile() {
            const fileName = document.getElementById('csv-filename').value || 'data.csv';
            const cells = document.querySelectorAll('#csv-grid .csv-cell');
            
            if (cells.length === 0) {
                showToast('Generate a grid first', 'error');
                return;
            }
            
            // Build CSV data structure
            const data = {};
            cells.forEach(cell => {
                const row = cell.dataset.row;
                const col = cell.dataset.col;
                if (!data[row]) data[row] = {};
                data[row][col] = cell.value || '';
            });
            
            // Convert to CSV text
            const rows = Object.keys(data).sort((a, b) => parseInt(a) - parseInt(b));
            const csvLines = rows.map(r => {
                const cols = Object.keys(data[r]).sort((a, b) => parseInt(a) - parseInt(b));
                return cols.map(c => {
                    const value = data[r][c];
                    // Escape quotes and wrap in quotes if contains comma, quote, or newline
                    if (value.includes(',') || value.includes('"') || value.includes('\n')) {
                        return `"${value.replace(/"/g, '""')}"`;
                    }
                    return value;
                }).join(',');
            });
            
            const csvContent = csvLines.join('\n');
            
            // Create file
            const currentFolder = IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
            const fullPath = fileName.startsWith('/') ? fileName : `${currentFolder}/${fileName}`;
            
            try {
                await createFileOrFolder(fullPath, csvContent);
                showToast(`Created ${fileName}`, 'success');
                closeCSVBuilder();
            } catch (error) {
                showToast(`Failed to create CSV: ${error.message}`, 'error');
            }
        }
        
        // ============================================================================
        // CHAT HISTORY UI FUNCTIONS
        // ============================================================================
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        async function toggleChatHistory() {
            const panel = document.getElementById('chat-history-panel');
            const btn = document.getElementById('history-toggle-btn');
            const isHidden = panel.classList.contains('hidden');
            
            if (isHidden) {
                // Show panel
                panel.classList.remove('hidden');
                if (btn) btn.classList.add('active');
                await updateChatHistoryUI();
                
                // Add click-outside listener to auto-close
                setTimeout(() => {
                    document.addEventListener('click', closeChatHistoryOnClickOutside);
                }, 100);
            } else {
                // Hide panel
                panel.classList.add('hidden');
                if (btn) btn.classList.remove('active');
                document.removeEventListener('click', closeChatHistoryOnClickOutside);
            }
        }

        function closeChatHistoryOnClickOutside(event) {
            const panel = document.getElementById('chat-history-panel');
            const btn = document.getElementById('history-toggle-btn');
            const historyButton = event.target.closest('#history-toggle-btn');
            
            // Don't close if clicking the history button or inside the panel
            if (!historyButton && !panel.contains(event.target)) {
                panel.classList.add('hidden');
                if (btn) btn.classList.remove('active');
                document.removeEventListener('click', closeChatHistoryOnClickOutside);
            }
        }
        
        function startNewChat() {
            // Clear current conversation
            aiConversationHistory = [];
            conversationSummary = null; // Clear summary
            chatHistory.startNewConversation();

            // Clear chat UI
            const messagesDiv = document.getElementById('ai-chat-messages');
            messagesDiv.innerHTML = `
                <div style="padding: 40px 20px; text-align: center; color: var(--text-secondary); font-size: 13px; opacity: 0.6;">
                    <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin-bottom: 16px; opacity: 0.5;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
                    <div>New conversation started. How can I help?</div>
                </div>
            `;

            updateTokenCounter();
            showToast('Started new conversation', 'success');
        }
        
        async function updateChatHistoryUI() {
            await chatHistory.loadConversationsFromServer();
            
            // DEBUG: Show ALL conversations regardless of folder
            const allConvs = chatHistory.allConversations;
            console.log('[CHAT HISTORY] Total conversations:', allConvs.length);
            console.log('[CHAT HISTORY] Current directory:', chatHistory.getCurrentDirectory());
            
            const conversations = allConvs; // Show all for now
            const listEl = document.getElementById('chat-history-list');
            
            if (conversations.length === 0) {
                listEl.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: var(--text-secondary); font-size: 12px;">
                        No chat history found
                    </div>
                `;
                return;
            }
            
            listEl.innerHTML = conversations.map(conv => {
                const date = new Date(conv.timestamp);
                const timeStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                const messageCount = conv.messageCount;
                const preview = conv.title || 'Untitled conversation';
                
                return `
                    <div class="chat-history-item" onclick="loadChatConversation('${conv.id}')">
                        <div class="conv-title">${preview}</div>
                        <div class="conv-meta">
                            <span>${timeStr}</span>
                            <span>${messageCount} messages</span>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        async function loadChatConversation(conversationId) {
            const conversation = await chatHistory.loadConversation(conversationId);
            if (!conversation) {
                showToast('Conversation not found', 'error');
                return;
            }

            // Load messages into conversation history
            aiConversationHistory = conversation.messages.map(m => ({
                role: m.role,
                content: m.content
            }));

            // Load summary if stored in conversation
            conversationSummary = conversation.summary || null;

            // Clear and rebuild chat UI
            const messagesDiv = document.getElementById('ai-chat-messages');
            messagesDiv.innerHTML = '';

            // Show summary indicator if exists
            if (conversationSummary) {
                const summaryEl = document.createElement('div');
                summaryEl.className = 'conversation-summary';
                summaryEl.style.cssText = 'padding: 8px 12px; margin: 8px 0; background: rgba(59, 130, 246, 0.1); border-radius: 6px; font-size: 11px; color: var(--text-secondary);';
                summaryEl.innerHTML = `<details><summary style="cursor: pointer; font-weight: 600;">📋 Earlier conversation summarized</summary><div style="margin-top: 8px; white-space: pre-wrap; opacity: 0.8;">${escapeHtml(conversationSummary)}</div></details>`;
                messagesDiv.appendChild(summaryEl);
            }

            conversation.messages.forEach(msg => {
                addChatMessage(msg.role, msg.content, {});
            });

            // Update token counter
            updateTokenCounter();

            // Close history panel
            const historyPanel = document.getElementById('chat-history-panel');
            historyPanel.classList.add('hidden');
            document.removeEventListener('click', closeChatHistoryOnClickOutside);

            showToast(`📂 ${conversation.title}`, 'success');
        }
        
        // ============================================================================
        // CONTEXT MENU - Cursor-style right-click options
        // ============================================================================
        
        function showContextMenu(x, y, filePath) {
            const menu = document.getElementById('context-menu');
            const fileData = openFiles.get(filePath);
            const fileName = filePath.split('/').pop();
            
            const menuItems = [
                { icon: '👁️', label: 'Open in Browser', action: () => openInBrowser(filePath) },
                { icon: '📁', label: 'Reveal in Finder', action: () => revealInFinder(filePath) },
                { separator: true },
                { icon: '📋', label: 'Copy Path', action: () => copyFilePath(filePath) },
                { icon: '📋', label: 'Copy Relative Path', action: () => copyRelativePath(filePath) },
                { separator: true },
                { icon: '✏️', label: 'Rename...', action: () => renameFileDialog(filePath) },
                { icon: '🗑️', label: 'Delete...', action: () => deleteFileDialog(filePath), danger: true },
                { separator: true },
                { icon: '📌', label: fileData && pinnedTabs.has(filePath) ? 'Unpin Tab' : 'Pin Tab', action: () => togglePinTab(filePath) },
                { icon: '💾', label: 'Save', action: () => saveFile(filePath), disabled: !fileData || !fileData.dirty },
                { icon: '🔄', label: 'Close Tab', action: () => closeFile(filePath), disabled: !fileData }
            ];
            
            // Clear menu
            menu.innerHTML = '';
            
            // Build menu with proper event listeners (not inline onclick)
            menuItems.forEach((item, index) => {
                if (item.separator) {
                    const separator = document.createElement('div');
                    separator.className = 'context-menu-separator';
                    menu.appendChild(separator);
                } else {
                    const menuItem = document.createElement('div');
                    menuItem.className = 'context-menu-item';
                    if (item.disabled) menuItem.classList.add('disabled');
                    if (item.danger) menuItem.classList.add('danger');
                    
                    menuItem.innerHTML = `
                        <span>${item.icon}</span>
                        <span>${item.label}</span>
                    `;
                    
                    // Add click handler with proper closure
                    menuItem.addEventListener('click', (e) => {
                        if (!menuItem.classList.contains('disabled')) {
                            item.action();
                            hideContextMenu();
                        }
                    });
                    
                    menu.appendChild(menuItem);
                }
            });
            
            // Position menu
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
            menu.classList.remove('hidden');
            
            // Store current file for action callbacks
            window.contextMenuTarget = filePath;
        }
        
        function hideContextMenu() {
            document.getElementById('context-menu').classList.add('hidden');
            window.contextMenuTarget = null;
        }
        
        async function openInBrowser(filePath) {
            const url = `/api/serve-file?path=${encodeURIComponent(filePath)}`;
            window.open(url, '_blank');
            showToast('Opened in browser', 'success');
        }
        
        async function revealInFinder(filePath) {
            try {
                const response = await fetch('/api/reveal-in-finder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: filePath })
                });
                
                const data = await response.json();
                if (data.success) {
                    showToast('Opened in Finder', 'success');
                } else {
                    showToast(data.error || 'Failed to reveal file', 'error');
                }
            } catch (error) {
                showToast('Failed to reveal file', 'error');
            }
        }
        
        function copyFilePath(filePath) {
            copyToClipboard(filePath);
            showToast('Copied full path', 'success');
        }
        
        function copyRelativePath(filePath) {
            const currentFolder = IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
            let relative = filePath.replace(currentFolder + '/', '');
            if (relative === filePath) relative = './' + filePath.split('/').pop();
            copyToClipboard(relative);
            showToast('Copied relative path', 'success');
        }
        
        function togglePinTab(filePath) {
            if (pinnedTabs.has(filePath)) {
                pinnedTabs.remove(filePath);
                showToast('Tab unpinned', 'success');
            } else {
                pinnedTabs.add(filePath);
                showToast('Tab pinned', 'success');
            }
            renderTabs();
        }
        
        // Close all modals and context menu on click outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.context-menu')) {
                hideContextMenu();
            }
        });
        
        /**
         * User-triggered: Create new file
         * Prompts for filename and creates in current folder
         */
        async function createNewFile() {
            const currentFolder = IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
            const fileName = prompt('Enter new file name:', 'untitled.md');
            
            if (!fileName) return;
            
            // Build full path
            const fullPath = fileName.startsWith('/') ? fileName : `${currentFolder}/${fileName}`;
            
            try {
                await createFileOrFolder(fullPath, '');
                showToast(`Created ${fileName}`, 'success');
            } catch (error) {
                showToast(`Failed to create file: ${error.message}`, 'error');
            }
        }
        
        /**
         * User-triggered: Create new folder
         * Prompts for folder name and creates in current folder
         */
        async function createNewFolder() {
            const currentFolder = IDE_MODE === 'filesystem' ? folderPath : (currentBrowsePath || '.');
            const folderName = prompt('Enter new folder name:', 'new-folder');
            
            if (!folderName) return;
            
            // Build full path (ensure it ends with /)
            const fullPath = folderName.startsWith('/') ? folderName : `${currentFolder}/${folderName}`;
            const normalizedPath = fullPath.endsWith('/') ? fullPath : `${fullPath}/`;
            
            try {
                await createFileOrFolder(normalizedPath, '');
                showToast(`Created folder ${folderName}`, 'success');
            } catch (error) {
                showToast(`Failed to create folder: ${error.message}`, 'error');
            }
        }
        
        async function createFileOrFolder(filePath, content = '') {
            try {
                // Detect if it's a folder (ends with / or has no extension and no content)
                const isFolder = filePath.endsWith('/') || (!filePath.includes('.') && !content);
                
                if (isFolder) {
                    // Create folder (just write a .gitkeep file in it)
                    const folderPath = filePath.replace(/\/$/, '');
                    const keepFile = `${folderPath}/.gitkeep`;
                    const data = await FileAPI.writeFile(keepFile, '');
                    
                    if (!data.success) {
                        throw new Error(data.error || 'Failed to create folder');
                    }
                    
                    console.log('[FOLDER CREATE] Success:', folderPath);
                    showToast(`Created folder: ${folderPath.split('/').pop()}`, 'success');
                } else {
                    // Check if it's a DOCX file - need to create valid DOCX structure
                    const isDocx = filePath.toLowerCase().endsWith('.docx');
                    
                    if (isDocx && !content) {
                        // Create valid empty DOCX file with minimal content
                        content = '# New Document\n\nStart writing here...';
                    }
                    
                    // Create file
                    const data = await FileAPI.writeFile(filePath, content);
                    
                    if (!data.success) {
                        throw new Error(data.error || 'Failed to create file');
                    }
                    
                    console.log('[FILE CREATE] Success:', filePath);
                    showToast(`Created: ${filePath.split('/').pop()}`, 'success');
                }
                
                // Reload file tree
                await loadFileTree();
                
                // Open the file if it's not a folder
                if (!isFolder) {
                    setTimeout(() => {
                        openFile(filePath);
                    }, 500);
                }
                
                return true;
            } catch (error) {
                console.error('[CREATE] Error:', error);
                showToast('Failed to create: ' + error.message, 'error');
                return false;
            }
        }

        // ============================================================================
        // FOLDER BROWSER
        // ============================================================================

        // Default browse path
        const isWindows = navigator.userAgent.toLowerCase().includes('windows');
        let currentBrowsePath = isWindows ? 'C:\\Users' : '/';
        const WORKING_FOLDER_STORAGE_KEY = 'evobrew.ui.workingFolder.v2';
        let workingDirectory = null; // User's chosen working folder (non-brain by default)
        let viewingBrainFolder = false; // Whether sidebar is currently showing the connected brain folder

        try {
            const savedWorkingFolder = localStorage.getItem(WORKING_FOLDER_STORAGE_KEY);
            if (savedWorkingFolder) {
                workingDirectory = savedWorkingFolder;
            }
        } catch (_error) {
            // Ignore localStorage failures
        }

        function normalizeFolderPath(path) {
            if (!path) return '';
            if (path === '/') return '/';
            if (/^[A-Za-z]:\\?$/.test(path)) return path.toUpperCase();
            return path.replace(/[\\/]+$/, '');
        }

        function pathsEqual(a, b) {
            return normalizeFolderPath(a) === normalizeFolderPath(b);
        }

        function getConnectedBrainFolderPath() {
            return window.brainOutputsPath || window.currentBrainInfo?.outputsPath || null;
        }

        function persistWorkingDirectory(path) {
            if (!path) return;
            workingDirectory = path;
            try {
                localStorage.setItem(WORKING_FOLDER_STORAGE_KEY, path);
            } catch (_error) {
                // Ignore localStorage failures
            }
        }

        function refreshFolderContextButtons() {
            const brainPath = getConnectedBrainFolderPath();
            const inBrainFolder = Boolean(brainPath && folderPath && pathsEqual(folderPath, brainPath));
            viewingBrainFolder = inBrainFolder;

            const brainBtn = document.getElementById('brain-folder-btn');
            if (brainBtn) {
                brainBtn.style.display = brainPath ? '' : 'none';
                if (brainPath) {
                    if (inBrainFolder) {
                        brainBtn.style.background = 'rgba(255, 180, 50, 0.22)';
                        brainBtn.setAttribute('title', 'Return to working folder');
                        brainBtn.setAttribute('data-tooltip', 'Working Folder');
                        brainBtn.setAttribute('aria-label', 'Return to working folder');
                    } else {
                        brainBtn.style.background = 'none';
                        brainBtn.setAttribute('title', 'Open connected brain folder');
                        brainBtn.setAttribute('data-tooltip', 'Brain Folder');
                        brainBtn.setAttribute('aria-label', 'Open connected brain folder');
                    }
                }
            }

            const homeBtn = document.getElementById('go-home-btn');
            if (homeBtn) {
                const hasWorkingFolder = Boolean(workingDirectory);
                homeBtn.style.opacity = hasWorkingFolder ? '1' : '0.55';
                homeBtn.setAttribute('title', hasWorkingFolder ? `Go to working folder (${workingDirectory})` : 'Choose a working folder');
            }

            const sidebarPath = document.getElementById('sidebar-path');
            if (sidebarPath && folderPath) {
                const scope = inBrainFolder ? 'Brain folder' : 'Working folder';
                sidebarPath.title = `${folderPath}\n(${scope} - click to choose folder)`;
            }
        }

        function getFolderBrowserStartPath(overridePath) {
            if (overridePath) return overridePath;
            const brainPath = getConnectedBrainFolderPath();
            if (workingDirectory) return workingDirectory;
            if (folderPath && !(brainPath && pathsEqual(folderPath, brainPath))) return folderPath;
            if (currentBrowsePath && currentBrowsePath !== '/') return currentBrowsePath;
            return isWindows ? 'C:\\Users' : '/Users';
        }

        async function showFolderBrowser(startPathOverride) {
            document.getElementById('folder-browser').classList.remove('hidden');
            document.getElementById('overlay').classList.remove('hidden');
            const startPath = getFolderBrowserStartPath(startPathOverride);
            await browseFolders(startPath);
        }
        
        function closeFolderBrowser() {
            document.getElementById('folder-browser').classList.add('hidden');
            document.getElementById('overlay').classList.add('hidden');
        }
        
        async function browseFolders(folderPath) {
            currentBrowsePath = folderPath;
            document.getElementById('current-path-display').textContent = folderPath;
            
            const folderList = document.getElementById('folder-list');
            folderList.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">Loading...</div>';
            
            try {
                const response = await fetch(`/api/folder/browse?path=${encodeURIComponent(folderPath)}`);
                const data = await response.json();
                
                if (!data.success) {
                    folderList.innerHTML = `<div style="text-align: center; color: var(--error-color); padding: 20px;">${data.error}</div>`;
                    return;
                }
                
                const folders = data.files.filter(item => item.isDirectory);
                
                if (folders.length === 0) {
                    folderList.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No subfolders</div>';
                    return;
                }
                
                folderList.innerHTML = folders.map(folder => `
                    <div onclick="browseFolders('${folder.path.replace(/'/g, "\\'")}');" 
                         style="padding: 10px 12px; cursor: pointer; border-radius: 4px; transition: background 0.15s; display: flex; align-items: center; gap: 8px; margin-bottom: 4px;"
                         onmouseover="this.style.background='var(--bg-tertiary)'" 
                         onmouseout="this.style.background='transparent'">
                        <span style="font-size: 18px;">📁</span>
                        <span style="font-size: 13px;">${folder.name}</span>
                    </div>
                `).join('');
                
            } catch (error) {
                folderList.innerHTML = `<div style="text-align: center; color: var(--error-color); padding: 20px;">Error: ${error.message}</div>`;
            }
        }
        
        async function navigateUp() {
            if (!currentBrowsePath || currentBrowsePath === '/') {
                showToast('Already at root', 'info');
                return;
            }

            const parentPath = currentBrowsePath.substring(0, currentBrowsePath.lastIndexOf('/')) || '/';
            await browseFolders(parentPath);
        }
        
        async function navigateToHome() {
            await browseFolders(getFolderBrowserStartPath());
        }
        
        function selectCurrentFolder() {
            if (!currentBrowsePath) {
                showToast('Please select a folder', 'error');
                return;
            }
            closeFolderBrowser();
            selectAndLoadFolder(currentBrowsePath, { setAsWorkingDirectory: true, forceBrainView: false });
        }

        async function selectAndLoadFolder(path, options = {}) {
            if (!path) return;
            folderPath = path;

            const brainPath = getConnectedBrainFolderPath();
            const isBrainPath = Boolean(brainPath && pathsEqual(path, brainPath));
            const shouldSetAsWorking = options.setAsWorkingDirectory === true || (!isBrainPath && options.setAsWorkingDirectory !== false);

            if (shouldSetAsWorking) {
                persistWorkingDirectory(path);
            }

            if (options.forceBrainView === true) {
                viewingBrainFolder = true;
            } else if (options.forceBrainView === false) {
                viewingBrainFolder = false;
            } else {
                viewingBrainFolder = isBrainPath;
            }

            await loadFileTree();
            refreshFolderContextButtons();

            if (options.toast !== false) {
                showToast(`Loaded: ${path.split('/').pop() || path}`, 'success');
            }
        }

        async function toggleBrainFolder() {
            const brainPath = getConnectedBrainFolderPath();
            if (!brainPath) {
                showToast('No brain connected', 'error');
                return;
            }

            const currentlyInBrainFolder = Boolean(folderPath && pathsEqual(folderPath, brainPath));

            if (currentlyInBrainFolder) {
                if (workingDirectory && !pathsEqual(workingDirectory, brainPath)) {
                    await selectAndLoadFolder(workingDirectory, { setAsWorkingDirectory: false, forceBrainView: false, toast: false });
                    showToast('Back to working folder', 'success');
                } else {
                    showToast('No working folder set yet. Choose a folder first.', 'info');
                    await showFolderBrowser(isWindows ? 'C:\\Users' : '/Users');
                }
                return;
            }

            if (folderPath && !pathsEqual(folderPath, brainPath)) {
                persistWorkingDirectory(folderPath);
            }

            await selectAndLoadFolder(brainPath, { setAsWorkingDirectory: false, forceBrainView: true, toast: false });
            showToast('Browsing connected brain folder', 'success');
        }
        
        function goToManualPath() {
            const input = document.getElementById('manual-path-input');
            const manualPath = input.value.trim();
            if (!manualPath) {
                showToast('Please enter a path', 'error');
                return;
            }

            // Navigate to that path in the browser
            browseFolders(manualPath);
        }

        // ============================================================================
        // COMMAND REGISTRY INITIALIZATION
        // ============================================================================
        
        function initializeCommands() {
            commands = [
                { id: 'file.save', label: 'Save File', action: saveCurrentFile, keys: 'Cmd+S' },
                { id: 'file.saveAll', label: 'Save All Files', action: saveAllFiles, keys: 'Cmd+Shift+S' },
                { id: 'file.close', label: 'Close File', action: () => { if (activeFile) closeTab(activeFile); }, keys: 'Cmd+W' },
                { id: 'file.closeOthers', label: 'Close Other Tabs', action: closeOtherTabs },
                { id: 'file.closeUnpinned', label: 'Close Unpinned Tabs', action: closeUnpinnedTabs },
                { id: 'file.download', label: 'Download Current File', action: downloadCurrentFile },
                { id: 'file.downloadAll', label: 'Download All Files', action: downloadAllFiles },
                { id: 'file.recent', label: 'Recent Files', action: showRecentFiles, keys: 'Cmd+E' },
                { id: 'file.new', label: 'New File', action: showNewFileDialog },
                { id: 'file.rename', label: 'Rename File', action: () => { if (activeFile) renameFileDialog(activeFile); } },
                { id: 'file.delete', label: 'Delete File', action: () => { if (activeFile) deleteFileDialog(activeFile); } },
                { id: 'export.html', label: 'Export Markdown to HTML', action: exportMarkdownToHTML },
                { id: 'export.pdf', label: 'Export Markdown to PDF', action: exportMarkdownToPDF },
                { id: 'view.toggleSidebar', label: 'Toggle Sidebar', action: toggleSidebar, keys: 'Cmd+B' },
                { id: 'view.togglePreview', label: 'Toggle Preview (MD/HTML/JSON/CSS/SVG/Images)', action: togglePreview, keys: 'Cmd+K V' },
                { id: 'terminal.toggle', label: 'Toggle Terminal Dock', action: () => window.toggleTerminalDock && window.toggleTerminalDock(), keys: 'Cmd+J' },
                { id: 'terminal.new', label: 'New Terminal Session', action: () => window.newTerminalSession && window.newTerminalSession(), keys: 'Cmd+Shift+`' },
                { id: 'terminal.focus', label: 'Focus Terminal', action: () => window.focusTerminal && window.focusTerminal(), keys: 'Ctrl+`' },
                { id: 'terminal.kill', label: 'Kill Active Terminal', action: () => window.killActiveTerminal && window.killActiveTerminal() },
                { id: 'view.settings', label: 'Open Settings', action: toggleSettings, keys: 'Cmd+,' },
                { id: 'editor.action.formatDocument', label: 'Format Document', action: () => editor && editor.getAction('editor.action.formatDocument').run() },
                { id: 'editor.find', label: 'Find', action: toggleSearch, keys: 'Cmd+F' },
                { id: 'editor.findInFiles', label: 'Find in All Files', action: showFindInFiles, keys: 'Cmd+Shift+F' },
                { id: 'tab.pin', label: 'Pin/Unpin Current Tab', action: () => { if (activeFile) togglePinTab(activeFile); } },
                { id: 'ai.toggle', label: 'Toggle AI Assistant', action: toggleAI, keys: 'Cmd+K A' },
                { id: 'ai.improve', label: 'AI: Improve Selection', action: () => aiQuickAction('improve') },
                { id: 'ai.grammar', label: 'AI: Check Grammar', action: () => aiQuickAction('grammar') },
                { id: 'ai.summarize', label: 'AI: Summarize', action: () => aiQuickAction('summarize') },
                { id: 'help.keyboard', label: 'Keyboard Shortcuts', action: toggleKeyboardHelp, keys: '?' },
            ];
            window.evobrewCommands = commands;
        }

        // ============================================================================
        // BRAIN STUDIO TAB SWITCHING
        // ============================================================================
        
        async function loadReadmeTab() {
          const contentEl = document.getElementById('readme-content');
          try {
            const response = await fetch('/api/folder/read?path=README.md');
            const data = await response.json();
            
            if (data.success && window.marked) {
              contentEl.innerHTML = renderMarkdownSafe(data.content);
              // Highlight code blocks
              contentEl.querySelectorAll('pre code').forEach((block) => {
                if (typeof hljs !== 'undefined') hljs.highlightElement(block);
              });
            } else {
              contentEl.innerHTML = `<div style="color: var(--error-color); padding: 20px;">Failed to load documentation.</div>`;
            }
          } catch (e) {
            console.error('Failed to load README:', e);
            contentEl.innerHTML = `<div style="color: var(--error-color); padding: 20px;">Error loading documentation.</div>`;
          }
        }

        // ============================================================================
        // FEATURE FLAGS - Check URL params, localStorage, or server config
        // ============================================================================
        function isFeatureEnabled(feature) {
          const urlParams = new URLSearchParams(window.location.search);
          if (urlParams.get('features')?.includes(feature)) return true;
          if (localStorage.getItem(`evobrew_feature_${feature}`) === 'true') return true;
          if (window.__EVOBREW_FEATURES__?.[feature]) return true;
          return false;
        }

        function switchBrainTab(tabName) {
          console.log('[EVOBREW] Switching to tab:', tabName);
          
          // Update mode description
          const modeDesc = document.getElementById('modeDescription');
          if (modeDesc) {
            if (tabName === 'readme') modeDesc.textContent = 'Platform documentation & guides';
            else if (tabName === 'query') modeDesc.textContent = 'Knowledge retrieval & synthesis';
            else if (tabName === 'files') modeDesc.textContent = 'Action-oriented workspace';
            else if (tabName === 'explore') modeDesc.textContent = 'Knowledge graph exploration';
            else if (tabName === 'hub') modeDesc.textContent = 'Brain package management';
            else if (tabName === 'openclaw') modeDesc.textContent = 'AI agent with memory & tools';
          }
          
          // Update tab buttons
          document.querySelectorAll('.tab-btn').forEach(btn => {
            const isActive = btn.dataset.tab === tabName;
            btn.classList.toggle('active', isActive);
          });
          
          // Update panels
          document.querySelectorAll('.brain-tab-panel').forEach(panel => {
            panel.style.display = panel.id === (tabName + '-tab-panel') ? 'flex' : 'none';
          });
          
          // AUTO-OPEN AI PANEL in Agent IDE
          if (tabName === 'files') {
            const aiPanel = document.getElementById('ai-panel');
            const aiBtn = document.getElementById('ai-btn');
            if (aiPanel) {
              aiPanel.classList.remove('hidden');
              if (aiBtn) aiBtn.classList.add('active');
            }
          } else if (tabName === 'readme' || tabName === 'explore' || tabName === 'hub' || tabName === 'openclaw') {
            // Auto-hide AI panel in documentation, explore, hub, openclaw modes to maximize space
            const aiPanel = document.getElementById('ai-panel');
            const aiBtn = document.getElementById('ai-btn');
            if (aiPanel && !aiPanel.classList.contains('hidden')) {
              toggleAI();
            }
          }

          // Initialize tabs on first view
          if (tabName === 'readme' && !window.readmeTabInitialized) {
            loadReadmeTab();
            window.readmeTabInitialized = true;
          }
          if (tabName === 'query' && !window.queryTabInitialized) {
            if (typeof initQueryTab === 'function') initQueryTab();
            window.queryTabInitialized = true;
          }
          if (tabName === 'explore' && !window.exploreTabInitialized) {
            if (typeof initExploreTab === 'function') initExploreTab();
            window.exploreTabInitialized = true;
          }
          
          // Resize explore graph when tab becomes visible
          if (tabName === 'explore' && window.exploreTabInitialized) {
            // Use setTimeout to ensure panel is visible before resize
            setTimeout(() => {
              if (typeof resizeGraph === 'function') resizeGraph();
            }, 50);
          }
          
          // Initialize OpenClaw chat on first view
          if (tabName === 'openclaw' && !window.openclawTabInitialized) {
            initOpenclawChat();
            window.openclawTabInitialized = true;
          }
        }
        
        // ============================================================================
        // OPENCLAW CHAT - WebSocket connection to OpenClaw Gateway
        // ============================================================================
        
        // UUID helper - fallback for non-secure contexts
        function openclawUuid() {
          if (typeof crypto !== 'undefined' && crypto.randomUUID) {
            return crypto.randomUUID();
          }
          // Fallback for HTTP/non-secure contexts
          return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
          });
        }
        
        let openclawWebSocket = null;
        let openclawPendingRequests = new Map();
        let openclawAuthenticated = false;
        let openclawConnectSent = false;
        
        // ===== Dynamic Model Selector =====
        async function populateModelSelector() {
          const select = document.getElementById('ai-model-select');
          if (!select) return;
          
          try {
            const res = await fetch('/api/providers/models');
            const data = await res.json();
            
            if (!data.success || !data.models?.length) {
              console.warn('[Models] No models returned, keeping defaults');
              return;
            }
            
            // Remember current selection
            const currentValue = select.value;
            
            // Group by provider
            const byProvider = {};
            data.models.forEach(m => {
              if (!byProvider[m.provider]) byProvider[m.provider] = [];
              byProvider[m.provider].push(m);
            });
            
            // Build options with optgroups
            select.innerHTML = '';
            for (const [provider, models] of Object.entries(byProvider)) {
              const group = document.createElement('optgroup');
              group.label = provider.charAt(0).toUpperCase() + provider.slice(1);
              models.forEach(m => {
                const opt = document.createElement('option');
                opt.value = m.id;
                opt.textContent = m.label || m.id;
                group.appendChild(opt);
              });
              select.appendChild(group);
            }
            
            // Restore selection if still available
            if ([...select.options].some(o => o.value === currentValue)) {
              select.value = currentValue;
            }
            
            // Update provider status indicator
            updateProviderStatus(data.providerCount);
            
            console.log(`[Models] Loaded ${data.models.length} models from ${data.providerCount} providers`);
          } catch (err) {
            console.error('[Models] Failed to load models:', err);
            // Keep existing hardcoded options as fallback
          }
        }
        
        function updateProviderStatus(count) {
          let badge = document.getElementById('provider-status-badge');
          if (!badge) {
            // Create badge next to model selector
            const modelContainer = document.getElementById('ai-model-select')?.parentElement;
            if (modelContainer) {
              badge = document.createElement('span');
              badge.id = 'provider-status-badge';
              badge.style.cssText = 'font-size: 9px; color: var(--success-color); margin-left: 8px; opacity: 0.8;';
              modelContainer.appendChild(badge);
            }
          }
          if (badge) {
            badge.textContent = `${count} provider${count !== 1 ? 's' : ''}`;
            badge.title = `${count} AI provider${count !== 1 ? 's' : ''} connected`;
          }
        }
        // ===== OpenClaw Connection Status =====
        function setupOpenClawModelHandler() {
          const select = document.getElementById('ai-model-select');
          if (!select) return;

          select.addEventListener('change', () => {
            if (select.value.startsWith('openclaw:')) {
              // Auto-connect to Gateway if not connected
              if (!openclawWebSocket || openclawWebSocket.readyState !== WebSocket.OPEN) {
                connectOpenclawWebSocket();
              }
              updateOpenClawStatus();
            } else {
              // Hide status dot when switching away
              const dot = document.getElementById('openclaw-status-dot');
              if (dot) dot.style.display = 'none';
            }
          });
        }

        function updateOpenClawStatus() {
          const select = document.getElementById('ai-model-select');
          if (!select || !select.value.startsWith('openclaw:')) return;

          let dot = document.getElementById('openclaw-status-dot');
          if (!dot) {
            const modelContainer = select.parentElement;
            if (modelContainer) {
              dot = document.createElement('span');
              dot.id = 'openclaw-status-dot';
              dot.style.cssText = 'display: inline-block; width: 7px; height: 7px; border-radius: 50%; margin-left: 6px; vertical-align: middle;';
              modelContainer.appendChild(dot);
            }
          }
          if (!dot) return;

          dot.style.display = 'inline-block';
          if (openclawAuthenticated && openclawWebSocket?.readyState === WebSocket.OPEN) {
            dot.style.background = 'var(--success-color)';
            dot.title = 'OpenClaw Gateway connected';
          } else if (openclawWebSocket?.readyState === WebSocket.CONNECTING || (openclawWebSocket?.readyState === WebSocket.OPEN && !openclawAuthenticated)) {
            dot.style.background = '#f0a030';
            dot.title = 'Connecting to OpenClaw Gateway...';
          } else {
            dot.style.background = 'var(--error-color)';
            dot.title = 'OpenClaw Gateway offline';
          }
        }
        // ===== End Dynamic Model Selector =====

        function initOpenclawChat() {
          console.log('[OpenClaw] Initializing chat connection...');
          connectOpenclawWebSocket();
        }
        
        function connectOpenclawWebSocket() {
          if (openclawWebSocket && openclawWebSocket.readyState === WebSocket.OPEN) return;
          
          // Reset authentication state
          openclawAuthenticated = false;
          openclawConnectSent = false;
          
          try {
            // Route WebSocket based on page protocol:
            // HTTPS → proxy through our server to avoid mixed-content block
            // HTTP  → connect directly to Gateway
            let wsUrl;
            // Always proxy through server to support remote access (LAN/Tailscale)
            if (window.location.protocol === 'https:') {
              wsUrl = 'wss://' + window.location.host + '/api/gateway-ws';
            } else {
              wsUrl = 'ws://' + window.location.host + '/api/gateway-ws';
            }
            console.log('[OpenClaw] Connecting to:', wsUrl);
            openclawWebSocket = new WebSocket(wsUrl);
            
            openclawWebSocket.onopen = () => {
              console.log('[OpenClaw] WebSocket opened, waiting for authentication challenge...');
              addOpenclawMessage('system', 'Connecting to OpenClaw Gateway...');
              updateOpenClawStatus();
            };
            
            openclawWebSocket.onmessage = (event) => {
              let data;
              try {
                data = JSON.parse(event.data);
              } catch (e) {
                console.error('[OpenClaw] JSON parse error:', e);
                return;
              }
              handleOpenclawMessage(data);
            };
            
            openclawWebSocket.onclose = () => {
              console.log('[OpenClaw] WebSocket disconnected');
              openclawAuthenticated = false;
              openclawConnectSent = false;
              addOpenclawMessage('system', 'Disconnected. Click to reconnect.', true);
              updateOpenClawStatus();
              // Clean up any in-flight OpenClaw main chat request
              if (openclawActive) {
                openclawActive = false;
                stopOpenClawPolling();
                openclawStreamEl = null;
                openclawStreamAccum = '';
                removeThinkingIndicator();
                addChatMessage('system', 'OpenClaw connection lost.');
                aiProcessing = false;
                document.getElementById('ai-send-btn').style.display = '';
                document.getElementById('ai-stop-btn').style.display = 'none';
              }
            };
            
            openclawWebSocket.onerror = (error) => {
              console.error('[OpenClaw] WebSocket error:', error);
              addOpenclawMessage('system', 'Connection error. Is OpenClaw Gateway running?');
            };
          } catch (e) {
            console.error('[OpenClaw] Failed to connect:', e);
            addOpenclawMessage('system', 'Failed to connect to Gateway');
          }
        }
        
        async function sendOpenclawConnect() {
          if (openclawConnectSent || !openclawWebSocket || openclawWebSocket.readyState !== WebSocket.OPEN) return;
          openclawConnectSent = true;

          // Generate or retrieve instance ID
          let instanceId = localStorage.getItem('evobrew-openclaw-instance-id');
          if (!instanceId) {
            instanceId = openclawUuid();
            localStorage.setItem('evobrew-openclaw-instance-id', instanceId);
          }

          // Fetch connect-level auth from server (credentials stay server-side)
          let auth = {};
          try {
            const authRes = await fetch('/api/gateway-auth');
            if (authRes.ok) auth = await authRes.json();
          } catch (e) {
            console.warn('[OpenClaw] Could not fetch gateway auth:', e.message);
          }

          const connectId = openclawUuid();
          openclawPendingRequests.set(connectId, 'connect');

          const connectRequest = {
            id: connectId,
            type: 'req',
            method: 'connect',
            params: {
              minProtocol: 3,
              maxProtocol: 3,
              client: {
                id: 'openclaw-control-ui',  // Use Control UI client ID for scope bypass
                version: 'dev',
                platform: navigator.platform || 'web',
                mode: 'webchat',
                instanceId: instanceId,
              },
              role: 'operator',
              scopes: ['operator.admin'],
              caps: [],
              auth,
              userAgent: navigator.userAgent,
              locale: navigator.language,
            }
          };

          console.log('[OpenClaw] Sending connect request...');
          openclawWebSocket.send(JSON.stringify(connectRequest));
        }
        
        const OPENCLAW_SIDEBAR_SESSION = 'evobrew:sidebar';

        function loadOpenclawHistory() {
          if (!openclawAuthenticated || !openclawWebSocket || openclawWebSocket.readyState !== WebSocket.OPEN) {
            console.log('[OpenClaw] Cannot load history - not authenticated');
            return;
          }
          
          const id = openclawUuid();
          openclawPendingRequests.set(id, 'history');
          openclawWebSocket.send(JSON.stringify({
            id: id,
            type: 'req',
            method: 'chat.history',
            params: {
              sessionKey: OPENCLAW_SIDEBAR_SESSION,
              limit: 50
            }
          }));
        }
        
        function handleOpenclawMessage(data) {
          // Handle authentication challenge
          if (data.type === 'event' && data.event === 'connect.challenge') {
            console.log('[OpenClaw] Received authentication challenge');
            sendOpenclawConnect();
            return;
          }
          
          // Handle response to our requests
          if (data.type === 'res' && data.id && openclawPendingRequests.has(data.id)) {
            const type = openclawPendingRequests.get(data.id);
            openclawPendingRequests.delete(data.id);
            
            if (type === 'connect') {
              if (data.ok) {
                console.log('[OpenClaw] Authentication successful');
                openclawAuthenticated = true;
                addOpenclawMessage('system', 'Connected and authenticated');
                updateOpenClawStatus();
                // Now we can load chat history
                loadOpenclawHistory();
              } else {
                console.error('[OpenClaw] Authentication failed:', data.error);
                addOpenclawMessage('system', 'Authentication failed: ' + (data.error?.message || 'Unknown error'));
              }
              return;
            } else if (type === 'history' && data.ok && data.payload?.messages) {
              // Clear welcome message and load history
              const container = document.getElementById('openclaw-messages');
              container.innerHTML = '';
              data.payload.messages.forEach(msg => {
                // Extract text from content (could be string or array of content blocks)
                let text = '';
                if (typeof msg.content === 'string') {
                  text = msg.content;
                } else if (Array.isArray(msg.content)) {
                  text = msg.content
                    .filter(c => c.type === 'text')
                    .map(c => c.text)
                    .join('\n');
                }
                if (text) addOpenclawMessage(msg.role, text);
              });
              if (data.payload.messages.length === 0) {
                addOpenclawMessage('system', 'No chat history. Start a conversation!');
              }
            } else if (type === 'main-chat') {
              // OpenClaw main chat send acknowledgement
              if (!data.ok) {
                console.error('[OpenClaw] Send failed:', data.error);
                removeThinkingIndicator();
                addChatMessage('error', 'OpenClaw send failed: ' + (data.error?.message || 'Unknown error'));
                stopOpenClawPolling();
                openclawActive = false;
              }
              return;
            } else if (type === 'send') {
              if (!data.ok) {
                console.error('[OpenClaw] Send message failed:', data.error);
                addOpenclawMessage('system', 'Failed to send message: ' + (data.error?.message || 'Unknown error'));
                stopOpenclawResponsePolling();
              }
              // Message sent - polling will pick up response
            } else if (type === 'poll' && data.ok && data.payload?.messages) {
              const messages = data.payload.messages;
              if (!messages || messages.length === 0) return;
              
              // Check if the LAST message is from assistant (that's our response!)
              const lastMsg = messages[messages.length - 1];
              console.log('[OpenClaw] Poll: last message role =', lastMsg.role, 'timestamp =', lastMsg.timestamp);
              
              // If last message is from assistant and newer than when we started polling
              if (lastMsg.role === 'assistant' && lastMsg.timestamp > openclawPollStartTimeSidebar) {
                console.log('[OpenClaw] Got assistant response!');
                
                // Remove "thinking" message
                const container = document.getElementById('openclaw-messages');
                const systemMsgs = container.querySelectorAll('.openclaw-system');
                systemMsgs.forEach(el => {
                  if (el.textContent.includes('thinking')) el.remove();
                });
                
                // Extract text content
                let content = '';
                if (typeof lastMsg.content === 'string') {
                  content = lastMsg.content;
                } else if (Array.isArray(lastMsg.content)) {
                  content = lastMsg.content
                    .filter(c => c.type === 'text')
                    .map(c => c.text)
                    .join('\n');
                }
                
                if (content) {
                  addOpenclawMessage('assistant', content);
                }
                
                // Stop polling
                stopOpenclawResponsePolling();
              }
            }
            return;
          }
          
          // Handle ALL Gateway events (agent, chat, health, tick, etc.)
          if (data.type === 'event') {
            const p = data.payload || data.params || {};
            const sk = p.sessionKey || '';
            const isMainChat = sk === 'evobrew:main' || sk.endsWith(':evobrew:main');
            const isSidebar = sk === OPENCLAW_SIDEBAR_SESSION || sk.endsWith(':' + OPENCLAW_SIDEBAR_SESSION);

            // Agent events: streaming deltas and lifecycle
            if (data.event === 'agent') {
              if (p.stream === 'assistant') {
                const delta = p.data?.delta || '';
                if (delta) {
                  if (isMainChat && openclawActive) {
                    openclawRenderedRunId = p.runId || data.payload?.runId;
                    handleOpenClawStream(delta);
                  } else if (isSidebar) {
                    appendToOpenclawStream(delta);
                  }
                }
              } else if (p.stream === 'lifecycle' && p.data?.phase === 'end') {
                if (isMainChat && openclawActive && openclawStreamEl) {
                  finalizeOpenClawStream();
                } else if (isSidebar && document.querySelector('.openclaw-stream')) {
                  finalizeOpenclawStream();
                }
              }
            }

            // Chat events: final response
            if (data.event === 'chat' && p.state === 'final') {
              let content = '';
              const msg = p.message;
              if (msg && msg.role === 'assistant') {
                if (typeof msg.content === 'string') {
                  content = msg.content;
                } else if (Array.isArray(msg.content)) {
                  content = msg.content
                    .filter(c => c.type === 'text')
                    .map(c => c.text)
                    .join('\n');
                }
              }

              // If we already rendered this run via streaming, ignore the final replay.
              // Some final events may omit runId; dedupe by content as a fallback.
              if (isMainChat && !openclawActive && content) {
                if (p.runId && p.runId === openclawRenderedRunId) return;
                if (!p.runId && openclawLastAssistantContent && content.trim() === openclawLastAssistantContent.trim()) return;
              }

              if (isMainChat && openclawActive) {
                stopOpenClawPolling();
                openclawRenderedRunId = p.runId || openclawRenderedRunId;

                if (openclawStreamEl) {
                  // We already streamed the content; just finalize the existing element.
                  // NOTE: finalizeOpenClawStream() also persists history.
                  openclawStreamAccum = content;
                  finalizeOpenClawStream();
                } else {
                  removeThinkingIndicator();
                  addChatMessage('assistant', content);
                  // Persist history for non-streaming path
                  aiConversationHistory.push(
                    { role: 'user', content: openclawLastUserMessage },
                    { role: 'assistant', content: content }
                  );
                  if (aiConversationHistory.length > 24) {
                    aiConversationHistory = aiConversationHistory.slice(-24);
                  }
                  chatHistory.saveMessage('user', openclawLastUserMessage);
                  chatHistory.saveMessage('assistant', content);
                  updateTokenCounter();
                  openclawActive = false;
                }

                document.getElementById('ai-send-btn').style.display = '';
                document.getElementById('ai-stop-btn').style.display = 'none';
              } else if (isMainChat && !openclawActive && content && p.runId !== openclawRenderedRunId) {
                // Proactive message — arrived without user prompt (and not already rendered via streaming)
                addChatMessage('assistant', '💬 ' + content);
                aiConversationHistory.push({ role: 'assistant', content: content });
                chatHistory.saveMessage('assistant', content);
              } else if (isSidebar && content) {
                stopOpenclawResponsePolling();
                addOpenclawMessage('assistant', content);
              }
            }

            return; // All events handled
          }
        }
        
        let openclawStreamElement = null;
        
        function appendToOpenclawStream(content) {
          if (!openclawStreamElement) {
            openclawStreamElement = document.createElement('div');
            openclawStreamElement.className = 'openclaw-message openclaw-assistant openclaw-stream';
            openclawStreamElement.style.cssText = 'padding: 12px 16px; border-radius: 12px; background: var(--bg-tertiary); max-width: 85%; align-self: flex-start; color: var(--text-primary); line-height: 1.5; white-space: pre-wrap;';
            document.getElementById('openclaw-messages').appendChild(openclawStreamElement);
          }
          openclawStreamElement.textContent += content;
          openclawStreamElement.scrollIntoView({ behavior: 'smooth' });
        }
        
        function finalizeOpenclawStream() {
          openclawStreamElement = null;
        }
        
        function addOpenclawMessage(role, content, clickToReconnect = false) {
          const container = document.getElementById('openclaw-messages');
          const msg = document.createElement('div');
          msg.className = `openclaw-message openclaw-${role}`;
          
          let bgColor, align;
          if (role === 'user') {
            bgColor = 'var(--accent-primary)';
            align = 'flex-end';
          } else if (role === 'system') {
            bgColor = 'transparent';
            align = 'center';
            msg.style.color = 'var(--text-secondary)';
            msg.style.fontSize = '12px';
            msg.style.fontStyle = 'italic';
          } else {
            bgColor = 'var(--bg-tertiary)';
            align = 'flex-start';
          }
          
          msg.style.cssText = `padding: ${role === 'system' ? '8px' : '12px 16px'}; border-radius: 12px; background: ${bgColor}; max-width: 85%; align-self: ${align}; color: ${role === 'user' ? 'white' : 'var(--text-primary)'}; line-height: 1.5; white-space: pre-wrap;`;
          msg.textContent = content;
          
          if (clickToReconnect) {
            msg.style.cursor = 'pointer';
            msg.onclick = () => {
              msg.remove();
              connectOpenclawWebSocket();
            };
          }
          
          container.appendChild(msg);
          msg.scrollIntoView({ behavior: 'smooth' });
        }
        
        function sendOpenclawMessage() {
          const input = document.getElementById('openclaw-input');
          const message = input.value.trim();
          if (!message) return;
          
          if (!openclawWebSocket || openclawWebSocket.readyState !== WebSocket.OPEN) {
            addOpenclawMessage('system', 'Not connected. Reconnecting...');
            connectOpenclawWebSocket();
            return;
          }
          
          if (!openclawAuthenticated) {
            addOpenclawMessage('system', 'Not authenticated. Please wait for connection...');
            return;
          }
          
          // Add user message to UI
          addOpenclawMessage('user', message);
          input.value = '';
          
          // Send to gateway
          const id = openclawUuid();
          openclawPendingRequests.set(id, 'send');
          openclawWebSocket.send(JSON.stringify({
            id: id,
            type: 'req',
            method: 'chat.send',
            params: {
              sessionKey: OPENCLAW_SIDEBAR_SESSION,
              message: message,
              idempotencyKey: openclawUuid()
            }
          }));

          // Start polling for response
          startOpenclawResponsePolling();
        }
        
        let openclawPollingIntervalSidebar = null;
        let openclawLastMessageCount = 0;
        let openclawPollStartTimeSidebar = 0;
        
        function startOpenclawResponsePolling() {
          // Stop any existing polling
          stopOpenclawResponsePolling();
          
          // Reset message count tracker
          openclawLastMessageCount = 0;
          
          // Add "thinking" indicator
          addOpenclawMessage('system', '⏳ Agent is thinking...');
          console.log('[OpenClaw] Starting response polling...');
          
          openclawPollStartTimeSidebar = Date.now();
          openclawPollingIntervalSidebar = setInterval(() => {
            // Timeout after 90 seconds
            if (Date.now() - openclawPollStartTimeSidebar > 90000) {
              stopOpenclawResponsePolling();
              addOpenclawMessage('system', '⏱️ Response timeout. The agent may still be working.');
              return;
            }
            pollOpenclawForResponse();
          }, 2000);
        }
        
        function stopOpenclawResponsePolling() {
          if (openclawPollingIntervalSidebar) {
            clearInterval(openclawPollingIntervalSidebar);
            openclawPollingIntervalSidebar = null;
          }
        }
        
        function pollOpenclawForResponse() {
          if (!openclawAuthenticated || !openclawWebSocket || openclawWebSocket.readyState !== WebSocket.OPEN) {
            console.log('[OpenClaw] Cannot poll - not connected');
            return;
          }
          console.log('[OpenClaw] Polling for response...');
          
          const id = openclawUuid();
          openclawPendingRequests.set(id, 'poll');
          openclawWebSocket.send(JSON.stringify({
            id: id,
            type: 'req',
            method: 'chat.history',
            params: {
              sessionKey: OPENCLAW_SIDEBAR_SESSION,
              limit: 10
            }
          }));
        }

        // ============================================================================
        // OPENCLAW MAIN CHAT INTEGRATION
        // ============================================================================

        let openclawPollingInterval = null;
        let openclawPollStartTime = 0;
        let openclawStreamEl = null;
        let openclawStreamAccum = ''; // Accumulate raw text for streaming
        let openclawLastUserMessage = ''; // Store original user message for history
        let openclawLastAssistantContent = ''; // Last assistant content already rendered (dedupe)
        // Track whether OpenClaw model is active for routing streaming events
        let openclawActive = false;
        let openclawRenderedRunId = null; // Track runId already rendered via streaming

        /**
         * Send message to OpenClaw Gateway with IDE context enrichment.
         * Called from sendAIMessage() when openclaw: model is selected.
         */
        async function sendViaOpenClaw(message, ctx) {
            // 1. Ensure connected and authenticated
            if (!openclawWebSocket || openclawWebSocket.readyState !== WebSocket.OPEN || !openclawAuthenticated) {
                connectOpenclawWebSocket();
                const authed = await new Promise(resolve => {
                    if (openclawAuthenticated) return resolve(true);
                    let attempts = 0;
                    const check = setInterval(() => {
                        if (openclawAuthenticated || ++attempts > 50) {
                            clearInterval(check);
                            resolve(openclawAuthenticated);
                        }
                    }, 100);
                });
                if (!authed) {
                    removeThinkingIndicator();
                    addChatMessage('error', 'OpenClaw Gateway not connected. Is it running on port 18789?');
                    return;
                }
            }

            // 2. Build context-enriched message
            let enrichedMessage = '';
            const hasContext = ctx.fileName || ctx.selectedText || ctx.brainEnabled;
            if (hasContext) {
                enrichedMessage += '[Evobrew IDE Context]\n';
                if (ctx.fileName) {
                    enrichedMessage += `File: ${ctx.fileName} (${ctx.language})\n`;
                    if (ctx.documentContent && ctx.documentContent.length > 0 && ctx.documentContent.length < 30000) {
                        enrichedMessage += '```' + ctx.language + '\n' + ctx.documentContent + '\n```\n';
                    }
                }
                if (ctx.selectedText) {
                    enrichedMessage += `Selected code:\n\`\`\`\n${ctx.selectedText}\n\`\`\`\n`;
                }
                if (ctx.brainEnabled && ctx.brainPath) {
                    enrichedMessage += `Brain: ${ctx.brainPath} (active)\n`;
                }
                if (ctx.fileTreeContext) {
                    enrichedMessage += `File tree:\n${ctx.fileTreeContext}\n`;
                }
                enrichedMessage += '[End Context]\n\n';
            }
            enrichedMessage += message;

            // 3. Send to Gateway
            openclawActive = true;
            openclawLastUserMessage = message;
            const id = openclawUuid();
            openclawPendingRequests.set(id, 'main-chat');
            openclawWebSocket.send(JSON.stringify({
                id,
                type: 'req',
                method: 'chat.send',
                params: {
                    sessionKey: 'evobrew:main',
                    message: enrichedMessage,
                    idempotencyKey: openclawUuid()
                }
            }));

            // 4. Response comes via event stream (agent/chat events)
            // Set a timeout as safety net
            startOpenClawTimeout();
        }

        function startOpenClawTimeout() {
            stopOpenClawPolling();
            openclawPollStartTime = Date.now();
            console.log('[OpenClaw] Waiting for agent response via event stream...');
            openclawPollingInterval = setTimeout(() => {
                if (openclawActive) {
                    removeThinkingIndicator();
                    addChatMessage('system', 'OpenClaw response timeout (2 min). The agent may still be working.');
                    openclawActive = false;
                    openclawStreamEl = null;
                    openclawStreamAccum = '';
                    document.getElementById('ai-send-btn').style.display = '';
                    document.getElementById('ai-stop-btn').style.display = 'none';
                }
            }, 120000);
        }

        function stopOpenClawPolling() {
            if (openclawPollingInterval) {
                clearTimeout(openclawPollingInterval);
                openclawPollingInterval = null;
            }
        }

        /**
         * Handle OpenClaw streaming chunk in main chat.
         */
        function handleOpenClawStream(content) {
            if (!openclawActive) return;
            if (!openclawStreamEl) {
                removeThinkingIndicator();
                openclawStreamAccum = '';
                openclawStreamEl = document.createElement('div');
                openclawStreamEl.className = 'ai-message assistant';
                openclawStreamEl.setAttribute('data-message-id', 'openclaw-stream-' + Date.now());
                openclawStreamEl.innerHTML = `
                    <div class="ai-message-header">🤖 AI Assistant (streaming...)</div>
                    <div class="ai-message-content">▋</div>
                `;
                document.getElementById('ai-chat-messages').appendChild(openclawStreamEl);
            }
            openclawStreamAccum += content;
            const contentDiv = openclawStreamEl.querySelector('.ai-message-content');
            if (contentDiv) {
                contentDiv.innerHTML = renderMarkdownSafe(openclawStreamAccum) + '▋';
            }
            openclawStreamEl.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }

        function finalizeOpenClawStream() {
            if (openclawStreamEl) {
                const finalContent = openclawStreamAccum;
                openclawLastAssistantContent = finalContent;
                // Update header and render final content
                const header = openclawStreamEl.querySelector('.ai-message-header');
                if (header) header.textContent = '🤖 AI Assistant';
                const contentDiv = openclawStreamEl.querySelector('.ai-message-content');
                if (contentDiv) {
                    contentDiv.innerHTML = renderMarkdownSafe(finalContent);
                    // Highlight code blocks
                    contentDiv.querySelectorAll('pre code').forEach(block => {
                        hljs.highlightElement(block);
                    });
                }
                aiConversationHistory.push(
                    { role: 'user', content: openclawLastUserMessage },
                    { role: 'assistant', content: finalContent }
                );
                if (aiConversationHistory.length > 24) {
                    aiConversationHistory = aiConversationHistory.slice(-24);
                }
                chatHistory.saveMessage('user', openclawLastUserMessage);
                chatHistory.saveMessage('assistant', finalContent);
                openclawStreamEl = null;
                openclawStreamAccum = '';
                stopOpenClawPolling();
                openclawActive = false;
                updateTokenCounter();
            }
        }

        // ============================================================================
        // INITIALIZATION - Setup auto-save on load
        // ============================================================================
        
        initializeCommands();
        setupAutoSave();
        
        // Initialize panel resizing after DOM loaded
        document.addEventListener('DOMContentLoaded', async () => {
            initPanelResizing();
            restorePanelSizes();
            let configData = null;
            
            // Fetch config to show/hide features
            try {
                const configRes = await fetch('/api/config');
                configData = await configRes.json();
                window.evobrewConfig = configData;
                window.uiRefreshEnabled = configData.features?.ui_refresh_v1 !== false;
                
                // Show/hide OpenClaw tab based on config
                const openclawTab = document.querySelector('.openclaw-tab');
                if (openclawTab) {
                    if (configData.openclaw?.enabled) {
                        openclawTab.style.display = '';
                        // Set custom tab name if configured
                        const tabName = openclawTab.querySelector('.openclaw-tab-name');
                        if (tabName && configData.openclaw.tab_name) {
                            tabName.textContent = configData.openclaw.tab_name;
                        }
                        // Update welcome title
                        const welcomeTitle = document.getElementById('openclaw-welcome-title');
                        if (welcomeTitle && configData.openclaw.tab_name) {
                            welcomeTitle.textContent = configData.openclaw.tab_name + ' Agent';
                        }
                    } else {
                        openclawTab.style.display = 'none';
                    }
                }
                
                // Show/hide brain picker based on config
                const brainPicker = document.getElementById('brainPickerBtn');
                if (brainPicker && !configData.features?.brains?.enabled) {
                    brainPicker.style.display = 'none';
                }
                
                // Hide Query and Explore tabs if brains disabled
                if (!configData.features?.brains?.enabled) {
                    const queryTab = document.querySelector('[data-tab="query"]');
                    const exploreTab = document.querySelector('[data-tab="explore"]');
                    if (queryTab) queryTab.style.display = 'none';
                    if (exploreTab) exploreTab.style.display = 'none';
                }
                
                console.log('[Config] Features:', configData.features);
            } catch (err) {
                window.uiRefreshEnabled = true;
                console.warn('[Config] Could not fetch config:', err.message);
            }

            window.dispatchEvent(new CustomEvent('evobrew:ui-refresh-toggle', {
                detail: { enabled: window.uiRefreshEnabled !== false, config: configData }
            }));
            
            // Populate AI model selector from API
            populateModelSelector();
            setupOpenClawModelHandler();

            // Set initial tab state
            switchBrainTab('files');

            const brainToggle = document.getElementById('brainEnabled');
            const pgsToggle = document.getElementById('query-pgs');
            if (brainToggle && !brainToggle.dataset.boundContextSync) {
                brainToggle.addEventListener('change', syncBrainContextControls);
                brainToggle.dataset.boundContextSync = 'true';
            }
            if (pgsToggle && !pgsToggle.dataset.boundContextSync) {
                pgsToggle.addEventListener('change', syncBrainContextControls);
                pgsToggle.dataset.boundContextSync = 'true';
            }
            syncBrainContextControls();
            refreshFolderContextButtons();
            
            // Hard fail-safe: if any modal/overlay got stuck open from a prior session, close it.
            try { closeAllModals(); } catch (e) {}

            // Check if brain is loaded and auto-open its output folder
            try {
                const brainInfo = await fetch('/api/brain/info').then(r => r.json());
                window.currentBrainInfo = brainInfo;
                
                if (brainInfo.hasBrain) {
                    // Update title with brain name
                    const stats = await fetch('/api/brain/stats').then(r => r.json());
                    document.getElementById('brainStudioTitle').textContent = `Brain Studio · ${brainInfo.brainName} · ${stats.nodes} nodes`;
                    updateBrainLabel(brainInfo.brainName, stats.nodes);

                    // Enable brain toggle
                    if (brainToggle) {
                        brainToggle.disabled = false;
                        brainToggle.checked = true;
                        console.log(`✅ Brain loaded: ${stats.nodes} nodes - brain context injection enabled`);
                    }
                    
                    // Store brain's output folder for "Browse Brain" feature
                    // but do NOT change the working directory
                    if (brainInfo.outputsPath) {
                        console.log('Brain outputs available at:', brainInfo.outputsPath);
                        window.brainOutputsPath = brainInfo.outputsPath;
                        // Only auto-load brain folder if no folder is currently selected
                        if (!folderPath) {
                            await selectAndLoadFolder(brainInfo.outputsPath, {
                                setAsWorkingDirectory: false,
                                forceBrainView: true
                            });
                        }
                    } else {
                        window.brainOutputsPath = null;
                    }

                    if (folderPath) {
                        if (!window.brainOutputsPath || !pathsEqual(folderPath, window.brainOutputsPath)) {
                            persistWorkingDirectory(folderPath);
                            viewingBrainFolder = false;
                        } else {
                            viewingBrainFolder = true;
                        }
                    }
                    syncBrainContextControls();
                    refreshFolderContextButtons();
                } else {
                    document.getElementById('brainStudioTitle').textContent = 'Brain Studio (IDE Mode)';
                    window.brainOutputsPath = null;
                    updateBrainLabel(null);
                    viewingBrainFolder = false;
                    if (folderPath) {
                        persistWorkingDirectory(folderPath);
                    }

                    // Disable brain toggle when no brain loaded
                    if (brainToggle) {
                        brainToggle.disabled = true;
                        brainToggle.checked = false;
                        console.log('⚠️ No brain loaded - brain toggle disabled');
                    }
                    if (pgsToggle) {
                        pgsToggle.checked = false;
                    }
                    syncBrainContextControls();
                    refreshFolderContextButtons();

                    // Keep startup non-blocking. Show guided empty-state instead of forcing a modal.
                    setTimeout(() => {
                        if (window.UIRefreshOnboarding?.updateVisibility) {
                            window.UIRefreshOnboarding.updateVisibility();
                        }
                    }, 150);
                }
            } catch (error) {
                console.error('Failed to load brain info:', error);
                document.getElementById('brainStudioTitle').textContent = 'Brain Studio (IDE Mode)';
                updateBrainLabel(null);
                if (brainToggle) {
                    brainToggle.disabled = true;
                    brainToggle.checked = false;
                }
                if (pgsToggle) {
                    pgsToggle.checked = false;
                }
                syncBrainContextControls();
                refreshFolderContextButtons();
            }
        });
    </script>
    
    <script>
      (function () {
        const notifyUnavailable = () => {
          const message = 'Terminal is not available. Verify terminal assets and restart Evobrew.';
          if (typeof window.showToast === 'function') {
            window.showToast(message, 'error');
          } else {
            console.warn(`[terminal] ${message}`);
          }
        };

        if (typeof window.toggleTerminalDock !== 'function') {
          window.toggleTerminalDock = notifyUnavailable;
        }
        if (typeof window.newTerminalSession !== 'function') {
          window.newTerminalSession = notifyUnavailable;
        }
        if (typeof window.focusTerminal !== 'function') {
          window.focusTerminal = () => {
            notifyUnavailable();
          };
        }
        if (typeof window.killActiveTerminal !== 'function') {
          window.killActiveTerminal = notifyUnavailable;
        }
      })();
    </script>

    <script>
      (function () {
        try {
          const hasOwnDefine = Object.prototype.hasOwnProperty.call(window, 'define');
          window.__evobrewTerminalDefineState = {
            hasOwnDefine: hasOwnDefine,
            define: window.define
          };
          window.define = undefined;
        } catch (_) {
          // Best effort only; if assignment fails, continue without modifying loader state.
        }
      })();
    </script>
    <script src="/vendor/xterm/lib/xterm.js"></script>
    <script src="/vendor/xterm-addon-fit/lib/addon-fit.js"></script>
    <script src="/vendor/xterm-addon-web-links/lib/addon-web-links.js"></script>
    <script src="/vendor/xterm-addon-search/lib/addon-search.js"></script>
    <script src="/vendor/xterm-addon-serialize/lib/addon-serialize.js"></script>
    <script>
      (function () {
        const state = window.__evobrewTerminalDefineState;
        if (!state) return;

        try {
          if (state.hasOwnDefine) {
            window.define = state.define;
          } else {
            try {
              delete window.define;
            } catch (_) {
              window.define = state.define;
            }
          }
        } finally {
          try {
            delete window.__evobrewTerminalDefineState;
          } catch (_) {
            window.__evobrewTerminalDefineState = undefined;
          }
        }
      })();
    </script>
    <script src="js/terminal.js"></script>

    <!-- Brain Studio Tab Modules -->
    <script src="js/query-tab.js"></script>
    <script src="js/explore-tab.js"></script>
    <script src="js/ui-panels.js"></script>
    <script src="js/ui-onboarding.js"></script>
    <script src="js/ui-shortcuts.js"></script>
    <script src="js/ui-shell.js"></script>

    <!-- Brain Picker Modal -->
    <div id="brainPickerModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; z-index:10000; background:rgba(0,0,0,0.5); align-items:center; justify-content:center;">
      <div style="background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:12px; max-width:520px; width:90vw; max-height:70vh; display:flex; flex-direction:column; box-shadow:0 8px 32px rgba(0,0,0,0.4);">
        <div style="padding:16px 20px; border-bottom:1px solid var(--border-color); display:flex; justify-content:space-between; align-items:center;">
          <h3 style="margin:0; font-size:15px; color:var(--text-primary);">🧠 Connect Brain</h3>
          <button onclick="toggleBrainPicker()" style="background:none; border:none; color:var(--text-secondary); cursor:pointer; font-size:18px; min-width:44px; min-height:44px; display:flex; align-items:center; justify-content:center;">✕</button>
        </div>
        <!-- Location tabs -->
        <div id="brainPickerLocations" style="padding:8px 12px; border-bottom:1px solid var(--border-color); display:flex; gap:6px; flex-wrap:wrap;">
          <div style="color:var(--text-secondary); font-size:12px; padding:4px;">Loading locations...</div>
        </div>
        <div style="padding:8px 12px; border-bottom:1px solid var(--border-color);">
          <input id="brainPickerSearch" type="text" placeholder="Filter brains..." style="width:100%; padding:8px 12px; background:var(--bg-primary); border:1px solid var(--border-color); border-radius:6px; color:var(--text-primary); font-size:13px; outline:none; box-sizing:border-box;" oninput="filterBrainList(this.value)">
        </div>
        <div id="brainPickerList" class="hub-brain-list" style="flex:1; overflow-y:auto; padding:8px; -webkit-overflow-scrolling:touch; overscroll-behavior:contain;">
          <div style="text-align:center; padding:20px; color:var(--text-secondary);">Choose a location above</div>
        </div>
      </div>
    </div>

    <script>
    // Brain Picker functionality — two-step: locations → brains
    let brainPickerOpen = false;
    let _bpSelectedLocation = null;
    let _bpLocations = null;

    const _locationColors = {
      'cosmo-home': '#10b981',
      'main': '#0d9488',
      'bertha': '#7c3aed',
      'bertha/testing': '#a78bfa'
    };

    function toggleBrainPicker() {
      brainPickerOpen = !brainPickerOpen;
      const modal = document.getElementById('brainPickerModal');
      modal.style.display = brainPickerOpen ? 'flex' : 'none';
      if (brainPickerOpen) {
        const searchInput = document.getElementById('brainPickerSearch');
        if (searchInput) { searchInput.value = ''; }
        fetchBrainLocations();
      }
    }

    // Close on backdrop click
    document.getElementById('brainPickerModal').addEventListener('click', function(e) {
      if (e.target === this) toggleBrainPicker();
    });

    // Close on Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && brainPickerOpen) {
        toggleBrainPicker();
      }
    });

    // Filter brain list by search text
    function filterBrainList(query) {
      const items = document.querySelectorAll('#brainPickerList .hub-brain-item');
      const q = query.toLowerCase();
      items.forEach(item => {
        const name = item.textContent.toLowerCase();
        item.style.display = name.includes(q) ? '' : 'none';
      });
    }

    async function fetchBrainLocations() {
      const locEl = document.getElementById('brainPickerLocations');
      const listEl = document.getElementById('brainPickerList');
      try {
        const res = await fetch('/api/brains/locations');
        if (!res.ok) throw new Error(`locations ${res.status}`);
        const data = await res.json();
        if (!data.success) throw new Error('Failed to load locations');
        _bpLocations = data.locations.filter(l => l.available && l.brainCount > 0);
        locEl.innerHTML = _bpLocations.map(loc => {
          const color = _locationColors[loc.label] || '#6b7280';
          return `<button onclick="selectBrainLocation('${loc.label}')" 
            id="bp-loc-${loc.label.replace(/[^a-z0-9]/gi,'_')}"
            style="padding:6px 12px; border-radius:6px; border:1px solid ${color}40; background:${color}15; 
            color:${color}; cursor:pointer; font-size:12px; font-weight:500; transition:all 0.15s;"
            onmouseover="this.style.background='${color}30'" onmouseout="this.style.background=this.classList.contains('bp-active')?'${color}30':'${color}15'">
            ${loc.label} <span style="opacity:0.7">(${loc.brainCount})</span>
          </button>`;
        }).join('');

        // Auto-select cosmo-home if available, otherwise first
        const defaultLoc = _bpLocations.find(l => l.label === 'cosmo-home') || _bpLocations[0];
        if (defaultLoc) selectBrainLocation(defaultLoc.label);
        else listEl.innerHTML = '<div style="text-align:center; padding:20px; color:var(--text-secondary);">No brain locations found</div>';
      } catch (err) {
        // Fallback: locations endpoint not present — hide location row and use flat list
        if (locEl) {
          locEl.style.display = 'none';
        }
        _bpSelectedLocation = null;
        await fetchBrainList(null);
      }
    }

    async function selectBrainLocation(label) {
      _bpSelectedLocation = label;
      // Update active tab styling
      document.querySelectorAll('#brainPickerLocations button').forEach(btn => {
        btn.classList.remove('bp-active');
        const isThis = btn.id === `bp-loc-${label.replace(/[^a-z0-9]/gi,'_')}`;
        const color = _locationColors[label] || '#6b7280';
        if (isThis) {
          btn.classList.add('bp-active');
          btn.style.background = color + '30';
          btn.style.borderColor = color;
          btn.style.fontWeight = '700';
        } else {
          const origLabel = btn.textContent.trim().split(' ')[0];
          const origColor = _locationColors[origLabel] || '#6b7280';
          btn.style.background = origColor + '15';
          btn.style.borderColor = origColor + '40';
          btn.style.fontWeight = '500';
        }
      });
      await fetchBrainList(label);
    }

    async function fetchBrainList(location) {
      const listEl = document.getElementById('brainPickerList');
      listEl.innerHTML = '<div style="text-align:center; padding:20px; color:var(--text-secondary);">Loading brains...</div>';
      try {
        const url = location ? `/api/brains/list?location=${encodeURIComponent(location)}` : '/api/brains/list';
        const res = await fetch(url);
        const data = await res.json();
        if (!data.success || !data.brains.length) {
          listEl.innerHTML = '<div style="text-align:center; padding:20px; color:var(--text-secondary);">No brains in this location</div>';
          return;
        }
        const infoRes = await fetch('/api/brain/info');
        const info = await infoRes.json();
        const currentPath = info.brainPath || null;
        const color = _locationColors[location] || '#6b7280';

        listEl.innerHTML = data.brains.map(b => {
          const isActive = currentPath && b.path === currentPath;
          const nodeText = b.nodes !== null
            ? (b.estimated ? '~' : '') + b.nodes.toLocaleString() + ' nodes'
            : 'unknown size';
          return `<div class="hub-brain-item ${isActive ? 'selected' : ''}" data-brain-path="${b.path}" onclick="pickBrain('${b.path.replace(/'/g, "\\'")}')" style="cursor:pointer;">
            <div class="hub-brain-item-header">
              <div class="hub-brain-item-info">
                <div class="hub-brain-item-name"><span>${b.name}</span>${isActive ? ' <span style="color:var(--accent-primary); font-size:10px;">● active</span>' : ''}</div>
                <div class="hub-brain-item-meta">${nodeText}</div>
              </div>
            </div>
          </div>`;
        }).join('');
      } catch (err) {
        listEl.innerHTML = `<div style="text-align:center; padding:20px; color:#f87171;">Error: ${err.message}</div>`;
      }
    }

    async function pickBrain(brainPath) {
      const listEl = document.getElementById('brainPickerList');
      // Find and update the clicked item
      const items = listEl.querySelectorAll('.hub-brain-item');
      items.forEach(item => {
        if (item.dataset?.brainPath === brainPath) {
          item.style.opacity = '0.6';
          item.innerHTML = '<div style="padding:8px; text-align:center; color:var(--text-secondary);">⏳ Loading brain...</div>';
        }
      });
      try {
        const res = await fetch('/api/brain/load', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path: brainPath })
        });
        const data = await res.json();
        if (!data.success) throw new Error(data.error);
        // Update header
        updateBrainLabel(data.brain.name, data.brain.nodes);
        // Update IDE title bar
        document.getElementById('brainStudioTitle').textContent = `Brain Studio · ${data.brain.name} · ${data.brain.nodes} nodes`;
        // Enable brain toggle
        const brainToggle = document.getElementById('brainEnabled');
        const pgsToggle = document.getElementById('query-pgs');
        if (brainToggle) {
          brainToggle.disabled = false;
          brainToggle.checked = true;
        }
        if (pgsToggle) {
          pgsToggle.checked = false;
        }
        syncBrainContextControls();
        // Update cached brain info — re-fetch full info to preserve isAdmin, outputsPath, etc.
        try {
          const freshInfo = await fetch('/api/brain/info').then(r => r.json());
          window.currentBrainInfo = freshInfo;
          if (freshInfo.outputsPath) {
            window.brainOutputsPath = freshInfo.outputsPath;
          } else {
            window.brainOutputsPath = null;
          }
        } catch (_e) {
          // Fallback if info endpoint fails
          window.currentBrainInfo = { hasBrain: true, brainName: data.brain.name, brainPath: data.brain.path || brainPath };
          window.brainOutputsPath = null;
        }
        refreshFolderContextButtons();
        // Reset stale state: refresh explore tab if loaded
        if (typeof initExploreGraph === 'function') { try { initExploreGraph(); } catch(e) {} }
        // Reload query history for new brain
        if (typeof _qt_loadHistory === 'function') { try { _qt_loadHistory(); } catch(e) {} }
        // Clear chat context referencing old brain
        if (typeof chatMessages !== 'undefined' && Array.isArray(chatMessages)) {
          chatMessages.length = 0;
          const chatEl = document.getElementById('chatMessages');
          if (chatEl) chatEl.innerHTML = '<div style="text-align:center; padding:12px; color:var(--text-secondary); font-size:12px;">Brain switched to ' + data.brain.name + '. Chat context cleared.</div>';
        }
        // Close modal
        toggleBrainPicker();
        // Show success toast if available
        if (typeof showToast === 'function') {
          showToast(`Brain loaded: ${data.brain.name}. Folder stays unchanged; use Brain Folder button to browse brain files.`, 'success');
        }
      } catch (err) {
        if (typeof showToast === 'function') {
          showToast(`Failed to load brain: ${err.message}`, 'error');
        } else {
          alert('Failed to load brain: ' + err.message);
        }
        fetchBrainList(_bpSelectedLocation); // refresh list
      }
    }

    function updateBrainLabel(name, nodes) {
      const label = document.getElementById('brainPickerLabel');
      const btn = document.getElementById('brainPickerBtn');
      if (name) {
        label.textContent = name;
        btn.style.borderColor = 'var(--accent-primary)';
        btn.style.color = 'var(--text-primary)';
        btn.setAttribute('title', `Loaded brain: ${name}. Click to load or switch brain.`);
      } else {
        label.textContent = 'No Brain';
        btn.style.borderColor = 'var(--border-color)';
        btn.style.color = 'var(--text-secondary)';
        btn.setAttribute('title', 'Connect or switch brain');
      }
    }

    // On page load, check current brain status
    fetch('/api/brain/info').then(r => r.json()).then(info => {
      if (info.hasBrain) {
        updateBrainLabel(info.brainName);
      } else {
        updateBrainLabel(null);
      }
    }).catch(() => {
      updateBrainLabel(null);
    });
    </script>

    <!-- Tablet Panel Switching Logic -->
    <script>
    (function() {
      function isTabletPortrait() {
        return window.innerWidth <= 900;
      }

      window.tabletShowPanel = function(panel) {
        if (!isTabletPortrait()) return;
        const sidebar = document.getElementById('sidebar');
        const aiPanel = document.getElementById('ai-panel');
        const sidebarBackdrop = document.getElementById('tablet-sidebar-backdrop');
        const aiBackdrop = document.getElementById('tablet-ai-backdrop');
        const btns = {
          files: document.getElementById('tablet-btn-files'),
          editor: document.getElementById('tablet-btn-editor'),
          chat: document.getElementById('tablet-btn-chat')
        };

        // Reset all
        if (sidebar) sidebar.classList.remove('tablet-open');
        if (aiPanel) aiPanel.classList.remove('tablet-open');
        if (sidebarBackdrop) sidebarBackdrop.classList.remove('visible');
        if (aiBackdrop) aiBackdrop.classList.remove('visible');
        Object.values(btns).forEach(b => b && b.classList.remove('active'));

        if (panel === 'files' && sidebar) {
          sidebar.classList.add('tablet-open');
          if (sidebarBackdrop) sidebarBackdrop.classList.add('visible');
          if (btns.files) btns.files.classList.add('active');
        } else if (panel === 'chat' && aiPanel) {
          aiPanel.classList.add('tablet-open');
          if (aiBackdrop) aiBackdrop.classList.add('visible');
          if (btns.chat) btns.chat.classList.add('active');
        } else {
          // editor — just close drawers
          if (btns.editor) btns.editor.classList.add('active');
        }
      };

      window.closeTabletSidebar = function() {
        const sidebar = document.getElementById('sidebar');
        const backdrop = document.getElementById('tablet-sidebar-backdrop');
        const btn = document.getElementById('tablet-btn-editor');
        if (sidebar) sidebar.classList.remove('tablet-open');
        if (backdrop) backdrop.classList.remove('visible');
        // Set editor as active
        document.querySelectorAll('.tablet-panel-bar button').forEach(b => b.classList.remove('active'));
        if (btn) btn.classList.add('active');
      };

      window.closeTabletAI = function() {
        const aiPanel = document.getElementById('ai-panel');
        const backdrop = document.getElementById('tablet-ai-backdrop');
        const btn = document.getElementById('tablet-btn-editor');
        if (aiPanel) aiPanel.classList.remove('tablet-open');
        if (backdrop) backdrop.classList.remove('visible');
        document.querySelectorAll('.tablet-panel-bar button').forEach(b => b.classList.remove('active'));
        if (btn) btn.classList.add('active');
      };

      // On resize, clean up tablet classes if we leave portrait
      window.addEventListener('resize', function() {
        if (!isTabletPortrait()) {
          document.querySelectorAll('.tablet-open').forEach(el => el.classList.remove('tablet-open'));
          document.querySelectorAll('.tablet-sidebar-backdrop.visible, .tablet-ai-backdrop.visible')
            .forEach(el => el.classList.remove('visible'));
        }
      });
    })();
    </script>
</body>
</html>
